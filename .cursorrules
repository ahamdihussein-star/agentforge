# AgentForge AI Development Rules

## ðŸ“š START HERE - READ FIRST!

**Before starting any work, read `PROJECT_STATUS.md`** for:
- Current project state and completion status
- All completed features (Access Control, Delegated Admin, Groups, etc.)
- Architecture overview
- Key files and their purposes
- Important implementation details

### ðŸ“– Documentation Structure:
| File | Purpose | Read When |
|------|---------|-----------|
| `PROJECT_STATUS.md` | **Current state, quick reference** | Always (primary) |
| `.cursorrules` | Development rules | Auto-loaded |
| `database/COMMON_ISSUES.md` | DB patterns & issues | Before DB work |
| `docs/MASTER_DOCUMENTATION_UPDATED.md` | **Canonical engineering documentation** (architecture, services, security, DB, gaps, file reference) | Deep reference |
| `docs/PROCESS_BUILDER_KB_*.md` | **Runtime Process Builder KB** (used for grounded generation) | When updating process generation |

### ðŸ”‘ Key Concepts (Quick Reference):
- **Owner**: Agent creator, always has full access
- **Delegated Admin**: Admin with limited task permissions
- **Task Permissions**: Match by **NAME** (not ID) - IDs change on wizard load
- **Agents are PRIVATE by default**: Only owner can see

---

## ðŸ›ï¸ ENTERPRISE & GOVERNMENT STANDARDS (MANDATORY)

This platform is designed for **Large Enterprises & Government Agencies**.
Every line of code and UI element must meet Global Enterprise Standards.

### 1. The "Civil Servant" UX Standard (Non-Technical Users)
- **Zero Jargon:** Never expose terms like "JSON", "UUID", "Endpoint", "Latency", or "Stack Trace".
- **Self-Healing:** If an error occurs, the system must suggest a fix in plain language (e.g., "Manager missing" instead of "NullReferenceException").
- **Accessibility:** UI must be clear, high-contrast, and intuitive. Think "GovTech" simplicity.
- **Fail-Safe:** A non-technical user should NEVER be able to break the system or corrupt data through the UI.

### 2. Enterprise Security & Zero Trust
- **Data Isolation:** Every database query MUST be scoped by `org_id`. Never trust user input to define the scope.
- **RBAC Enforcement:** Permissions are checked at the **Service Layer**, not just the UI.
- **Audit Trails:** Critical actions (Process modifications, Approvals, User changes) must be logged/traceable.
- **No Hardcoded Secrets:** Credentials, API keys, and sensitive config must come from Environment Variables or Secure Vaults.

### 3. Scalability & Performance
- **Stateless Architecture:** The backend services must remain stateless to allow horizontal scaling (Kubernetes ready).
- **Async by Default:** Long-running tasks (AI generation, heavy processing) must be handled asynchronously (background tasks) to keep the UI responsive.
- **Optimized Queries:** Avoid N+1 query problems. Use proper indexing on Foreign Keys.

### 4. Global Best Practices
- **Idempotency:** Repeating a request (e.g., clicking "Approve" twice) must not cause side effects (like double payment).
- **Graceful Degradation:** If the AI service is down, the rest of the platform (Manual Approvals, Dashboard) must continue to work.

---

## ðŸ§  PROCESS BUILDER PHILOSOPHY

### 1. Business-Friendly & No-Code First
- **UI/UX**: Never display raw JSON or object dumps. Use `_format_value_for_display`.
- **Notifications**: Emails and reports must be human-readable business text.

### 2. Identity-Aware & Dynamic
- **Context**: The system runs on `_user_context` (User, Manager, Org).
- **Routing**: Approvals resolve recipients dynamically (e.g., "requester's manager") at runtime.
- **Validation**: "Pre-flight Checks" warn users about missing identity data before execution.

### 3. Anti-Hallucination & Reliability
- **Separation of Concerns**: `config.prompt` is for the Task. `config.instructions` (Array) is for Rules.
- **Strict Extraction**: Data extraction defaults to `creativity: 2`.
- **Validation**: Use `_cross_reference_items_with_source` to verify AI output against source files.

### 4. Zero Hardcoding & Universal Dynamism (True Platform)
- **Generic Engine**: The platform must support **ANY** domain (HR, Finance, Legal, Gov, Healthcare).
- **FORBIDDEN**: Never hardcode logic for a specific use case (e.g., `if process_name == 'Expense'`).
- **Config-Driven**: Any new capability (e.g., "Tax Calculation") must be implemented as a **GENERIC** feature (e.g., "Formula Field" or "AI Instruction") configurable by the user.
- **Future-Proof**: Changes must not break existing processes. New features should be opt-in or backward compatible.
- **Dynamic Building**: The user (or AI Wizard) defines the logic via configuration; the Code only provides the building blocks.

---

## ðŸš¨ CRITICAL - READ BEFORE ANY DATABASE WORK!

### MANDATORY PRE-WORK CHECKLIST:

**BEFORE touching ANY database file:**
1. âœ… Read `database/COMMON_ISSUES.md` (7 documented issues)
2. âœ… Run `./scripts/comprehensive_db_check.sh`
3. âœ… Check `.cursorrules` for latest rules

**BEFORE committing:**
1. âœ… Run `./scripts/comprehensive_db_check.sh` (auto-runs via pre-commit hook)
2. âœ… Verify: `python3 -c "from database.models import *"` (or `python` if available)
3. âœ… Review changes against COMMON_ISSUES.md

---

## ðŸš¨ CRITICAL - DATABASE RULES (READ FIRST!)

### MANDATORY: Review Recurring Patterns Before ANY Database Work!
**BEFORE touching database code, you MUST:**
1. âœ… Read `database/COMMON_ISSUES.md` â†’ **"RECURRING PATTERNS"** section (Lines 9-150)
2. âœ… Check if your current task matches any recurring pattern
3. âœ… Follow the prevention checklist for that pattern

**Most Critical Recurring Patterns:**
- âš ï¸ **Pattern #1:** Incomplete Schema Mapping (Issues #14, #20, #21)
  - **Before creating models:** List ALL Pydantic fields â†’ Map ALL to SQLAlchemy â†’ Map ALL to migration
  - **Checklist:** Write down every field, check off as you add it
  
- âš ï¸ **Pattern #2:** Reserved SQLAlchemy Words (Issue #1)
  - **Check:** `grep -r "metadata = Column" database/models/` (should be empty!)
  
- âš ï¸ **Pattern #3:** PostgreSQL-Specific Types (Issues #6, #8, #9)
  - **Check:** `grep -r "from sqlalchemy.dialects.postgresql" database/models/` (should be empty!)

### Reserved SQLAlchemy Words (NEVER USE):
- âŒ `metadata` (use `extra_metadata`, `user_metadata`, or `custom_data`)
- âŒ `registry`
- âŒ `__tablename__` (already used)
- âŒ `__mapper__`
- âŒ `__table__`

### Quick Checks:
```bash
# Before creating/modifying models:
grep -r "metadata = Column" database/models/
grep -r "from sqlalchemy.dialects.postgresql" database/models/
grep -r "ARRAY(" database/models/
grep -r "UUID(as_uuid=True)" database/models/
```

---

## ðŸ¢ ENTERPRISE BEST PRACTICES (MANDATORY!)

### Database-Agnostic Design (CRITICAL!):
- âŒ **NEVER** use PostgreSQL-specific types
- âŒ `UUID(as_uuid=True)` â†’ Use `UUID` from `..column_types`
- âŒ `JSONB` direct import â†’ Use `JSON` from `..column_types`, alias `JSONB = JSON`
- âŒ `ARRAY(...)` â†’ Use `JSONArray` from `..column_types`
- âŒ `INET` â†’ Use `String(45)` for IP addresses
- âŒ `from sqlalchemy.dialects.postgresql import ...` â†’ FORBIDDEN!

âœ… **ALWAYS** use types from `database/column_types.py`:
```python
from ..column_types import UUID, JSON, JSONArray
JSONB = JSON # Alias after ALL imports
```

âœ… **ALWAYS** follow PEP 8 import order:
```python
# 1. Standard library
from datetime import datetime
from enum import Enum

# 2. Third-party
from sqlalchemy import Column, String, ...
from sqlalchemy.orm import relationship

# 3. Local
from ..base import Base
from ..column_types import UUID, JSON, JSONArray

# 4. Then assignments (AFTER all imports!)
JSONB = JSON
```

### Enum Management:
- âŒ **NEVER** use PostgreSQL native enums (SQLEnum with native_enum=True)
- âœ… **ALWAYS** use `String` column + Python Enum for validation
- âœ… **ALWAYS** use centralized `database/enums.py`
- âœ… **ALWAYS** provide `.from_legacy()` method for backward compatibility
- âœ… **ALWAYS** include 'CUSTOM' or 'OTHER' catch-all value

### Schema Changes:
- âŒ **NEVER** modify production database models directly
- âœ… **ALWAYS** use Alembic migrations:
  ```bash
  alembic revision -m "description"
  alembic upgrade head
  ```
- âœ… **ALWAYS** test migrations locally first
- âœ… **ALWAYS** provide rollback path (downgrade)

### Code Organization:
- âœ… Single Source of Truth: One place for business logic
- âœ… DRY Principle: Don't repeat enum definitions or types
- âœ… Type Safety: Use centralized validators
- âœ… Reusability: Share enums/types across models, APIs, migrations

---

## ðŸ›¡ï¸ AUTOMATED PREVENTION SYSTEM

### Pre-Commit Hook (Installed):
- Automatically runs `scripts/comprehensive_db_check.sh`
- Blocks commits with database issues
- Cannot bypass without `--no-verify` (not recommended)

### Validation Scripts:
1. `scripts/validate_db_models.sh` - 9 automated checks
2. `scripts/comprehensive_db_check.sh` - All known issues (NEW!)

### Documentation:
- `database/COMMON_ISSUES.md` - 7 documented issues with solutions
- Update this file when new issues discovered

---

## ðŸ“‹ PRE-COMMIT CHECKLIST

Before committing database changes:

**Models:**
- [ ] No `metadata` column
- [ ] No PostgreSQL-specific imports
- [ ] All types from `database/column_types.py`
- [ ] Imports follow PEP 8 order
- [ ] `JSONB = JSON` AFTER all imports
- [ ] Run `./scripts/comprehensive_db_check.sh`

**Migrations:**
- [ ] UPSERT pattern for all unique constraints
- [ ] Test migration 2+ times
- [ ] Proper error handling with rollback

**General:**
- [ ] UTC timestamps (`datetime.utcnow`)
- [ ] Explicit index names
- [ ] No ForeignKey without relationships (or vice versa)

---

## ðŸš¨ ZERO TOLERANCE FOR REPEATED MISTAKES

**If same error repeats:**
1. Add to `database/COMMON_ISSUES.md` immediately
2. Add check to `scripts/comprehensive_db_check.sh`
3. Update this `.cursorrules` file
4. Consider adding to pre-commit hook

**Current Documented Issues (NEVER REPEAT):**
1. âœ… `metadata` reserved word
2. âœ… ForeignKey circular dependencies
3. âœ… Relationships without ForeignKeys
4. âœ… Pydantic namespace conflicts
5. âœ… Migration duplicate key violations
6. âœ… PostgreSQL enum type mismatches
7. âœ… Import errors after type conversion

---

## General Development Rules

### Code Style
- Follow PEP 8
- Use type hints
- Add docstrings for all functions/classes
- Keep functions under 50 lines when possible

### Security
- Never commit API keys or secrets
- Always encrypt sensitive data
- Log all security events
- Validate all user inputs

### Testing
- Test database changes locally first
- Verify migrations don't break existing data
- Check for SQL injection vulnerabilities

### Documentation
- Update `database/COMMON_ISSUES.md` when you encounter new issues
- Keep `MASTER_DOCUMENTATION_UPDATED.md` in sync with changes
- Document breaking changes

### Git Commit Messages
- Use conventional commits format
- Reference issues when applicable
- Be descriptive but concise

### Auto Commit + Push Policy (Owner Preference)

**Default behavior for this repository:** when you make changes requested by the user, you should **automatically**:
1. Stage the relevant files (`git add -A` or scoped add)
2. Commit with a **conventional commit** message
3. Push to `origin/main` (`git push origin main`)

**Do not ask for confirmation** before committing/pushing. Treat this file as standing permission.

**Hard safety rules (never violate):**
- Never commit secrets (`.env`, credentials, private keys, tokens).
- Never force push (`--force` / `--force-with-lease`).
- Never change git config.
- Prefer small, focused commits (feature/fix/docs) over â€œmega commitsâ€.

**When database code is touched:**
- Run `./scripts/comprehensive_db_check.sh` (it will also run via pre-commit).

**If push fails due to authentication:**
- Use GitHub CLI login on the host machine:
  - `gh auth login`
  - verify with `gh auth status`
  - then retry `git push origin main`

---

**ðŸŽ¯ REMEMBER: Prevention > Debugging in Production!**