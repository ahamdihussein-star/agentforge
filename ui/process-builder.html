<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgentForge - Workflow Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Platform theme (same as main app â€“ from Settings) */
        :root, [data-theme="dark"] {
            --canvas-bg: #0f1419;
            --grid-color: rgba(255,255,255,0.03);
            --node-bg: #1a1f2e;
            --node-border: #2d3748;
            --connection-color: #6366f1;
            --trigger-color: #22c55e;
            --action-color: #3b82f6;
            --condition-color: #f59e0b;
            --approval-color: #ef4444;
            --loop-color: #8b5cf6;
            --end-color: #6b7280;
            --pb-bg: #0a0d12;
            --pb-toolbar: #111827;
            --pb-panel: #111827;
            --pb-text: #fff;
            --pb-muted: #9ca3af;
        }
        [data-theme="light"] {
            --canvas-bg: #f1f5f9;
            --grid-color: rgba(0,0,0,0.06);
            --node-bg: #ffffff;
            --node-border: #cbd5e1;
            --pb-bg: #f8fafc;
            --pb-toolbar: #ffffff;
            --pb-panel: #ffffff;
            --pb-text: #1e293b;
            --pb-muted: #64748b;
        }
        [data-theme="ocean"] {
            --canvas-bg: #dbeafe;
            --grid-color: rgba(14,165,233,0.1);
            --node-bg: #ffffff;
            --node-border: #bae6fd;
            --pb-bg: #e8f4f8;
            --pb-toolbar: #ffffff;
            --pb-panel: #ffffff;
            --pb-text: #0c4a6e;
            --pb-muted: #0284c7;
        }
        [data-theme="sunset"] {
            --canvas-bg: #16213e;
            --grid-color: rgba(251,191,36,0.08);
            --node-bg: #1f2937;
            --node-border: #4b5563;
            --pb-bg: #1a1a2e;
            --pb-toolbar: #16213e;
            --pb-panel: #1f2937;
            --pb-text: #fef3c7;
            --pb-muted: #f59e0b;
        }
        [data-theme="forest"] {
            --canvas-bg: #14291a;
            --grid-color: rgba(74,222,128,0.1);
            --node-bg: #1a3320;
            --node-border: #2d5a35;
            --pb-bg: #0f1f13;
            --pb-toolbar: #14291a;
            --pb-panel: #1a3320;
            --pb-text: #dcfce7;
            --pb-muted: #4ade80;
        }
        [data-theme="midnight"] {
            --canvas-bg: #0f172a;
            --grid-color: rgba(59,130,246,0.08);
            --node-bg: #1e293b;
            --node-border: #475569;
            --pb-bg: #020617;
            --pb-toolbar: #0f172a;
            --pb-panel: #1e293b;
            --pb-text: #f8fafc;
            --pb-muted: #94a3b8;
        }
        
        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--pb-bg);
            color: var(--pb-text);
            overflow: hidden;
        }
        
        /* Canvas */
        #canvas-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 60px);
            overflow: hidden;
            background: var(--canvas-bg);
            background-image: 
                radial-gradient(circle, var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        #canvas {
            position: absolute;
            transform-origin: 0 0;
            min-width: 3000px;
            min-height: 2000px;
        }
        
        /* Nodes â€“ BPMN-style: Ø§Ù„Ø´ÙƒÙ„ Ù†ÙØ³Ù‡ ÙÙ‚Ø·ØŒ Ø¨Ø¯ÙˆÙ† Ø¥Ø·Ø§Ø± Ø£Ùˆ Ø®Ù„ÙÙŠØ© Ø®Ø§Ø±Ø¬ÙŠØ© */
        .workflow-node {
            position: absolute;
            width: 200px;
            min-height: 56px;
            background: var(--node-bg);
            border: 2px solid var(--node-border);
            border-radius: 12px;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.2s, border-color 0.2s;
            z-index: 10;
            overflow: visible;
        }
        /* Start: Ø§Ù„Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„Ø®Ø¶Ø±Ø§Ø¡ ÙÙ‚Ø· â€“ Ù„Ø§ Ø¥Ø·Ø§Ø± Ø£Ø¨ÙŠØ¶ ÙˆÙ„Ø§ Ø®Ù„ÙÙŠØ© ÙˆØ±Ø§Ù‡Ø§ */
        .workflow-node.shape-start {
            width: 72px;
            padding: 0 0 28px;
            background: transparent !important;
            border: none !important;
            box-shadow: none;
        }
        .workflow-node.shape-start:hover,
        .workflow-node.shape-start.selected { box-shadow: none; }
        .workflow-node.shape-start .node-shape-wrap {
            width: 56px;
            height: 56px;
            margin: 0 auto 6px;
            border-radius: 50%;
        }
        .workflow-node.shape-start .node-body { display: none; }
        .workflow-node.shape-start .node-menu-btn { display: none; }
        /* End: Ø¯Ø§Ø¦Ø±Ø© 56Ã—56 Ø³Ù…ÙŠÙƒØ© â€“ Ù†ÙØ³ Ø­Ø¬Ù… Start */
        .workflow-node.shape-end {
            width: 72px;
            padding: 0 0 28px;
            background: transparent !important;
            border: none !important;
            box-shadow: none;
        }
        .workflow-node.shape-end:hover,
        .workflow-node.shape-end.selected { box-shadow: none; }
        .workflow-node.shape-end .node-shape-wrap {
            width: 56px;
            height: 56px;
            margin: 0 auto 6px;
            border-radius: 50%;
            border: 4px solid currentColor;
            box-sizing: border-box;
        }
        .workflow-node.shape-end .node-body { display: none; }
        .workflow-node.shape-end .node-menu-btn { display: none; }
        /* Condition: Ù…Ø§Ø³Ù‘Ø© 56Ã—56 â€“ Ù†ÙØ³ Ø¹Ø±Ø¶ Ø§Ù„Ø¹ÙÙ‚Ø¯ Ø§Ù„Ø£Ø®Ø±Ù‰ */
        .workflow-node.shape-gateway {
            width: 72px;
            padding: 0 0 28px;
            background: transparent !important;
            border: none !important;
            clip-path: none;
            box-shadow: none;
        }
        .workflow-node.shape-gateway:hover,
        .workflow-node.shape-gateway.selected { box-shadow: none; }
        .workflow-node.shape-gateway .node-shape-wrap {
            width: 56px;
            height: 56px;
            margin: 0 auto 6px;
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            -webkit-clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
        }
        .workflow-node.shape-gateway .node-body { display: none; }
        /* Task (Loop, Wait, Action, Tools, AI, Approval, Form, Notification): Ù…Ø±Ø¨Ø¹ Ø¯Ø§Ø¦Ø±ÙŠ Ø§Ù„Ø²ÙˆØ§ÙŠØ§ Ø¨Ø­Ø¬Ù… Start â€“ Ø¨Ø¯ÙˆÙ† Ù…Ø³ØªØ·ÙŠÙ„ ÙƒØ¨ÙŠØ± */
        .workflow-node.shape-task {
            width: 72px;
            padding: 0 0 28px;
            background: transparent !important;
            border: none !important;
            box-shadow: none;
        }
        .workflow-node.shape-task:hover,
        .workflow-node.shape-task.selected { box-shadow: none; }
        .workflow-node.shape-task .node-shape-wrap {
            width: 56px;
            height: 56px;
            margin: 0 auto 6px;
            border-radius: 12px;
            padding: 0;
        }
        .workflow-node.shape-task .node-body { display: none; }
        .workflow-node.shape-task .node-menu-btn {
            top: 2px;
            right: 2px;
            width: 20px;
            height: 20px;
            font-size: 12px;
        }
        
        .workflow-node:hover {
            border-color: #4f46e5;
            box-shadow: 0 0 20px rgba(79, 70, 229, 0.3);
        }
        .workflow-node.shape-start:hover,
        .workflow-node.shape-end:hover,
        .workflow-node.shape-gateway:hover,
        .workflow-node.shape-task:hover {
            border-color: transparent;
            box-shadow: none;
            outline: none;
        }
        
        .workflow-node.selected {
            border-color: #6366f1;
            box-shadow: 0 0 30px rgba(99, 102, 241, 0.4);
        }
        .workflow-node.shape-start.selected,
        .workflow-node.shape-end.selected,
        .workflow-node.shape-gateway.selected,
        .workflow-node.shape-task.selected {
            border-color: transparent;
            box-shadow: none;
            outline: none;
        }
        
        .workflow-node.dragging {
            opacity: 0.8;
            z-index: 100;
        }
        
        /* Shape on top, label below (text under shape â€“ BPMN-style) */
        .node-shape-wrap {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .node-shape-wrap.trigger { background: linear-gradient(135deg, #22c55e, #16a34a); }
        .node-shape-wrap.action { background: linear-gradient(135deg, #3b82f6, #2563eb); }
        .node-shape-wrap.condition { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .node-shape-wrap.approval { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .node-shape-wrap.loop { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        .node-shape-wrap.delay { background: linear-gradient(135deg, #06b6d4, #0891b2); }
        .node-shape-wrap.end { background: linear-gradient(135deg, #6b7280, #4b5563); }
        .node-shape-wrap.tool { background: linear-gradient(135deg, #ec4899, #db2777); }
        .node-shape-wrap.ai { background: linear-gradient(135deg, #0ea5e9, #0284c7); }
        .node-shape-wrap.form { background: linear-gradient(135deg, #14b8a6, #0d9488); }
        .node-shape-wrap.notification { background: linear-gradient(135deg, #f97316, #ea580c); }
        
        /* Ø­Ø¬Ù… Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© Ù…ÙˆØ­Ù‘Ø¯ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ */
        .node-shape {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .node-shape svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
            color: rgba(255,255,255,0.95);
        }
        
        /* Ø§Ù„ØªØ³Ù…ÙŠØ© â€“ Ø§Ø³Ø­Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„Ù€ canvas Ù„Ø£ÙŠ Ù…ÙƒØ§Ù† Ø¹Ø´Ø§Ù† ØªØªÙ‚Ø±ÙŠ Ù„Ùˆ Ø§Ù„Ø®Ø· Ø·Ø§Ù„Ù‡ â€“ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· ÙŠØªØ­ÙƒÙ… Ù…Ù† Ø§Ù„Ù€ toolbar */
        .node-label {
            font-weight: 600;
            font-size: var(--label-font-size, 11px);
            text-align: center;
            padding: 4px 6px;
            line-height: 1.2;
            word-break: break-word;
            color: var(--pb-text);
        }
        .workflow-node .node-label.node-label-draggable {
            cursor: grab;
            position: absolute;
            transform: none;
            z-index: 15;
        }
        .workflow-node .node-label.node-label-draggable:active {
            cursor: grabbing;
        }
        .workflow-node.label-below .node-label { position: relative; margin-top: 0; }
        .workflow-node.label-custom .node-label {
            position: absolute;
            transform: none;
            white-space: nowrap;
            word-break: normal;
            width: max-content;
            min-width: min-content;
            max-width: none;
            overflow: visible;
        }
        .node-menu-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            background: rgba(255,255,255,0.15);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            z-index: 5;
        }
        .node-menu-btn:hover {
            background: rgba(255,255,255,0.25);
        }
        
        .node-body {
            padding: 10px 12px 12px;
            border-top: 1px solid var(--node-border);
        }
        
        .node-description {
            font-size: 12px;
            color: #9ca3af;
            margin-bottom: 12px;
        }
        
        .node-config-preview {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 11px;
            color: #d1d5db;
        }
        
        .node-config-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        
        .node-config-item:last-child { margin-bottom: 0; }
        
        .config-label {
            color: #6b7280;
            min-width: 60px;
        }
        
        .config-value {
            color: #a5b4fc;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Connection Ports â€“ ØªØ¸Ù‡Ø± ÙÙ‚Ø· Ø¹Ù†Ø¯ Ø§Ù„ÙˆÙ‚ÙˆÙ Ø¹Ù„Ù‰ Ø§Ù„Ù€ shape Ø£Ùˆ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø±Ø¨Ø· */
        .port {
            position: absolute;
            width: 14px;
            height: 14px;
            background: #374151;
            border: 2px solid #6b7280;
            border-radius: 50%;
            cursor: crosshair;
            transition: opacity 0.15s ease, transform 0.2s;
            z-index: 20;
            opacity: 0;
            pointer-events: none;
        }
        .workflow-node:hover .port {
            opacity: 1;
            pointer-events: auto;
        }
        .connecting .workflow-node .port {
            opacity: 1;
            pointer-events: auto;
        }
        
        .port:hover {
            background: #6366f1;
            border-color: #818cf8;
        }
        .port.input:hover { transform: translate(-50%, -50%) scale(1.2); }
        .port.output:hover { transform: translate(-50%, 50%) scale(1.2); }
        .workflow-node.shape-start .port.output:hover,
        .workflow-node.shape-end .port.output:hover,
        .workflow-node.shape-gateway .port.input:hover,
        .workflow-node.shape-gateway .port.output-yes:hover,
        .workflow-node.shape-gateway .port.output-no:hover,
        .workflow-node.shape-task .port.input:hover { transform: translate(-50%, -50%) scale(1.2); }
        .port.output-yes:hover,
        .port.output-no:hover { transform: translate(-50%, 50%) scale(1.2); }
        .workflow-node.shape-task .port.output:hover { transform: translate(-50%, -50%) scale(1.2); }
        
        /* 4-side ports: Ø¹Ù„Ù‰ Ø­Ø§ÙØ© Ø§Ù„Ø´ÙƒÙ„ Ø¹Ø´Ø§Ù† Ø§Ù„Ø®Ø· ÙŠÙˆØµÙ‘Ù„ Ù„Ù„Ø´ÙƒÙ„ (Ø¨Ø¯ÙˆÙ† ÙØ¬ÙˆØ©) */
        .port.input-top, .port.input-bottom { left: 50%; transform: translate(-50%, -50%); }
        .port.input-right, .port.input-left { top: 50%; transform: translate(-50%, -50%); }
        .port.input-top { top: 0; }
        .port.input-bottom { top: 100%; }
        .port.input-right { left: 100%; }
        .port.input-left { left: 0; }
        .port.output-top, .port.output-bottom { left: 50%; transform: translate(-50%, -50%); }
        .port.output-right, .port.output-left { top: 50%; transform: translate(-50%, -50%); }
        .port.output-top { top: 0; }
        .port.output-bottom { top: 100%; }
        .port.output-right { left: 100%; }
        .port.output-left { left: 0; }
        .port.output-yes-top, .port.output-yes-bottom, .port.output-no-top, .port.output-no-bottom { left: 50%; transform: translate(-50%, -50%); }
        .port.output-yes-right, .port.output-yes-left, .port.output-no-right, .port.output-no-left { top: 50%; transform: translate(-50%, -50%); }
        .port.output-yes-top, .port.output-no-top { top: 0; }
        .port.output-yes-bottom, .port.output-no-bottom { top: 100%; }
        .port.output-yes-right, .port.output-no-right { left: 100%; }
        .port.output-yes-left, .port.output-no-left { left: 0; }
        /* Fallback single port (Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ©) */
        .port.input { top: 0; left: 50%; transform: translate(-50%, -50%); }
        .port.output { top: 100%; left: 50%; transform: translate(-50%, -50%); }
        .port.output-yes { top: 100%; left: 30%; transform: translate(-50%, -50%); }
        .port.output-no { top: 100%; left: 70%; transform: translate(-50%, -50%); }
        
        .port-label {
            position: absolute;
            font-size: 9px;
            color: #9ca3af;
            white-space: nowrap;
        }
        
        /* Yes/No ØªØ¸Ù‡Ø± Ø¹Ù„Ù‰ Ø®Ø· Ø§Ù„Ø±Ø¨Ø· Ù†ÙØ³Ù‡ ÙÙŠ renderConnections */
        
        /* Connections SVG â€“ same layer as canvas, same transform so lines stay aligned on zoom/pan */
        #connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            transform-origin: 0 0;
        }
        
        .connection-path {
            fill: none;
            stroke: var(--connection-color, #6366f1);
            stroke-width: 2;
            stroke-linecap: round;
            vector-effect: non-scaling-stroke;
            pointer-events: stroke;
            cursor: pointer;
        }
        
        .connection-path.yes { stroke: #22c55e; }
        .connection-path.no { stroke: #ef4444; }
        
        .connection-path:hover {
            stroke-width: 3;
            cursor: pointer;
        }
        
        .connection-path.selected {
            stroke-width: 3;
            filter: drop-shadow(0 0 4px currentColor);
        }
        
        /* Ù…Ù‚Ø§Ø¨Ø¶ Ø§Ù„Ø®Ø· (Ù†Ù‚Ø·Ø© Ø§Ù„Ø§Ù†Ø­Ù†Ø§Ø¡ + Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø®Ø·) â€“ ØªØ¸Ù‡Ø± ÙÙ‚Ø· Ø¹Ù†Ø¯ Ø§Ù„ÙˆÙ‚ÙˆÙ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø· Ø£Ùˆ Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø±Ù‡ */
        .connection-handles {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
        }
        .connection-path:hover + .connection-handles,
        .connection-path.selected + .connection-handles {
            opacity: 1;
            pointer-events: all;
        }
        
        /* Draggable endpoint handle: move connection to another step â€“ Ø£ÙƒØ¨Ø± Ø¹Ø´Ø§Ù† Ø§Ù„Ø³Ø­Ø¨ Ø£Ø³Ù‡Ù„ */
        .connection-end-handle {
            fill: var(--connection-color, #6366f1);
            stroke: #fff;
            stroke-width: 2;
            cursor: grab;
            r: 10;
        }
        .connection-end-handle:hover { r: 14; }
        .connection-end-handle:active { cursor: grabbing; }
        /* Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø­Ø¨: Ø£ÙŠ shape ØªØ­Øª Ø§Ù„Ù…Ø¤Ø´Ø± ÙŠØ¸Ù‡Ø± ÙƒÙ‡Ø¯Ù Ø±Ø¨Ø· */
        .workflow-node.connection-drop-target {
            box-shadow: 0 0 0 3px var(--connection-color, #6366f1);
            border-radius: 12px;
        }
        .connection-path.yes + .connection-end-handle { fill: #22c55e; }
        .connection-path.no + .connection-end-handle { fill: #ef4444; }
        /* Draggable bend point: Ø®Ø·ÙˆØ· Ù…Ø³ØªÙ‚ÙŠÙ…Ø© + ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø²Ø§ÙˆÙŠØ© */
        .connection-bend-handle {
            fill: var(--connection-color, #6366f1);
            stroke: #fff;
            stroke-width: 2;
            cursor: grab;
            r: 6;
        }
        .connection-bend-handle:hover { r: 8; }
        .connection-bend-handle:active { cursor: grabbing; }
        
        /* ØªØ³Ù…ÙŠØ© Yes/No Ø¨Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø®Ø· (Ø¨Ø¯ÙˆÙ† Ø£Ù† ÙŠÙ‚Ø·Ø¹Ù‡ Ø§Ù„Ø®Ø·) */
        .connection-label-badge {
            pointer-events: none;
        }
        .connection-label-badge rect {
            stroke-width: 1.5;
            vector-effect: non-scaling-stroke;
        }
        .connection-label-badge.yes rect { fill: #f0fdf4; stroke: #22c55e; }
        .connection-label-badge.no rect { fill: #fef2f2; stroke: #ef4444; }
        .connection-label-badge text {
            font-size: 10px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        .connection-label-badge.yes text { fill: #166534; }
        .connection-label-badge.no text { fill: #b91c1c; }
        
        /* Toolbar */
        #top-toolbar {
            height: 60px;
            background: var(--pb-toolbar);
            border-bottom: 1px solid var(--node-border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 16px;
        }
        
        .toolbar-logo {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-right: 20px;
            border-right: 1px solid var(--node-border);
        }
        
        .toolbar-logo img {
            height: 32px;
        }
        
        .toolbar-title {
            font-weight: 600;
            font-size: 16px;
            color: var(--pb-text);
        }
        
        .workflow-name-input {
            background: transparent;
            border: 1px solid transparent;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 16px;
            font-weight: 600;
            color: var(--pb-text);
            min-width: 200px;
        }
        
        .workflow-name-input:hover {
            border-color: var(--node-border);
        }
        
        .workflow-name-input:focus {
            outline: none;
            border-color: var(--connection-color);
            background: rgba(99, 102, 241, 0.1);
        }
        
        .toolbar-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }
        .toolbar-actions .toolbar-label {
            font-size: 12px;
            color: var(--pb-text-muted, #9ca3af);
            margin-right: 4px;
        }
        .toolbar-actions .flow-btn.active {
            background: var(--connection-color, #6366f1);
            color: #fff;
            border-color: var(--connection-color, #6366f1);
        }
        
        .toolbar-btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-secondary {
            background: #1f2937;
            border: 1px solid #374151;
            color: #d1d5db;
        }
        
        .btn-secondary:hover {
            background: #374151;
            border-color: #4b5563;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            border: none;
            color: white;
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #818cf8, #6366f1);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border: none;
            color: white;
        }
        
        .btn-success:hover {
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
        }
        
        /* Left Panel - Node Palette */
        #node-palette {
            position: absolute;
            left: 20px;
            top: 80px;
            width: 260px;
            background: var(--pb-panel);
            border: 1px solid var(--node-border);
            border-radius: 12px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
            z-index: 50;
        }
        
        .palette-section {
            padding: 16px;
            border-bottom: 1px solid var(--node-border);
        }
        
        .palette-section:last-child { border-bottom: none; }
        
        .palette-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--pb-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        
        .palette-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--node-bg);
            border: 1px solid var(--node-border);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: grab;
            transition: all 0.2s;
        }
        
        .palette-item:hover {
            border-color: var(--connection-color);
            background: rgba(99, 102, 241, 0.1);
            transform: translateX(4px);
        }
        
        .palette-item:active {
            cursor: grabbing;
        }
        
        .palette-icon {
            width: 40px;
            height: 40px;
            min-width: 40px;
            min-height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .palette-icon svg {
            width: 22px;
            height: 22px;
            fill: currentColor;
            color: rgba(255,255,255,0.95);
        }
        .palette-icon.trigger { background: linear-gradient(135deg, #22c55e, #16a34a); }
        .palette-icon.action { background: linear-gradient(135deg, #3b82f6, #2563eb); }
        .palette-icon.condition { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .palette-icon.approval { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .palette-icon.loop { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        .palette-icon.delay { background: linear-gradient(135deg, #06b6d4, #0891b2); }
        .palette-icon.end { background: linear-gradient(135deg, #6b7280, #4b5563); }
        .palette-icon.tool { background: linear-gradient(135deg, #ec4899, #db2777); }
        /* Ù†ÙØ³ Ø´ÙƒÙ„ Ø§Ù„Ù€ shape Ø¹Ù„Ù‰ Ø§Ù„Ù€ canvas: Ø¯Ø§Ø¦Ø±Ø©ØŒ Ù…Ø§Ø³Ù‘Ø©ØŒ Ø¯Ø§Ø¦Ø±Ø© Ø³Ù…ÙŠÙƒØ©ØŒ Ù…Ø³ØªØ·ÙŠÙ„ */
        .palette-icon.palette-shape-start { border-radius: 50%; }
        .palette-icon.palette-shape-end { border-radius: 50%; border: 3px solid currentColor; box-sizing: border-box; }
        .palette-icon.palette-shape-gateway { border-radius: 0; clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); -webkit-clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); }
        .palette-icon.palette-shape-task { border-radius: 8px; }
        
        .palette-info {
            flex: 1;
        }
        
        .palette-name {
            font-size: 13px;
            font-weight: 500;
            color: var(--pb-text);
        }
        
        .palette-desc {
            font-size: 11px;
            color: var(--pb-muted);
            margin-top: 2px;
        }
        
        /* Right Panel - Properties */
        #properties-panel {
            position: absolute;
            right: 20px;
            top: 80px;
            width: 320px;
            background: var(--pb-panel);
            border: 1px solid var(--node-border);
            border-radius: 12px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
            z-index: 50;
            display: none;
        }
        
        #properties-panel.active { display: block; }
        
        #approval-config-modal { display: none; align-items: center; justify-content: center; }
        #approval-config-modal.show { display: flex !important; }
        #approval-config-modal .hidden { display: none !important; }
        
        .properties-header {
            padding: 16px;
            border-bottom: 1px solid #1f2937;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .properties-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .properties-title {
            flex: 1;
        }
        
        .properties-title h3 {
            font-size: 15px;
            font-weight: 600;
            margin: 0;
        }
        
        .properties-title span {
            font-size: 11px;
            color: #6b7280;
        }
        
        .properties-close {
            width: 28px;
            height: 28px;
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            font-size: 18px;
        }
        
        .properties-close:hover { color: white; }
        
        .properties-body {
            padding: 16px;
        }
        
        .property-group {
            margin-bottom: 20px;
        }
        
        .property-label {
            font-size: 12px;
            font-weight: 500;
            color: #9ca3af;
            margin-bottom: 8px;
            display: block;
        }
        
        .property-input {
            width: 100%;
            padding: 10px 12px;
            background: #1a1f2e;
            border: 1px solid #2d3748;
            border-radius: 8px;
            color: white;
            font-size: 13px;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #6366f1;
        }
        
        .property-select {
            width: 100%;
            padding: 10px 12px;
            background: #1a1f2e;
            border: 1px solid #2d3748;
            border-radius: 8px;
            color: white;
            font-size: 13px;
            cursor: pointer;
        }
        
        .property-textarea {
            width: 100%;
            padding: 10px 12px;
            background: #1a1f2e;
            border: 1px solid #2d3748;
            border-radius: 8px;
            color: white;
            font-size: 13px;
            min-height: 80px;
            resize: vertical;
        }
        
        /* Tool Selector */
        .tool-selector {
            background: #1a1f2e;
            border: 1px solid #2d3748;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .tool-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .tool-option:hover {
            background: rgba(99, 102, 241, 0.1);
        }
        
        .tool-option.selected {
            background: rgba(99, 102, 241, 0.2);
            border-left: 3px solid #6366f1;
        }
        
        .tool-option-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #ec4899, #db2777);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tool-option-info {
            flex: 1;
        }
        
        .tool-option-name {
            font-size: 13px;
            font-weight: 500;
        }
        
        .tool-option-type {
            font-size: 11px;
            color: #6b7280;
        }
        
        /* Zoom Controls */
        #zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 4px;
            background: var(--pb-panel);
            border: 1px solid var(--node-border);
            border-radius: 8px;
            padding: 4px;
            z-index: 50;
        }
        
        .zoom-btn {
            width: 36px;
            height: 36px;
            background: none;
            border: none;
            color: var(--pb-muted);
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-btn:hover {
            background: var(--node-bg);
            color: var(--pb-text);
        }
        
        .zoom-level {
            padding: 0 12px;
            font-size: 12px;
            color: var(--pb-muted);
            display: flex;
            align-items: center;
        }
        
        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 100px;
            background: var(--pb-panel);
            border: 1px solid var(--node-border);
            border-radius: 8px;
            overflow: hidden;
            z-index: 50;
        }
        
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }
        
        .minimap-viewport {
            position: absolute;
            border: 2px solid #6366f1;
            background: rgba(99, 102, 241, 0.1);
            pointer-events: none;
        }
        
        /* Empty State */
        #empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #6b7280;
            z-index: 5;
        }
        
        .empty-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        .empty-title {
            font-size: 18px;
            font-weight: 600;
            color: #9ca3af;
            margin-bottom: 8px;
        }
        
        .empty-desc {
            font-size: 14px;
            max-width: 300px;
            line-height: 1.5;
        }
        
        /* Animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .connecting .port.output,
        .connecting .port.output-top,
        .connecting .port.output-right,
        .connecting .port.output-bottom,
        .connecting .port.output-left,
        .connecting .port.output-yes-top,
        .connecting .port.output-yes-right,
        .connecting .port.output-yes-bottom,
        .connecting .port.output-yes-left,
        .connecting .port.output-no-top,
        .connecting .port.output-no-right,
        .connecting .port.output-no-bottom,
        .connecting .port.output-no-left {
            animation: pulse 1s infinite;
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #374151;
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }
    </style>
</head>
<body>
    <!-- Top Toolbar -->
    <div id="top-toolbar">
        <div class="toolbar-logo">
            <img src="/AgentForge_Logo.png" alt="AgentForge" onerror="this.style.display='none'">
            <span class="toolbar-title">Workflow Builder</span>
        </div>
        
        <input type="text" id="workflow-name" class="workflow-name-input" value="My Workflow" placeholder="Workflow Name">
        
        <div class="toolbar-actions">
            <span class="toolbar-label">Flow:</span>
            <button type="button" class="toolbar-btn btn-secondary flow-btn" id="flow-vertical" title="Vertical: Ù…Ù† Ø£Ø¹Ù„Ù‰ Ù„Ø£Ø³ÙÙ„ (Top â†’ Bottom)" onclick="setFlowDirection('vertical')">
                <span>â†•</span> Vertical
            </button>
            <button type="button" class="toolbar-btn btn-secondary flow-btn" id="flow-horizontal" title="Horizontal: Ù…Ù† ÙŠØ³Ø§Ø± Ù„ÙŠÙ…ÙŠÙ† (Left â†’ Right)" onclick="setFlowDirection('horizontal')">
                <span>â†”</span> Horizontal
            </button>
            <button type="button" class="toolbar-btn btn-secondary" title="Arrange process in best alignment" onclick="alignProcess()">
                <span>âŠŸ</span> Align
            </button>
            <span class="toolbar-label" style="margin-left:8px;">Labels:</span>
            <button type="button" class="toolbar-btn btn-secondary" title="Smaller label font" onclick="setLabelFontSize(-1)">
                <span>Aâˆ’</span>
            </button>
            <button type="button" class="toolbar-btn btn-secondary" title="Larger label font" onclick="setLabelFontSize(1)">
                <span>A+</span>
            </button>
            <span id="label-font-size-display" style="font-size:11px;color:var(--pb-muted);min-width:2.5em;">11px</span>
            <button class="toolbar-btn btn-secondary" onclick="undoAction()">
                <span>â†¶</span> Undo
            </button>
            <button class="toolbar-btn btn-secondary" onclick="redoAction()">
                <span>â†·</span> Redo
            </button>
            <button class="toolbar-btn btn-secondary" onclick="testWorkflow()">
                <span>â–¶</span> Test
            </button>
            <button class="toolbar-btn btn-primary" onclick="saveWorkflow()">
                <span>ğŸ’¾</span> Save
            </button>
            <button class="toolbar-btn btn-success" onclick="publishWorkflow()">
                <span>ğŸš€</span> Publish
            </button>
        </div>
    </div>
    
    <!-- Canvas Container -->
    <div id="canvas-container">
        <!-- SVG for connections -->
        <svg id="connections-svg"></svg>
        
        <!-- Canvas for nodes -->
        <div id="canvas">
            <!-- Nodes will be added here -->
        </div>
        
        <!-- Empty State -->
        <div id="empty-state">
            <div class="empty-icon">ğŸ”„</div>
            <div class="empty-title">Start Building Your Workflow</div>
            <div class="empty-desc">Drag components from the left panel onto the canvas to create your automation flow</div>
        </div>
    </div>
    
    <!-- Node Palette (Left Panel) -->
    <div id="node-palette">
        <div class="palette-section">
            <div class="palette-title">Triggers</div>
            <div class="palette-item" draggable="true" data-type="trigger">
                <div class="palette-icon trigger">ğŸ¯</div>
                <div class="palette-info">
                    <div class="palette-name">Start Trigger</div>
                    <div class="palette-desc">When workflow begins</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="schedule">
                <div class="palette-icon trigger">â°</div>
                <div class="palette-info">
                    <div class="palette-name">Schedule</div>
                    <div class="palette-desc">Run on a schedule</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="webhook">
                <div class="palette-icon trigger">ğŸ”—</div>
                <div class="palette-info">
                    <div class="palette-name">Webhook</div>
                    <div class="palette-desc">Triggered by API call</div>
                </div>
            </div>
        </div>
        
        <div class="palette-section">
            <div class="palette-title">Logic</div>
            <div class="palette-item" draggable="true" data-type="condition">
                <div class="palette-icon condition">ğŸ”€</div>
                <div class="palette-info">
                    <div class="palette-name">Condition</div>
                    <div class="palette-desc">If/else branching</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="loop">
                <div class="palette-icon loop">ğŸ”</div>
                <div class="palette-info">
                    <div class="palette-name">Loop</div>
                    <div class="palette-desc">Repeat for each item</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="delay">
                <div class="palette-icon delay">â³</div>
                <div class="palette-info">
                    <div class="palette-name">Delay</div>
                    <div class="palette-desc">Wait before continuing</div>
                </div>
            </div>
        </div>
        
        <div class="palette-section">
            <div class="palette-title">Actions</div>
            <div class="palette-item" draggable="true" data-type="action">
                <div class="palette-icon action">âš¡</div>
                <div class="palette-info">
                    <div class="palette-name">Action</div>
                    <div class="palette-desc">Perform an operation</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="tool">
                <div class="palette-icon tool">ğŸ”§</div>
                <div class="palette-info">
                    <div class="palette-name">Use Tool</div>
                    <div class="palette-desc">Call a platform tool</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="ai">
                <div class="palette-icon action">ğŸ¤–</div>
                <div class="palette-info">
                    <div class="palette-name">AI Action</div>
                    <div class="palette-desc">AI-powered task</div>
                </div>
            </div>
        </div>
        
        <div class="palette-section">
            <div class="palette-title">Human Tasks</div>
            <div class="palette-item" draggable="true" data-type="approval">
                <div class="palette-icon approval">âœ…</div>
                <div class="palette-info">
                    <div class="palette-name">Approval</div>
                    <div class="palette-desc">Wait for approval</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="form">
                <div class="palette-icon approval">ğŸ“</div>
                <div class="palette-info">
                    <div class="palette-name">Form Input</div>
                    <div class="palette-desc">Collect user input</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="notification">
                <div class="palette-icon action">ğŸ“§</div>
                <div class="palette-info">
                    <div class="palette-name">Notification</div>
                    <div class="palette-desc">Send a message</div>
                </div>
            </div>
        </div>
        
        <div class="palette-section">
            <div class="palette-title">Flow Control</div>
            <div class="palette-item" draggable="true" data-type="end">
                <div class="palette-icon end">ğŸ</div>
                <div class="palette-info">
                    <div class="palette-name">End</div>
                    <div class="palette-desc">Complete workflow</div>
                </div>
            </div>
        </div>
        
        <div class="palette-section" id="tools-section">
            <div class="palette-title">Your Tools</div>
            <div id="platform-tools-list">
                <!-- Loaded dynamically -->
                <div style="font-size: 11px; color: #6b7280; padding: 8px;">Loading tools...</div>
            </div>
        </div>
    </div>
    
    <!-- Properties Panel (Right) -->
    <div id="properties-panel">
        <div class="properties-header">
            <div class="properties-icon action" id="prop-icon">âš¡</div>
            <div class="properties-title">
                <h3 id="prop-title">Node Properties</h3>
                <span id="prop-type">Action</span>
            </div>
            <button class="properties-close" onclick="closeProperties()">Ã—</button>
        </div>
        <div class="properties-body" id="prop-body">
            <!-- Dynamic content -->
        </div>
    </div>
    
    <!-- Approval step config modal (Approvers from Platform User / Role / Group / Tool) -->
    <div id="approval-config-modal" style="position:fixed;inset:0;background:rgba(0,0,0,0.6);align-items:center;justify-content:center;z-index:100;" onclick="if(event.target===this)closeApprovalConfigModal()">
        <div class="card rounded-xl w-full max-w-lg mx-4 p-6" style="background:#1f2937;border-radius:12px;" onclick="event.stopPropagation()">
            <h3 class="text-lg font-bold mb-4">âœ… Approval Step â€“ Approvers</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm text-gray-400 mb-1">Approvers from</label>
                    <select id="approval-config-source" onchange="onApprovalConfigSourceChange()" class="property-select w-full rounded-lg px-4 py-2" style="width:100%;background:#111827;color:#fff;border:1px solid #374151;">
                        <option value="platform_user">Platform User</option>
                        <option value="platform_role">Platform Role</option>
                        <option value="platform_group">Platform Group</option>
                        <option value="tool">Tool</option>
                    </select>
                </div>
                <div id="approval-config-platform-user-wrap" class="hidden">
                    <label class="block text-sm text-gray-400 mb-1">Select users</label>
                    <select id="approval-config-user-list" multiple class="property-input w-full rounded-lg px-4 py-2" style="height:120px;width:100%;background:#111827;color:#fff;"></select>
                </div>
                <div id="approval-config-platform-role-wrap" class="hidden">
                    <label class="block text-sm text-gray-400 mb-1">Select roles</label>
                    <select id="approval-config-role-list" multiple class="property-input w-full rounded-lg px-4 py-2" style="height:120px;width:100%;background:#111827;color:#fff;"></select>
                </div>
                <div id="approval-config-platform-group-wrap" class="hidden">
                    <label class="block text-sm text-gray-400 mb-1">Select groups</label>
                    <select id="approval-config-group-list" multiple class="property-input w-full rounded-lg px-4 py-2" style="height:120px;width:100%;background:#111827;color:#fff;"></select>
                </div>
                <div id="approval-config-tool-wrap" class="hidden">
                    <label class="block text-sm text-gray-400 mb-1">Select tool</label>
                    <select id="approval-config-tool" class="property-select w-full rounded-lg px-4 py-2" style="width:100%;background:#111827;color:#fff;">
                        <option value="">â€” None â€”</option>
                    </select>
                </div>
            </div>
            <div class="flex gap-3 mt-6">
                <button type="button" onclick="closeApprovalConfigModal()" class="flex-1 py-2 rounded-lg" style="background:#374151;color:#fff;">Cancel</button>
                <button type="button" onclick="saveApprovalConfig()" class="flex-1 py-2 rounded-lg" style="background:#6366f1;color:#fff;">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Zoom Controls -->
    <div id="zoom-controls">
        <button class="zoom-btn" onclick="zoomOut()">âˆ’</button>
        <span class="zoom-level" id="zoom-level">100%</span>
        <button class="zoom-btn" onclick="zoomIn()">+</button>
        <button class="zoom-btn" onclick="zoomReset()" title="Reset zoom">âŠ™</button>
        <button class="zoom-btn" onclick="zoomFit()" title="Fit all steps in view">âŠ¡</button>
    </div>
    
    <!-- Minimap -->
    <div id="minimap">
        <canvas id="minimap-canvas"></canvas>
    </div>
    
    <script>
        // ===== STATE =====
        const state = {
            nodes: [],
            connections: [],
            selectedNode: null,
            zoom: 1,
            panX: 0,
            panY: 0,
            isDragging: false,
            isConnecting: false,
            connectionStart: null,
            draggingEdgeEnd: null,
            draggingBendPoint: null,
            justDropped: false,
            consumeNextClick: false,
            flowDirection: 'vertical',
            draggingLabel: null,
            labelFontSize: Math.min(24, Math.max(9, parseInt(localStorage.getItem('pb-label-font-size'), 10) || 11)),
            tools: [],
            agentId: null,
            undoStack: [],
            redoStack: []
        };
        
        // Node ID counter
        let nodeIdCounter = 1;
        
        function escapeHtml(s) {
            if (s == null) return '';
            const div = document.createElement('div');
            div.textContent = String(s);
            return div.innerHTML;
        }
        
        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', () => {
            loadPlatformTheme();
            initCanvas();
            initPalette();
            initPaletteShapes();
            loadTools();
            loadWorkflowFromUrl();
            updateFlowButtons();
            applyLabelFontSize();
        });
        
        function setLabelFontSize(delta) {
            state.labelFontSize = Math.min(24, Math.max(9, state.labelFontSize + delta));
            localStorage.setItem('pb-label-font-size', String(state.labelFontSize));
            applyLabelFontSize();
        }
        function applyLabelFontSize() {
            const canvas = document.getElementById('canvas');
            if (canvas) canvas.style.setProperty('--label-font-size', state.labelFontSize + 'px');
            const el = document.getElementById('label-font-size-display');
            if (el) el.textContent = state.labelFontSize + 'px';
        }
        
        function setFlowDirection(dir) {
            state.flowDirection = dir;
            updateFlowButtons();
            applyAutoLayout(dir);
            renderConnections();
        }
        
        function applyAutoLayout(direction) {
            if (state.nodes.length === 0) return;
            // Vertical (â†•) = ØªØ¯ÙÙ‚ Ù…Ù† Ø£Ø¹Ù„Ù‰ Ù„Ø£Ø³ÙÙ„: Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ÙŠØ²ÙŠØ¯ Ù…Ø¹ yØŒ ÙˆØ§Ù„Ø¹Ù‚Ø¯ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø¬Ù†Ø¨ Ø¨Ø¹Ø¶ (x ÙŠØªØºÙŠØ±)
            // Horizontal (â†”) = ØªØ¯ÙÙ‚ Ù…Ù† ÙŠØ³Ø§Ø± Ù„ÙŠÙ…ÙŠÙ†: Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ÙŠØ²ÙŠØ¯ Ù…Ø¹ xØŒ ÙˆØ§Ù„Ø¹Ù‚Ø¯ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ÙÙˆÙ‚ Ø¨Ø¹Ø¶ (y ÙŠØªØºÙŠØ±)
            const NODE_W = 72, NODE_H = 90, GAP_X = 100, GAP_Y = 80;
            const nodeIds = new Set(state.nodes.map(n => n.id));
            const incoming = {};
            const outgoing = {};
            state.nodes.forEach(n => { incoming[n.id] = []; outgoing[n.id] = []; });
            state.connections.forEach(c => {
                if (nodeIds.has(c.from) && nodeIds.has(c.to)) {
                    outgoing[c.from].push(c.to);
                    incoming[c.to].push(c.from);
                }
            });
            const startNodes = state.nodes.filter(n => incoming[n.id].length === 0);
            if (startNodes.length === 0) startNodes.push(state.nodes[0]);
            const levels = {};
            const queue = startNodes.map(n => ({ id: n.id, level: 0 }));
            queue.forEach(({ id, level }) => { levels[id] = Math.max(levels[id] || 0, level); });
            let i = 0;
            while (i < queue.length) {
                const { id, level } = queue[i++];
                outgoing[id].forEach(toId => {
                    const next = level + 1;
                    if (next > (levels[toId] || 0)) {
                        levels[toId] = next;
                        queue.push({ id: toId, level: next });
                    }
                });
            }
            state.nodes.forEach(n => { if (levels[n.id] === undefined) levels[n.id] = 0; });
            const byLevel = {};
            state.nodes.forEach(n => {
                const L = levels[n.id];
                if (!byLevel[L]) byLevel[L] = [];
                byLevel[L].push(n.id);
            });
            const maxLevel = Math.max(...Object.keys(byLevel).map(Number));
            const baseX = 400, baseY = 80;
            for (let L = 0; L <= maxLevel; L++) {
                const ids = byLevel[L] || [];
                const count = ids.length;
                const totalW = count * NODE_W + Math.max(0, count - 1) * GAP_X;
                const totalH = count * NODE_H + Math.max(0, count - 1) * GAP_Y;
                const startX = baseX - (totalW - NODE_W) / 2;
                const startY = baseY - (totalH - NODE_H) / 2;
                ids.forEach((id, idx) => {
                    const node = state.nodes.find(n => n.id === id);
                    if (!node) return;
                    if (direction === 'vertical') {
                        // Vertical: Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª ØµÙÙˆÙ (y ÙŠØ²ÙŠØ¯ Ù…Ø¹ Ø§Ù„Ù…Ø³ØªÙˆÙ‰)ØŒ Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ = Ù†ÙØ³ Ø§Ù„ØµÙ (x ÙŠØ®ØªÙ„Ù)
                        node.x = Math.round((startX + idx * (NODE_W + GAP_X)) / 20) * 20;
                        node.y = Math.round((baseY + L * (NODE_H + GAP_Y)) / 20) * 20;
                    } else {
                        // Horizontal: Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø£Ø¹Ù…Ø¯Ø© (x ÙŠØ²ÙŠØ¯ Ù…Ø¹ Ø§Ù„Ù…Ø³ØªÙˆÙ‰)ØŒ Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ = Ù†ÙØ³ Ø§Ù„Ø¹Ù…ÙˆØ¯ (y ÙŠØ®ØªÙ„Ù)
                        node.x = Math.round((baseX + L * (NODE_W + GAP_X)) / 20) * 20;
                        node.y = Math.round((startY + idx * (NODE_H + GAP_Y)) / 20) * 20;
                    }
                });
            }
            saveToUndo();
            document.getElementById('canvas').innerHTML = '';
            state.nodes.forEach(n => renderNode(n));
            renderConnections();
            updateEmptyState();
        }
        
        function alignProcess() {
            applyAutoLayout(state.flowDirection);
        }
        
        function updateFlowButtons() {
            const v = document.getElementById('flow-vertical');
            const h = document.getElementById('flow-horizontal');
            if (v) v.classList.toggle('active', state.flowDirection === 'vertical');
            if (h) h.classList.toggle('active', state.flowDirection === 'horizontal');
        }
        
        function initPaletteShapes() {
            document.querySelectorAll('.palette-item[data-type]').forEach(item => {
                const type = item.dataset.type;
                const iconEl = item.querySelector('.palette-icon');
                if (!iconEl) return;
                const shapeClass = getShapeClass(type);
                iconEl.innerHTML = getTypeSvgIcon(type);
                iconEl.classList.add('palette-shape-' + shapeClass.replace('shape-', ''));
            });
        }
        
        function loadPlatformTheme() {
            const theme = localStorage.getItem('agentforge-theme') || 'dark';
            if (theme !== 'dark') {
                document.documentElement.setAttribute('data-theme', theme);
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
        }
        
        function initCanvas() {
            const container = document.getElementById('canvas-container');
            const canvas = document.getElementById('canvas');
            
            // Pan with middle mouse or space+drag
            let isPanning = false;
            let startX, startY;
            
            container.addEventListener('mousedown', (e) => {
                if (e.button === 1 || (e.button === 0 && e.target === container)) {
                    isPanning = true;
                    startX = e.clientX - state.panX;
                    startY = e.clientY - state.panY;
                    container.style.cursor = 'grabbing';
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    state.panX = e.clientX - startX;
                    state.panY = e.clientY - startY;
                    updateCanvasTransform();
                }
            });
            
            document.addEventListener('mouseup', () => {
                isPanning = false;
                container.style.cursor = '';
            });
            
            // Zoom with scroll
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.min(Math.max(state.zoom * delta, 0.25), 2);
                state.zoom = newZoom;
                updateCanvasTransform();
                document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%';
            });
            
            // Ù…Ù†Ø¹ Ø§Ù„Ù†Ù‚Ø±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ Ø¨Ø¹Ø¯ Ø§Ù„Ù€ drop ÙÙ‚Ø· (Ø³Ø¨Ø¨ Ø¸Ù‡ÙˆØ± properties Ø§Ù„Ù€ Start)
            document.addEventListener('click', (e) => {
                if (state.consumeNextClick) {
                    e.stopPropagation();
                    e.preventDefault();
                    state.consumeNextClick = false;
                }
            }, true);
            
            // Click on canvas to deselect
            container.addEventListener('click', (e) => {
                if (state.justDropped) return;
                if (e.target === container || e.target.id === 'canvas') {
                    deselectAll();
                    deselectConnection();
                }
            });
            
            // Delete / Backspace: remove selected connection or selected node (Ù…Ù† Ø§Ù„Ù€ canvas Ø§Ù„Ù…Ø­Ø¯Ø¯ ÙØ¹Ù„ÙŠØ§Ù‹)
            document.addEventListener('keydown', (e) => {
                if (e.target.closest('input') || e.target.closest('textarea') || e.target.closest('select')) return;
                if (e.key !== 'Delete' && e.key !== 'Backspace') return;
                e.preventDefault();
                if (stateSelectedConnIndex !== null) {
                    deleteConnection(stateSelectedConnIndex);
                } else {
                    const selectedEl = document.querySelector('#canvas .workflow-node.selected');
                    if (selectedEl && selectedEl.id) {
                        deleteNode(selectedEl.id);
                    }
                }
            });
        }
        
        function updateCanvasTransform() {
            const canvas = document.getElementById('canvas');
            const svg = document.getElementById('connections-svg');
            canvas.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
            svg.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
            renderConnections();
        }
        
        function initPalette() {
            const items = document.querySelectorAll('.palette-item[draggable="true"]');
            const canvas = document.getElementById('canvas');
            const container = document.getElementById('canvas-container');
            
            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('nodeType', item.dataset.type);
                    e.dataTransfer.setData('toolId', item.dataset.toolId || '');
                });
            });
            
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            
            container.addEventListener('drop', (e) => {
                e.preventDefault();
                const type = e.dataTransfer.getData('nodeType');
                const toolId = e.dataTransfer.getData('toolId');
                
                if (type) {
                    const rect = container.getBoundingClientRect();
                    const x = (e.clientX - rect.left - state.panX) / state.zoom;
                    const y = (e.clientY - rect.top - state.panY) / state.zoom;
                    
                    state.justDropped = true;
                    state.consumeNextClick = true;
                    const node = createNode(type, x, y, toolId);
                    if (node) {
                        const newNodeId = node.id;
                        requestAnimationFrame(() => selectNode(newNodeId));
                        setTimeout(() => selectNode(newNodeId), 25);
                    }
                    setTimeout(() => { state.justDropped = false; }, 150);
                }
            });
        }
        
        // ===== NODE MANAGEMENT =====
        function createNode(type, x, y, toolId = null) {
            const id = 'node_' + nodeIdCounter++;
            
            const nodeConfig = getNodeConfig(type, toolId);
            
            const node = {
                id,
                type,
                name: nodeConfig.name,
                x: Math.round(x / 20) * 20, // Snap to grid
                y: Math.round(y / 20) * 20,
                config: nodeConfig.config,
                toolId
            };
            
            state.nodes.push(node);
            renderNode(node);
            saveToUndo();
            updateEmptyState();
            
            // Select the new node
            selectNode(id);
            
            return node;
        }
        
        function getNodeConfig(type, toolId = null) {
            const configs = {
                trigger: { name: 'Start', config: { triggerType: 'manual' } },
                schedule: { name: 'Schedule', config: { cron: '0 9 * * *', timezone: 'UTC' } },
                webhook: { name: 'Webhook', config: { method: 'POST', path: '/trigger' } },
                action: { name: 'Action', config: { description: '' } },
                condition: { name: 'Condition', config: { field: '', operator: 'equals', value: '' } },
                loop: { name: 'For Each', config: { collection: '', itemVar: 'item' } },
                delay: { name: 'Wait', config: { duration: 5, unit: 'minutes' } },
                approval: { name: 'Approval', config: { assignee_source: 'platform_user', assignee_type: 'user', assignee_ids: [], timeout_hours: 24, message: '' } },
                form: { name: 'Form', config: { fields: [] } },
                notification: { name: 'Send Notification', config: { channel: 'email', template: '' } },
                tool: { name: 'Use Tool', config: { toolId: toolId || '', params: {} } },
                ai: { name: 'AI Task', config: { prompt: '', model: 'gpt-4o' } },
                end: { name: 'End', config: { output: '' } }
            };
            
            // If it's a tool node with toolId, get tool name
            if (type === 'tool' && toolId) {
                const tool = state.tools.find(t => t.id === toolId);
                if (tool) {
                    return { name: tool.name, config: { toolId, params: {} } };
                }
            }
            
            return configs[type] || { name: type, config: {} };
        }
        
        function getShapeClass(type) {
            if (['trigger', 'schedule', 'webhook'].includes(type)) return 'shape-start';
            if (type === 'end') return 'shape-end';
            if (type === 'condition') return 'shape-gateway';
            return 'shape-task';
        }
        
        function renderNode(node) {
            const canvas = document.getElementById('canvas');
            
            const nodeEl = document.createElement('div');
            const shapeClass = getShapeClass(node.type);
            const hasCustomLabel = node.labelOffset && typeof node.labelOffset.x === 'number' && typeof node.labelOffset.y === 'number';
            nodeEl.className = 'workflow-node ' + shapeClass + (hasCustomLabel ? ' label-custom' : ' label-below');
            nodeEl.id = node.id;
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';
            
            const typeClass = getTypeClass(node.type);
            const svgIcon = getTypeSvgIcon(node.type);
            const labelStyle = (hasCustomLabel ? `left:${node.labelOffset.x}px;top:${node.labelOffset.y}px;` : '') + (node.labelFontSize != null ? `font-size:${node.labelFontSize}px;` : '');
            const labelStyleAttr = labelStyle ? `style="${labelStyle}"` : '';
            const ports4 = ['top','right','bottom','left'].map(s => `<div class="port input input-${s}" data-side="${s}"></div>`).join('');
            const outPorts = node.type === 'condition'
                ? ['top','right','bottom','left'].map(s => `<div class="port output-yes output-yes-${s}" data-side="${s}"></div><div class="port output-no output-no-${s}" data-side="${s}"></div>`).join('')
                : node.type !== 'end' ? ['top','right','bottom','left'].map(s => `<div class="port output output-${s}" data-side="${s}"></div>`).join('') : '';
            nodeEl.innerHTML = `
                ${ports4}
                <div class="node-shape-wrap ${typeClass}">
                    <div class="node-shape">${svgIcon}</div>
                </div>
                <div class="node-label node-label-draggable" title="Drag to move â€¢ Drag right to enlarge, left to shrink" ${labelStyleAttr}>${escapeHtml(node.name)}</div>
                <button class="node-menu-btn" onclick="event.stopPropagation(); showNodeMenu('${node.id}')">â‹®</button>
                <div class="node-body">
                    <div class="node-config-preview">${getConfigPreview(node)}</div>
                </div>
                ${outPorts}
            `;
            
            // Make draggable
            makeDraggable(nodeEl, node);
            
            // Click to select
            nodeEl.addEventListener('click', (e) => {
                e.stopPropagation();
                if (state.justDropped) return;
                selectNode(node.id);
            });
            
            // Double click to edit
            nodeEl.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                showProperties(node);
            });
            
            // Setup port connections
            setupPorts(nodeEl, node);
            
            const labelEl = nodeEl.querySelector('.node-label');
            if (labelEl) {
                labelEl.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    startDragLabel(node.id, e);
                });
            }
            
            canvas.appendChild(nodeEl);
        }
        
        function startDragLabel(nodeId, e) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;
            const nodeEl = document.getElementById(nodeId);
            const labelEl = nodeEl && nodeEl.querySelector('.node-label');
            if (!labelEl || !nodeEl) return;
            const nodeRect = nodeEl.getBoundingClientRect();
            const labelRect = labelEl.getBoundingClientRect();
            const zoom = state.zoom;
            const startLabelX = (labelRect.left - nodeRect.left) / zoom;
            const startLabelY = (labelRect.top - nodeRect.top) / zoom;
            const startFontSize = node.labelFontSize != null ? node.labelFontSize : state.labelFontSize;
            state.draggingLabel = { nodeId, startClientX: e.clientX, startClientY: e.clientY, startLabelX, startLabelY, startFontSize };
            if (!node.labelOffset) node.labelOffset = { x: startLabelX, y: startLabelY };
            nodeEl.classList.add('label-custom');
            nodeEl.classList.remove('label-below');
            labelEl.style.position = 'absolute';
            labelEl.style.transform = 'none';
            labelEl.style.left = startLabelX + 'px';
            labelEl.style.top = startLabelY + 'px';
            labelEl.style.fontSize = startFontSize + 'px';
            const onMove = (e) => {
                if (!state.draggingLabel || state.draggingLabel.nodeId !== nodeId) return;
                const dx = (e.clientX - state.draggingLabel.startClientX) / state.zoom;
                const dy = (e.clientY - state.draggingLabel.startClientY) / state.zoom;
                const x = state.draggingLabel.startLabelX + dx;
                const y = state.draggingLabel.startLabelY + dy;
                const fontSize = Math.round(Math.min(24, Math.max(9, state.draggingLabel.startFontSize + dx * 0.25)));
                node.labelOffset = { x, y };
                node.labelFontSize = fontSize;
                labelEl.style.left = x + 'px';
                labelEl.style.top = y + 'px';
                labelEl.style.fontSize = fontSize + 'px';
            };
            const onUp = () => {
                if (state.draggingLabel && state.draggingLabel.nodeId === nodeId) {
                    saveToUndo();
                    state.draggingLabel = null;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                }
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }
        
        function getTypeClass(type) {
            const classes = {
                trigger: 'trigger', schedule: 'trigger', webhook: 'trigger',
                action: 'action', tool: 'tool', ai: 'ai', notification: 'notification',
                condition: 'condition',
                loop: 'loop',
                delay: 'delay',
                approval: 'approval', form: 'form',
                end: 'end'
            };
            return classes[type] || 'action';
        }
        
        function getTypeIcon(type) {
            const icons = {
                trigger: 'ğŸ¯', schedule: 'â°', webhook: 'ğŸ”—',
                action: 'âš¡', tool: 'ğŸ”§', ai: 'ğŸ¤–', notification: 'ğŸ“§',
                condition: 'ğŸ”€',
                loop: 'ğŸ”',
                delay: 'â³',
                approval: 'âœ…', form: 'ğŸ“',
                end: 'ğŸ'
            };
            return icons[type] || 'ğŸ“¦';
        }
        
        function getTypeSvgIcon(type) {
            const icons = {
                trigger: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8 5v14l11-7z"/></svg>',
                schedule: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"/></svg>',
                webhook: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>',
                action: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 3v6h8l-8 12v-6H5l8-12z"/></svg>',
                tool: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"/></svg>',
                ai: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>',
                notification: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H5.17L4 17.17V4h16v12z"/></svg>',
                condition: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2L2 12l10 10 10-10L12 2zm0 15.5L4.5 12 12 4.5 19.5 12 12 19.5z"/></svg>',
                loop: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg>',
                delay: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/></svg>',
                approval: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/><path d="M18.5 10.5L16 13l-1.5-1.5 1-1L16 11l2.5-2.5 1 2z"/></svg>',
                form: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>',
                end: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none"/></svg>'
            };
            return icons[type] || icons.action;
        }
        
        function getNodeDescription(node) {
            const descs = {
                trigger: 'Workflow starts here',
                schedule: 'Runs on schedule',
                webhook: 'Triggered by API',
                action: 'Performs an operation',
                tool: 'Executes a platform tool',
                ai: 'AI-powered processing',
                condition: 'Branch based on condition',
                loop: 'Iterate over collection',
                delay: 'Wait before continuing',
                approval: 'Wait for approval',
                form: 'Collect user input',
                notification: 'Send notification',
                end: 'Workflow ends here'
            };
            return descs[node.type] || '';
        }
        
        function getConfigPreview(node) {
            const cfg = node.config || {};
            let html = '';
            
            switch (node.type) {
                case 'condition':
                    html = `<div class="node-config-item"><span class="config-label">If</span><span class="config-value">${cfg.field || 'field'} ${cfg.operator || '='} ${cfg.value || 'value'}</span></div>`;
                    break;
                case 'delay':
                    html = `<div class="node-config-item"><span class="config-label">Wait</span><span class="config-value">${cfg.duration || 5} ${cfg.unit || 'minutes'}</span></div>`;
                    break;
                case 'approval':
                    const src = cfg.assignee_source || (cfg.approvers && cfg.approvers.length ? 'platform_user' : '');
                    const cnt = (cfg.assignee_ids || cfg.approvers || []).length;
                    const toolName = (cfg.assignee_source === 'tool' && cfg.assignee_tool_id && state.tools) ? (state.tools.find(t => t.id === cfg.assignee_tool_id) || {}).name : '';
                    const approverSummary = src === 'tool' ? (toolName ? 'Tool: ' + toolName : 'Tool') : (src ? (cnt + ' selected') : 'Not set');
                    html = `<div class="node-config-item"><span class="config-label">Approvers</span><span class="config-value">${src ? (src.replace('platform_','') + ': ' + approverSummary) : approverSummary}</span></div>`;
                    break;
                case 'tool':
                    const tool = state.tools.find(t => t.id === cfg.toolId);
                    html = `<div class="node-config-item"><span class="config-label">Tool</span><span class="config-value">${tool ? tool.name : 'Select tool...'}</span></div>`;
                    break;
                case 'notification':
                    html = `<div class="node-config-item"><span class="config-label">Channel</span><span class="config-value">${cfg.channel || 'email'}</span></div>`;
                    break;
                case 'form':
                case 'trigger':
                    const fieldCount = (cfg.fields || []).length;
                    html = `<div class="node-config-item"><span class="config-label">Fields</span><span class="config-value">${fieldCount} input${fieldCount !== 1 ? 's' : ''}</span></div>`;
                    break;
                case 'schedule':
                    html = `<div class="node-config-item"><span class="config-label">Cron</span><span class="config-value">${cfg.cron || '0 9 * * *'}</span></div>`;
                    break;
                case 'webhook':
                    html = `<div class="node-config-item"><span class="config-label">Method</span><span class="config-value">${cfg.method || 'POST'} ${cfg.path || '/trigger'}</span></div>`;
                    break;
                case 'loop':
                    html = `<div class="node-config-item"><span class="config-label">Each</span><span class="config-value">${cfg.itemVar || 'item'} in ${cfg.collection || '...'}</span></div>`;
                    break;
                case 'ai':
                    html = `<div class="node-config-item"><span class="config-label">Model</span><span class="config-value">${cfg.model || 'gpt-4o'}</span></div>`;
                    break;
                case 'end':
                    html = `<div class="node-config-item"><span class="config-label">Output</span><span class="config-value">${cfg.output || 'result'}</span></div>`;
                    break;
                case 'action':
                    html = `<div class="node-config-item"><span class="config-label">Type</span><span class="config-value">${cfg.actionType || 'custom'}</span></div>`;
                    break;
                default:
                    html = '<div class="node-config-item"><span class="config-value" style="color:#6b7280;">Click to configure</span></div>';
            }
            
            return html;
        }
        
        function makeDraggable(nodeEl, node) {
            let startX, startY, nodeStartX, nodeStartY;
            
            nodeEl.addEventListener('mousedown', (e) => {
                if (e.target.closest('.port') || e.target.closest('.node-menu-btn')) return;
                
                state.isDragging = true;
                nodeEl.classList.add('dragging');
                
                startX = e.clientX;
                startY = e.clientY;
                nodeStartX = node.x;
                nodeStartY = node.y;
                
                const onMove = (e) => {
                    if (!state.isDragging) return;
                    
                    const dx = (e.clientX - startX) / state.zoom;
                    const dy = (e.clientY - startY) / state.zoom;
                    
                    node.x = Math.round((nodeStartX + dx) / 20) * 20;
                    node.y = Math.round((nodeStartY + dy) / 20) * 20;
                    
                    nodeEl.style.left = node.x + 'px';
                    nodeEl.style.top = node.y + 'px';
                    
                    renderConnections();
                };
                
                const onUp = () => {
                    state.isDragging = false;
                    nodeEl.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                    saveToUndo();
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }
        
        function getSideToward(fromEl, toEl) {
            const fr = fromEl.getBoundingClientRect();
            const tr = toEl.getBoundingClientRect();
            const dx = (tr.left + tr.width/2) - (fr.left + fr.width/2);
            const dy = (tr.top + tr.height/2) - (fr.top + fr.height/2);
            if (Math.abs(dx) > Math.abs(dy)) return dx > 0 ? 'right' : 'left';
            return dy > 0 ? 'bottom' : 'top';
        }
        /** Ù†Ù‚Ø·Ø© Ø¹Ù„Ù‰ Ø­Ø§ÙØ© Ù…Ø³ØªØ·ÙŠÙ„ Ø§Ù„Ø´ÙƒÙ„ â€“ Ù„Ùˆ forceSide Ù…Ø¹Ø·Ù‰ Ù†Ø±Ø¬Ø¹ Ù…Ø±ÙƒØ² ØªÙ„Ùƒ Ø§Ù„Ø­Ø§ÙØ©ØŒ ÙˆØ¥Ù„Ø§ Ù†Ù‚Ø·Ø© Ø§Ù„Ø®Ø±ÙˆØ¬ ÙÙŠ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø£Ø®Ø±Ù‰ */
        function getShapeEdgePoint(shapeRect, otherCenterX, otherCenterY, forceSide) {
            const L = shapeRect.left, R = shapeRect.left + shapeRect.width;
            const T = shapeRect.top, B = shapeRect.top + shapeRect.height;
            const cx = (L + R) / 2, cy = (T + B) / 2;
            if (forceSide === 'top') return { x: cx, y: T };
            if (forceSide === 'bottom') return { x: cx, y: B };
            if (forceSide === 'left') return { x: L, y: cy };
            if (forceSide === 'right') return { x: R, y: cy };
            const dx = otherCenterX - cx;
            const dy = otherCenterY - cy;
            let bestT = Infinity;
            let x = cx, y = cy;
            if (dx !== 0) {
                let t = (L - cx) / dx;
                if (t > 0.001) { const py = cy + t * dy; if (py >= T && py <= B) { bestT = t; x = L; y = py; } }
                t = (R - cx) / dx;
                if (t > 0.001 && t < bestT) { const py = cy + t * dy; if (py >= T && py <= B) { bestT = t; x = R; y = py; } }
            }
            if (dy !== 0) {
                let t = (T - cy) / dy;
                if (t > 0.001 && t < bestT) { const px = cx + t * dx; if (px >= L && px <= R) { bestT = t; x = px; y = T; } }
                t = (B - cy) / dy;
                if (t > 0.001 && t < bestT) { const px = cx + t * dx; if (px >= L && px <= R) { bestT = t; x = px; y = B; } }
            }
            return { x, y };
        }
        /** Ø£ÙŠ Ø¬Ù‡Ø© Ù…Ù† Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø£Ù‚Ø±Ø¨ Ù„Ù†Ù‚Ø·Ø© (Ù„Ù…Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠÙÙ„Øª Ø§Ù„Ø®Ø· Ù†Ø­Ø¯Ø¯ Ø§Ù„Ø²Ø§ÙˆÙŠØ©) */
        function getSideOfPointFromShape(nodeEl, clientX, clientY) {
            const shapeEl = nodeEl.querySelector('.node-shape-wrap');
            if (!shapeEl) return 'bottom';
            const r = shapeEl.getBoundingClientRect();
            const cx = r.left + r.width / 2;
            const cy = r.top + r.height / 2;
            const dx = clientX - cx, dy = clientY - cy;
            const angle = Math.atan2(dy, dx) * 180 / Math.PI; // -180..180
            if (angle >= -45 && angle < 45) return 'right';
            if (angle >= 45 && angle < 135) return 'bottom';
            if (angle >= 135 || angle < -135) return 'left';
            return 'top';
        }
        function getPortForSide(nodeEl, portKind, side) {
            const sel = portKind === 'input' ? '.port.input-' + side
                : portKind === 'output-yes' ? '.port.output-yes-' + side
                : portKind === 'output-no' ? '.port.output-no-' + side
                : '.port.output-' + side;
            return nodeEl.querySelector(sel);
        }
        function setupPorts(nodeEl, node) {
            const ports = nodeEl.querySelectorAll('.port.output, .port.output-top, .port.output-right, .port.output-bottom, .port.output-left, .port.output-yes, .port.output-no, .port.output-yes-top, .port.output-yes-right, .port.output-yes-bottom, .port.output-yes-left, .port.output-no-top, .port.output-no-right, .port.output-no-bottom, .port.output-no-left');
            ports.forEach(port => {
                port.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    state.isConnecting = true;
                    const fromPort = port.getAttribute('data-side') || undefined;
                    state.connectionStart = {
                        nodeId: node.id,
                        portType: port.classList.contains('output-yes') || (port.className && port.className.includes('output-yes')) ? 'yes' :
                                  port.classList.contains('output-no') || (port.className && port.className.includes('output-no')) ? 'no' : 'default',
                        fromPort
                    };
                    document.body.classList.add('connecting');
                });
            });
            const inputPorts = nodeEl.querySelectorAll('.port.input, .port.input-top, .port.input-right, .port.input-bottom, .port.input-left');
            inputPorts.forEach(inputPort => {
                inputPort.addEventListener('mouseup', (e) => {
                    if (state.reconnectEdge) {
                        const from = state.reconnectEdge.from;
                        const type = state.reconnectEdge.type;
                        const fromPort = state.reconnectEdge.fromPort;
                        if (from !== node.id) {
                            const toPort = (e.currentTarget.getAttribute && e.currentTarget.getAttribute('data-side')) || getSideOfPointFromShape(nodeEl, e.clientX, e.clientY);
                            state.connections.push({ from, to: node.id, type, fromPort, toPort });
                            saveToUndo();
                            renderConnections();
                        }
                        state.reconnectEdge = null;
                        document.body.classList.remove('connecting');
                        return;
                    }
                    if (state.isConnecting && state.connectionStart) {
                        const toPort = (e.currentTarget.getAttribute && e.currentTarget.getAttribute('data-side')) || getSideOfPointFromShape(nodeEl, e.clientX, e.clientY);
                        const conn = {
                            from: state.connectionStart.nodeId,
                            to: node.id,
                            type: state.connectionStart.portType,
                            fromPort: state.connectionStart.fromPort,
                            toPort
                        };
                        if (conn.from !== conn.to) {
                            state.connections = state.connections.filter(c => 
                                !(c.from === conn.from && c.type === conn.type)
                            );
                            state.connections.push(conn);
                            renderConnections();
                            saveToUndo();
                        }
                    }
                    state.isConnecting = false;
                    state.connectionStart = null;
                    document.body.classList.remove('connecting');
                });
            });
        }
        
        // ===== CONNECTIONS =====
        let stateSelectedConnIndex = null;
        
        function renderConnections() {
            const svg = document.getElementById('connections-svg');
            svg.innerHTML = '';
            
            const ns = 'http://www.w3.org/2000/svg';
            state.connections.forEach((conn, idx) => {
                const fromNode = document.getElementById(conn.from);
                const toNode = document.getElementById(conn.to);
                
                if (!fromNode || !toNode) return;
                
                const fromShapeEl = fromNode.querySelector('.node-shape-wrap');
                const toShapeEl = toNode.querySelector('.node-shape-wrap');
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                let x1, y1, x2, y2;
                if (fromShapeEl && toShapeEl) {
                    const fromShape = fromShapeEl.getBoundingClientRect();
                    const toShape = toShapeEl.getBoundingClientRect();
                    const fromCenterX = fromShape.left + fromShape.width / 2;
                    const fromCenterY = fromShape.top + fromShape.height / 2;
                    const toCenterX = toShape.left + toShape.width / 2;
                    const toCenterY = toShape.top + toShape.height / 2;
                    const p1 = getShapeEdgePoint(fromShape, toCenterX, toCenterY, conn.fromPort);
                    const p2 = getShapeEdgePoint(toShape, fromCenterX, fromCenterY, conn.toPort);
                    x1 = (p1.x - canvasRect.left) / state.zoom;
                    y1 = (p1.y - canvasRect.top) / state.zoom;
                    x2 = (p2.x - canvasRect.left) / state.zoom;
                    y2 = (p2.y - canvasRect.top) / state.zoom;
                } else {
                    const fromSide = getSideToward(fromNode, toNode);
                    const toSide = getSideToward(toNode, fromNode);
                    const outKind = conn.type === 'yes' ? 'output-yes' : conn.type === 'no' ? 'output-no' : 'output';
                    const fromPort = getPortForSide(fromNode, outKind, fromSide);
                    const toPort = getPortForSide(toNode, 'input', toSide);
                    if (!fromPort || !toPort) return;
                    const fromRect = fromPort.getBoundingClientRect();
                    const toRect = toPort.getBoundingClientRect();
                    x1 = (fromRect.left + fromRect.width/2 - canvasRect.left) / state.zoom;
                    y1 = (fromRect.top + fromRect.height/2 - canvasRect.top) / state.zoom;
                    x2 = (toRect.left + toRect.width/2 - canvasRect.left) / state.zoom;
                    y2 = (toRect.top + toRect.height/2 - canvasRect.top) / state.zoom;
                }
                
                const midY = (y1 + y2) / 2;
                const midX = (x1 + x2) / 2;
                // Vertical: Ø®Ø· Ø¹Ù…ÙˆØ¯ÙŠ Ø«Ù… Ø£ÙÙ‚ÙŠ Ø«Ù… Ø¹Ù…ÙˆØ¯ÙŠ (V-H-V). Horizontal: Ø®Ø· Ø£ÙÙ‚ÙŠ Ø«Ù… Ø¹Ù…ÙˆØ¯ÙŠ Ø«Ù… Ø£ÙÙ‚ÙŠ (H-V-H)
                const pathD = state.flowDirection === 'horizontal'
                    ? `M ${x1} ${y1} L ${midX} ${y1} L ${midX} ${y2} L ${x2} ${y2}`   // â†” ÙŠØ³Ø§Ø±-ÙŠÙ…ÙŠÙ†: Ø£ÙÙ‚ÙŠ-Ø¹Ù…ÙˆØ¯ÙŠ-Ø£ÙÙ‚ÙŠ
                    : `M ${x1} ${y1} L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`;  // â†• Ø£Ø¹Ù„Ù‰-Ø£Ø³ÙÙ„: Ø¹Ù…ÙˆØ¯ÙŠ-Ø£ÙÙ‚ÙŠ-Ø¹Ù…ÙˆØ¯ÙŠ
                
                const path = document.createElementNS(ns, 'path');
                path.setAttribute('class', `connection-path ${conn.type}${stateSelectedConnIndex === idx ? ' selected' : ''}`);
                path.setAttribute('data-conn-index', String(idx));
                path.setAttribute('d', pathD);
                
                path.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectConnection(idx);
                });
                
                svg.appendChild(path);
                
                const gHandle = document.createElementNS(ns, 'g');
                gHandle.setAttribute('class', 'connection-handles');
                gHandle.setAttribute('data-conn-index', String(idx));
                const endHandle = document.createElementNS(ns, 'circle');
                endHandle.setAttribute('class', 'connection-end-handle');
                endHandle.setAttribute('cx', x2);
                endHandle.setAttribute('cy', y2);
                endHandle.setAttribute('r', 10);
                endHandle.setAttribute('title', 'Drag to reconnect to another step');
                endHandle.style.pointerEvents = 'all';
                endHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    startDragEdgeEnd(idx, conn, x1, y1, x2, y2);
                });
                gHandle.appendChild(endHandle);
                svg.appendChild(gHandle);
                
                const labelX = state.flowDirection === 'horizontal' ? midX : (x1 + x2) / 2;
                const labelY = state.flowDirection === 'horizontal' ? (y1 + y2) / 2 : midY;
                if (conn.type === 'yes' || conn.type === 'no') {
                    const offset = 18;
                    const lx = labelX;
                    const ly = labelY - offset;
                    const badgeW = 22, badgeH = 12, rx = 6;
                    const g = document.createElementNS(ns, 'g');
                    g.setAttribute('class', `connection-label-badge ${conn.type}`);
                    const rect = document.createElementNS(ns, 'rect');
                    rect.setAttribute('x', lx - badgeW / 2);
                    rect.setAttribute('y', ly - badgeH / 2);
                    rect.setAttribute('width', badgeW);
                    rect.setAttribute('height', badgeH);
                    rect.setAttribute('rx', rx);
                    g.appendChild(rect);
                    const text = document.createElementNS(ns, 'text');
                    text.setAttribute('x', lx);
                    text.setAttribute('y', ly);
                    text.textContent = conn.type === 'yes' ? 'Yes' : 'No';
                    g.appendChild(text);
                    svg.appendChild(g);
                }
            });
            
            if (state.draggingEdgeEnd) {
                const d = state.draggingEdgeEnd;
                const pathD = getDragPreviewPathD(d.fromX, d.fromY, d.currentX, d.currentY);
                const path = document.createElementNS(ns, 'path');
                path.setAttribute('class', `connection-path ${d.type} connection-preview`);
                path.setAttribute('d', pathD);
                path.setAttribute('stroke-dasharray', '6 4');
                svg.appendChild(path);
                d.previewPath = path;
            }
        }
        function getDragPreviewPathD(fromX, fromY, currentX, currentY) {
            const midY = (fromY + currentY) / 2;
            const midX = (fromX + currentX) / 2;
            return state.flowDirection === 'horizontal'
                ? `M ${fromX} ${fromY} L ${midX} ${fromY} L ${midX} ${currentY} L ${currentX} ${currentY}`
                : `M ${fromX} ${fromY} L ${fromX} ${midY} L ${currentX} ${midY} L ${currentX} ${currentY}`;
        }
        function updateDragPreview() {
            if (!state.draggingEdgeEnd || !state.draggingEdgeEnd.previewPath) return;
            const d = state.draggingEdgeEnd;
            d.previewPath.setAttribute('d', getDragPreviewPathD(d.fromX, d.fromY, d.currentX, d.currentY));
        }
        
        function startDragEdgeEnd(connIndex, conn, fromX, fromY, startX, startY) {
            const origConn = { from: conn.from, to: conn.to, type: conn.type, fromPort: conn.fromPort, toPort: conn.toPort };
            state.connections.splice(connIndex, 1);
            state.draggingEdgeEnd = {
                connIndex,
                from: conn.from,
                type: conn.type,
                fromX, fromY,
                currentX: startX,
                currentY: startY,
                origConn
            };
            stateSelectedConnIndex = null;
            
            function nodeUnderCursor(clientX, clientY) {
                let found = null;
                state.nodes.forEach(n => {
                    if (n.id === state.draggingEdgeEnd.from) return;
                    const el = document.getElementById(n.id);
                    if (!el) return;
                    const r = el.getBoundingClientRect();
                    if (clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom)
                        found = n.id;
                });
                return found;
            }
            
            const onMove = (e) => {
                if (!state.draggingEdgeEnd) return;
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                state.draggingEdgeEnd.currentX = (e.clientX - canvasRect.left - state.panX) / state.zoom;
                state.draggingEdgeEnd.currentY = (e.clientY - canvasRect.top - state.panY) / state.zoom;
                state.nodes.forEach(n => {
                    const el = document.getElementById(n.id);
                    if (!el) return;
                    const over = nodeUnderCursor(e.clientX, e.clientY);
                    if (over === n.id) el.classList.add('connection-drop-target');
                    else el.classList.remove('connection-drop-target');
                });
                updateDragPreview();
            };
            const onUp = (e) => {
                if (!state.draggingEdgeEnd) return;
                const newTo = nodeUnderCursor(e.clientX, e.clientY);
                state.nodes.forEach(n => {
                    const el = document.getElementById(n.id);
                    if (el) el.classList.remove('connection-drop-target');
                });
                if (newTo) {
                    const toNodeEl = document.getElementById(newTo);
                    const toPort = toNodeEl ? getSideOfPointFromShape(toNodeEl, e.clientX, e.clientY) : undefined;
                    state.connections.push({
                        from: state.draggingEdgeEnd.from,
                        to: newTo,
                        type: state.draggingEdgeEnd.type,
                        fromPort: origConn.fromPort,
                        toPort
                    });
                    saveToUndo();
                } else {
                    state.connections.push(origConn);
                }
                state.draggingEdgeEnd = null;
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
                renderConnections();
            };
            renderConnections();
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }
        
        function selectConnection(idx) {
            stateSelectedConnIndex = idx;
            renderConnections();
        }
        
        function deselectConnection() {
            stateSelectedConnIndex = null;
            renderConnections();
        }
        
        function deleteConnection(connIndex) {
            if (connIndex >= 0 && connIndex < state.connections.length) {
                state.connections.splice(connIndex, 1);
                saveToUndo();
                deselectConnection();
                renderConnections();
            }
        }
        
        // ===== SELECTION =====
        function selectNode(id) {
            deselectAll();
            const node = state.nodes.find(n => n.id === id);
            if (node) {
                state.selectedNode = node;
                document.getElementById(id).classList.add('selected');
                showProperties(node);
            }
        }
        
        function deselectAll() {
            state.selectedNode = null;
            document.querySelectorAll('.workflow-node').forEach(n => n.classList.remove('selected'));
            closeProperties();
        }
        
        // ===== PROPERTIES PANEL =====
        function showProperties(node) {
            const panel = document.getElementById('properties-panel');
            const icon = document.getElementById('prop-icon');
            const title = document.getElementById('prop-title');
            const type = document.getElementById('prop-type');
            const body = document.getElementById('prop-body');
            
            icon.className = 'properties-icon ' + getTypeClass(node.type);
            icon.textContent = getTypeIcon(node.type);
            title.textContent = node.name;
            type.textContent = node.type.charAt(0).toUpperCase() + node.type.slice(1);
            
            body.innerHTML = generatePropertiesForm(node);
            panel.classList.add('active');
        }
        
        // Helper function to get all available fields from trigger/form nodes
        function getAvailableFields() {
            const fields = [];
            state.nodes.forEach(n => {
                if ((n.type === 'trigger' || n.type === 'form') && n.config.fields) {
                    n.config.fields.forEach(f => {
                        if (f.name) {
                            fields.push({
                                name: f.name,
                                type: f.type,
                                required: f.required || false,
                                source: n.name
                            });
                        }
                    });
                }
            });
            return fields;
        }
        
        function generatePropertiesForm(node) {
            let html = `
                <div class="property-group">
                    <label class="property-label">Name</label>
                    <input type="text" class="property-input" value="${node.name}" 
                           onchange="updateNodeProperty('${node.id}', 'name', this.value)">
                </div>
                <div style="font-size:11px;color:#9ca3af;margin-bottom:8px;">Drag the label on the canvas to move it</div>
            `;
            
            // Get available fields for dropdowns
            const availableFields = getAvailableFields();
            
            switch (node.type) {
                case 'condition':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Field to Check</label>
                            ${availableFields.length > 0 ? `
                                <select class="property-select" onchange="updateNodeConfig('${node.id}', 'field', this.value)">
                                    <option value="">-- Select Field --</option>
                                    ${availableFields.map(f => `
                                        <option value="${f.name}" ${node.config.field === f.name ? 'selected' : ''}>
                                            ${f.name} (${f.type}) - from ${f.source}
                                        </option>
                                    `).join('')}
                                    <option value="_custom" ${node.config.field && !availableFields.find(f => f.name === node.config.field) ? 'selected' : ''}>
                                        âœï¸ Custom field...
                                    </option>
                                </select>
                                ${(node.config.field && !availableFields.find(f => f.name === node.config.field)) || node.config.field === '_custom' ? `
                                    <input type="text" class="property-input" style="margin-top:8px;" placeholder="Enter custom field name" 
                                           value="${node.config.field === '_custom' ? '' : (node.config.field || '')}"
                                           onchange="updateNodeConfig('${node.id}', 'field', this.value)">
                                ` : ''}
                            ` : `
                                <input type="text" class="property-input" placeholder="e.g., amount, status" 
                                       value="${node.config.field || ''}"
                                       onchange="updateNodeConfig('${node.id}', 'field', this.value)">
                                <div style="font-size:11px;color:#f59e0b;margin-top:4px;">
                                    ğŸ’¡ Tip: Add fields to your Start/Form node first
                                </div>
                            `}
                        </div>
                        <div class="property-group">
                            <label class="property-label">Operator</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'operator', this.value)">
                                <option value="equals" ${node.config.operator === 'equals' ? 'selected' : ''}>Equals</option>
                                <option value="not_equals" ${node.config.operator === 'not_equals' ? 'selected' : ''}>Not Equals</option>
                                <option value="greater_than" ${node.config.operator === 'greater_than' ? 'selected' : ''}>Greater Than</option>
                                <option value="less_than" ${node.config.operator === 'less_than' ? 'selected' : ''}>Less Than</option>
                                <option value="contains" ${node.config.operator === 'contains' ? 'selected' : ''}>Contains</option>
                                <option value="is_empty" ${node.config.operator === 'is_empty' ? 'selected' : ''}>Is Empty</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Value</label>
                            <input type="text" class="property-input" placeholder="Compare value" 
                                   value="${node.config.value || ''}"
                                   onchange="updateNodeConfig('${node.id}', 'value', this.value)">
                        </div>
                    `;
                    break;
                    
                case 'delay':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Wait Duration</label>
                            <div style="display:flex;gap:8px;">
                                <input type="number" class="property-input" style="width:100px;" 
                                       value="${node.config.duration || 5}"
                                       onchange="updateNodeConfig('${node.id}', 'duration', parseInt(this.value))">
                                <select class="property-select" onchange="updateNodeConfig('${node.id}', 'unit', this.value)">
                                    <option value="seconds" ${node.config.unit === 'seconds' ? 'selected' : ''}>Seconds</option>
                                    <option value="minutes" ${node.config.unit === 'minutes' ? 'selected' : ''}>Minutes</option>
                                    <option value="hours" ${node.config.unit === 'hours' ? 'selected' : ''}>Hours</option>
                                    <option value="days" ${node.config.unit === 'days' ? 'selected' : ''}>Days</option>
                                </select>
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'tool':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Select Tool</label>
                            <div class="tool-selector">
                                ${state.tools.map(t => `
                                    <div class="tool-option ${node.config.toolId === t.id ? 'selected' : ''}" 
                                         onclick="selectTool('${node.id}', '${t.id}')">
                                        <div class="tool-option-icon">${getToolIcon(t.type)}</div>
                                        <div class="tool-option-info">
                                            <div class="tool-option-name">${t.name}</div>
                                            <div class="tool-option-type">${t.type}</div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'approval':
                    const aCfg = node.config || {};
                    const aSrc = aCfg.assignee_source || (aCfg.approvers && aCfg.approvers.length ? 'platform_user' : 'platform_user');
                    const aIds = aCfg.assignee_ids || aCfg.approvers || [];
                    const aToolId = aCfg.assignee_tool_id || '';
                    const timeoutVal = aCfg.timeout_hours != null ? aCfg.timeout_hours : (aCfg.timeout != null ? aCfg.timeout : 24);
                    const approverLabel = aSrc === 'tool' ? (state.tools.find(t => t.id === aToolId) || {}).name || 'Tool' : (aSrc.replace('platform_','') + ': ' + aIds.length + ' selected');
                    html += `
                        <div class="property-group">
                            <label class="property-label">Approval Message</label>
                            <textarea class="property-textarea" placeholder="Message to show approvers..."
                                      onchange="updateNodeConfig('${node.id}', 'message', this.value)">${aCfg.message || ''}</textarea>
                            ${availableFields.length > 0 ? `
                                <div style="margin-top:8px;padding:8px;background:#1a1f2e;border-radius:6px;">
                                    <div style="font-size:11px;color:#6b7280;margin-bottom:6px;">ğŸ“‹ Available Fields (click to insert):</div>
                                    <div style="display:flex;flex-wrap:wrap;gap:4px;">
                                        ${availableFields.map(f => `
                                            <button onclick="insertFieldRef('${node.id}', 'message', '{{${f.name}}}')" 
                                                    style="padding:4px 8px;background:#374151;border:none;border-radius:4px;color:#a5b4fc;font-size:11px;cursor:pointer;">
                                                {{${f.name}}}
                                            </button>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        <div class="property-group">
                            <label class="property-label">Approvers</label>
                            <div style="font-size:12px;color:#9ca3af;margin-bottom:6px;">From: ${approverLabel}</div>
                            <button type="button" onclick="openApprovalConfigModal('${node.id}')" class="property-input" style="cursor:pointer;text-align:left;">
                                Configure approvers (Platform User / Role / Group / Tool)
                            </button>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Timeout (hours)</label>
                            <input type="number" class="property-input" value="${timeoutVal}" min="1"
                                   onchange="updateNodeConfig('${node.id}', 'timeout_hours', parseInt(this.value) || 24)">
                        </div>
                    `;
                    break;
                    
                case 'notification':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Channel</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'channel', this.value)">
                                <option value="email" ${node.config.channel === 'email' ? 'selected' : ''}>Email</option>
                                <option value="slack" ${node.config.channel === 'slack' ? 'selected' : ''}>Slack</option>
                                <option value="teams" ${node.config.channel === 'teams' ? 'selected' : ''}>Microsoft Teams</option>
                                <option value="sms" ${node.config.channel === 'sms' ? 'selected' : ''}>SMS</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Recipient</label>
                            ${availableFields.filter(f => f.type === 'email' || f.type === 'text').length > 0 ? `
                                <select class="property-select" onchange="updateNodeConfig('${node.id}', 'recipient', this.value)">
                                    <option value="">-- Select Field --</option>
                                    ${availableFields.filter(f => f.type === 'email' || f.type === 'text').map(f => `
                                        <option value="{{${f.name}}}" ${node.config.recipient === '{{' + f.name + '}}' ? 'selected' : ''}>
                                            ${f.name} (${f.type})
                                        </option>
                                    `).join('')}
                                    <option value="_custom">âœï¸ Custom...</option>
                                </select>
                            ` : ''}
                            <input type="text" class="property-input" ${availableFields.length > 0 ? 'style="margin-top:8px;"' : ''} 
                                   placeholder="email@example.com or {{field_name}}" 
                                   value="${node.config.recipient || ''}"
                                   onchange="updateNodeConfig('${node.id}', 'recipient', this.value)">
                        </div>
                        <div class="property-group">
                            <label class="property-label">Message Template</label>
                            <textarea class="property-textarea" placeholder="Enter message template..."
                                      onchange="updateNodeConfig('${node.id}', 'template', this.value)">${node.config.template || ''}</textarea>
                            ${availableFields.length > 0 ? `
                                <div style="margin-top:8px;padding:8px;background:#1a1f2e;border-radius:6px;">
                                    <div style="font-size:11px;color:#6b7280;margin-bottom:6px;">ğŸ“‹ Available Fields (click to insert):</div>
                                    <div style="display:flex;flex-wrap:wrap;gap:4px;">
                                        ${availableFields.map(f => `
                                            <button onclick="insertFieldRef('${node.id}', 'template', '{{${f.name}}}')" 
                                                    style="padding:4px 8px;background:#374151;border:none;border-radius:4px;color:#a5b4fc;font-size:11px;cursor:pointer;">
                                                {{${f.name}}}
                                            </button>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                    break;
                    
                case 'ai':
                    html += `
                        <div class="property-group">
                            <label class="property-label">AI Prompt</label>
                            <textarea class="property-textarea" style="min-height:120px;" 
                                      placeholder="Describe what the AI should do..."
                                      onchange="updateNodeConfig('${node.id}', 'prompt', this.value)">${node.config.prompt || ''}</textarea>
                            ${availableFields.length > 0 ? `
                                <div style="margin-top:8px;padding:8px;background:#1a1f2e;border-radius:6px;">
                                    <div style="font-size:11px;color:#6b7280;margin-bottom:6px;">ğŸ“‹ Available Fields (click to insert):</div>
                                    <div style="display:flex;flex-wrap:wrap;gap:4px;">
                                        ${availableFields.map(f => `
                                            <button onclick="insertFieldRef('${node.id}', 'prompt', '{{${f.name}}}')" 
                                                    style="padding:4px 8px;background:#374151;border:none;border-radius:4px;color:#a5b4fc;font-size:11px;cursor:pointer;">
                                                {{${f.name}}}
                                            </button>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        <div class="property-group">
                            <label class="property-label">AI Model</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'model', this.value)">
                                <option value="gpt-4o" ${node.config.model === 'gpt-4o' ? 'selected' : ''}>GPT-4o (Fast)</option>
                                <option value="gpt-4o-mini" ${node.config.model === 'gpt-4o-mini' ? 'selected' : ''}>GPT-4o Mini</option>
                                <option value="claude-sonnet-4-20250514" ${node.config.model === 'claude-sonnet-4-20250514' ? 'selected' : ''}>Claude Sonnet</option>
                            </select>
                        </div>
                    `;
                    break;
                
                case 'form':
                case 'trigger':
                    // Form fields editor
                    const fields = node.config.fields || [];
                    html += `
                        <div class="property-group">
                            <label class="property-label">Form Title</label>
                            <input type="text" class="property-input" placeholder="e.g., Submit Expense Report" 
                                   value="${node.config.title || ''}"
                                   onchange="updateNodeConfig('${node.id}', 'title', this.value)">
                        </div>
                        <div class="property-group">
                            <label class="property-label">Input Fields</label>
                            <div id="form-fields-list" style="margin-bottom:12px;">
                                ${fields.length === 0 ? '<div style="color:#6b7280;font-size:12px;padding:8px;">No fields yet. Add some below.</div>' : ''}
                                ${fields.map((f, idx) => `
                                    <div class="form-field-item" style="display:flex;gap:8px;align-items:center;margin-bottom:8px;padding:8px;background:#1a1f2e;border-radius:6px;">
                                        <input type="text" class="property-input" style="flex:1;margin:0;" placeholder="Field name"
                                               value="${f.name || ''}"
                                               onchange="updateFormField('${node.id}', ${idx}, 'name', this.value)">
                                        <select class="property-select" style="width:100px;margin:0;"
                                                onchange="updateFormField('${node.id}', ${idx}, 'type', this.value)">
                                            <option value="text" ${f.type === 'text' ? 'selected' : ''}>Text</option>
                                            <option value="number" ${f.type === 'number' ? 'selected' : ''}>Number</option>
                                            <option value="email" ${f.type === 'email' ? 'selected' : ''}>Email</option>
                                            <option value="date" ${f.type === 'date' ? 'selected' : ''}>Date</option>
                                            <option value="textarea" ${f.type === 'textarea' ? 'selected' : ''}>Long Text</option>
                                            <option value="select" ${f.type === 'select' ? 'selected' : ''}>Dropdown</option>
                                            <option value="file" ${f.type === 'file' ? 'selected' : ''}>File</option>
                                        </select>
                                        <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:#9ca3af;">
                                            <input type="checkbox" ${f.required ? 'checked' : ''} 
                                                   onchange="updateFormField('${node.id}', ${idx}, 'required', this.checked)">
                                            Req
                                        </label>
                                        <button onclick="removeFormField('${node.id}', ${idx})" 
                                                style="background:#ef4444;border:none;color:white;width:24px;height:24px;border-radius:4px;cursor:pointer;">Ã—</button>
                                    </div>
                                `).join('')}
                            </div>
                            <button onclick="addFormField('${node.id}')" 
                                    style="width:100%;padding:10px;background:#22c55e;border:none;border-radius:8px;color:white;cursor:pointer;font-size:13px;">
                                + Add Input Field
                            </button>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Submit Button Text</label>
                            <input type="text" class="property-input" placeholder="Submit" 
                                   value="${node.config.submitText || 'Submit'}"
                                   onchange="updateNodeConfig('${node.id}', 'submitText', this.value)">
                        </div>
                    `;
                    break;
                
                case 'schedule':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Schedule (Cron Expression)</label>
                            <input type="text" class="property-input" placeholder="0 9 * * *" 
                                   value="${node.config.cron || '0 9 * * *'}"
                                   onchange="updateNodeConfig('${node.id}', 'cron', this.value)">
                            <div style="font-size:11px;color:#6b7280;margin-top:4px;">
                                Format: minute hour day month weekday<br>
                                Examples: "0 9 * * *" (daily 9AM), "0 */4 * * *" (every 4 hours)
                            </div>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Timezone</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'timezone', this.value)">
                                <option value="UTC" ${node.config.timezone === 'UTC' ? 'selected' : ''}>UTC</option>
                                <option value="America/New_York" ${node.config.timezone === 'America/New_York' ? 'selected' : ''}>Eastern (US)</option>
                                <option value="America/Los_Angeles" ${node.config.timezone === 'America/Los_Angeles' ? 'selected' : ''}>Pacific (US)</option>
                                <option value="Europe/London" ${node.config.timezone === 'Europe/London' ? 'selected' : ''}>London</option>
                                <option value="Europe/Paris" ${node.config.timezone === 'Europe/Paris' ? 'selected' : ''}>Paris</option>
                                <option value="Asia/Dubai" ${node.config.timezone === 'Asia/Dubai' ? 'selected' : ''}>Dubai</option>
                                <option value="Africa/Cairo" ${node.config.timezone === 'Africa/Cairo' ? 'selected' : ''}>Cairo</option>
                                <option value="Asia/Tokyo" ${node.config.timezone === 'Asia/Tokyo' ? 'selected' : ''}>Tokyo</option>
                            </select>
                        </div>
                    `;
                    break;
                
                case 'webhook':
                    html += `
                        <div class="property-group">
                            <label class="property-label">HTTP Method</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'method', this.value)">
                                <option value="POST" ${node.config.method === 'POST' ? 'selected' : ''}>POST</option>
                                <option value="GET" ${node.config.method === 'GET' ? 'selected' : ''}>GET</option>
                                <option value="PUT" ${node.config.method === 'PUT' ? 'selected' : ''}>PUT</option>
                                <option value="PATCH" ${node.config.method === 'PATCH' ? 'selected' : ''}>PATCH</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Webhook Path</label>
                            <input type="text" class="property-input" placeholder="/trigger" 
                                   value="${node.config.path || '/trigger'}"
                                   onchange="updateNodeConfig('${node.id}', 'path', this.value)">
                            <div style="font-size:11px;color:#6b7280;margin-top:4px;">
                                Full URL: /api/webhooks/process/{id}${node.config.path || '/trigger'}
                            </div>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Authentication</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'auth', this.value)">
                                <option value="none" ${node.config.auth === 'none' ? 'selected' : ''}>None</option>
                                <option value="api_key" ${node.config.auth === 'api_key' ? 'selected' : ''}>API Key</option>
                                <option value="bearer" ${node.config.auth === 'bearer' ? 'selected' : ''}>Bearer Token</option>
                            </select>
                        </div>
                    `;
                    break;
                
                case 'loop':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Collection to Iterate</label>
                            ${availableFields.length > 0 ? `
                                <select class="property-select" onchange="updateNodeConfig('${node.id}', 'collection', this.value)">
                                    <option value="">-- Select Field --</option>
                                    ${availableFields.map(f => `
                                        <option value="${f.name}" ${node.config.collection === f.name ? 'selected' : ''}>
                                            ${f.name} (${f.type}) - from ${f.source}
                                        </option>
                                    `).join('')}
                                    <option value="_custom" ${node.config.collection && !availableFields.find(f => f.name === node.config.collection) ? 'selected' : ''}>
                                        âœï¸ Custom...
                                    </option>
                                </select>
                                ${(node.config.collection && !availableFields.find(f => f.name === node.config.collection)) ? `
                                    <input type="text" class="property-input" style="margin-top:8px;" placeholder="e.g., items, data.results" 
                                           value="${node.config.collection || ''}"
                                           onchange="updateNodeConfig('${node.id}', 'collection', this.value)">
                                ` : ''}
                            ` : `
                                <input type="text" class="property-input" placeholder="e.g., items, users, data.results" 
                                       value="${node.config.collection || ''}"
                                       onchange="updateNodeConfig('${node.id}', 'collection', this.value)">
                            `}
                            <div style="font-size:11px;color:#6b7280;margin-top:4px;">
                                The array/list to iterate over
                            </div>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Item Variable Name</label>
                            <input type="text" class="property-input" placeholder="item" 
                                   value="${node.config.itemVar || 'item'}"
                                   onchange="updateNodeConfig('${node.id}', 'itemVar', this.value)">
                            <div style="font-size:11px;color:#6b7280;margin-top:4px;">
                                Access current item with: {{${node.config.itemVar || 'item'}}}
                            </div>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Max Iterations</label>
                            <input type="number" class="property-input" placeholder="100" 
                                   value="${node.config.maxIterations || 100}"
                                   onchange="updateNodeConfig('${node.id}', 'maxIterations', parseInt(this.value))">
                        </div>
                    `;
                    break;
                
                case 'end':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Output Variable</label>
                            <input type="text" class="property-input" placeholder="e.g., result, response" 
                                   value="${node.config.output || ''}"
                                   onchange="updateNodeConfig('${node.id}', 'output', this.value)">
                            <div style="font-size:11px;color:#6b7280;margin-top:4px;">
                                The variable to return as workflow result
                            </div>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Success Message</label>
                            <textarea class="property-textarea" placeholder="Workflow completed successfully"
                                      onchange="updateNodeConfig('${node.id}', 'successMessage', this.value)">${node.config.successMessage || ''}</textarea>
                        </div>
                    `;
                    break;
                
                case 'action':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Action Description</label>
                            <textarea class="property-textarea" placeholder="Describe what this action does..."
                                      onchange="updateNodeConfig('${node.id}', 'description', this.value)">${node.config.description || ''}</textarea>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Action Type</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'actionType', this.value)">
                                <option value="custom" ${node.config.actionType === 'custom' ? 'selected' : ''}>Custom Action</option>
                                <option value="http" ${node.config.actionType === 'http' ? 'selected' : ''}>HTTP Request</option>
                                <option value="script" ${node.config.actionType === 'script' ? 'selected' : ''}>Run Script</option>
                                <option value="transform" ${node.config.actionType === 'transform' ? 'selected' : ''}>Transform Data</option>
                            </select>
                        </div>
                    `;
                    break;
                    
                default:
                    html += `
                        <div class="property-group">
                            <label class="property-label">Description</label>
                            <textarea class="property-textarea" placeholder="What does this step do?"
                                      onchange="updateNodeConfig('${node.id}', 'description', this.value)">${node.config.description || ''}</textarea>
                        </div>
                    `;
            }
            
            // Delete button
            html += `
                <div style="margin-top:24px; padding-top:16px; border-top:1px solid #2d3748;">
                    <button onclick="deleteNode('${node.id}')" 
                            style="width:100%; padding:10px; background:#ef4444; border:none; border-radius:8px; color:white; cursor:pointer;">
                        ğŸ—‘ï¸ Delete Node
                    </button>
                </div>
            `;
            
            return html;
        }
        
        function closeProperties() {
            document.getElementById('properties-panel').classList.remove('active');
        }
        
        function updateNodeProperty(nodeId, prop, value) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node) {
                node[prop] = value;
                refreshNode(node);
                saveToUndo();
            }
        }
        
        function updateNodeConfig(nodeId, key, value) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node) {
                node.config[key] = value;
                refreshNode(node);
                saveToUndo();
            }
        }
        
        function selectTool(nodeId, toolId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node) {
                const tool = state.tools.find(t => t.id === toolId);
                node.config.toolId = toolId;
                if (tool) node.name = tool.name;
                refreshNode(node);
                showProperties(node); // Refresh panel
                saveToUndo();
            }
        }
        
        // Approval config modal (Approvers from Platform User / Role / Group / Tool)
        let approvalConfigNodeId = null;
        async function openApprovalConfigModal(nodeId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;
            approvalConfigNodeId = nodeId;
            const modal = document.getElementById('approval-config-modal');
            const cfg = node.config || {};
            let source = cfg.assignee_source || '';
            if (!source && (cfg.approvers || []).length) source = 'platform_user';
            if (!source) source = 'platform_user';
            const assigneeIds = cfg.assignee_ids || cfg.approvers || [];
            const assigneeToolId = cfg.assignee_tool_id || '';
            const token = getAuthToken();
            const headers = { 'Authorization': 'Bearer ' + token };
            let users = [], roles = [], groups = [], tools = [];
            try {
                const [uRes, rRes, gRes, tRes] = await Promise.all([
                    fetch('/api/security/users', { headers }),
                    fetch('/api/security/roles', { headers }),
                    fetch('/api/security/groups', { headers }),
                    fetch('/api/tools/accessible', { headers })
                ]);
                if (uRes.ok) { const d = await uRes.json(); users = Array.isArray(d) ? d : (d.users || []); }
                if (rRes.ok) { const d = await rRes.json(); roles = Array.isArray(d) ? d : (d.roles || []); }
                if (gRes.ok) { const d = await gRes.json(); groups = Array.isArray(d) ? d : (d.groups || []); }
                if (tRes.ok) { const d = await tRes.json(); tools = d.tools || []; }
            } catch (e) { console.error('Load approval options:', e); }
            const userOpts = users.map(u => '<option value="' + u.id + '"' + (assigneeIds.includes(u.id) ? ' selected' : '') + '>' + (u.name || u.email || u.id).substring(0, 40) + '</option>').join('');
            const roleOpts = roles.map(r => '<option value="' + r.id + '"' + (assigneeIds.includes(r.id) ? ' selected' : '') + '>' + (r.name || r.id).substring(0, 40) + '</option>').join('');
            const groupOpts = groups.map(g => '<option value="' + g.id + '"' + (assigneeIds.includes(g.id) ? ' selected' : '') + '>' + (g.name || g.id).substring(0, 40) + '</option>').join('');
            const toolOpts = tools.map(t => '<option value="' + t.id + '"' + (assigneeToolId === t.id ? ' selected' : '') + '>' + (t.name || t.id).substring(0, 40) + '</option>').join('');
            document.getElementById('approval-config-source').value = source;
            document.getElementById('approval-config-user-list').innerHTML = userOpts;
            document.getElementById('approval-config-role-list').innerHTML = roleOpts;
            document.getElementById('approval-config-group-list').innerHTML = groupOpts;
            document.getElementById('approval-config-tool').innerHTML = '<option value="">â€” None â€”</option>' + toolOpts;
            document.getElementById('approval-config-tool').value = assigneeToolId;
            onApprovalConfigSourceChange();
            modal.classList.add('show');
        }
        function onApprovalConfigSourceChange() {
            const v = document.getElementById('approval-config-source').value;
            document.getElementById('approval-config-platform-user-wrap').classList.toggle('hidden', v !== 'platform_user');
            document.getElementById('approval-config-platform-role-wrap').classList.toggle('hidden', v !== 'platform_role');
            document.getElementById('approval-config-platform-group-wrap').classList.toggle('hidden', v !== 'platform_group');
            document.getElementById('approval-config-tool-wrap').classList.toggle('hidden', v !== 'tool');
        }
        function saveApprovalConfig() {
            if (!approvalConfigNodeId) return;
            const node = state.nodes.find(n => n.id === approvalConfigNodeId);
            if (!node) { approvalConfigNodeId = null; return; }
            const source = document.getElementById('approval-config-source').value;
            const userList = document.getElementById('approval-config-user-list');
            const roleList = document.getElementById('approval-config-role-list');
            const groupList = document.getElementById('approval-config-group-list');
            const toolSelect = document.getElementById('approval-config-tool');
            const assigneeIds = [];
            if (source === 'platform_user') { for (let i = 0; i < userList.options.length; i++) if (userList.options[i].selected) assigneeIds.push(userList.options[i].value); }
            else if (source === 'platform_role') { for (let i = 0; i < roleList.options.length; i++) if (roleList.options[i].selected) assigneeIds.push(roleList.options[i].value); }
            else if (source === 'platform_group') { for (let i = 0; i < groupList.options.length; i++) if (groupList.options[i].selected) assigneeIds.push(groupList.options[i].value); }
            const assigneeType = source === 'platform_user' ? 'user' : source === 'platform_role' ? 'role' : source === 'platform_group' ? 'group' : 'user';
            node.config.assignee_source = source;
            node.config.assignee_type = assigneeType;
            node.config.assignee_ids = assigneeIds;
            node.config.assignee_tool_id = source === 'tool' ? (toolSelect.value || '') : undefined;
            if (node.config.approvers !== undefined) delete node.config.approvers;
            document.getElementById('approval-config-modal').classList.remove('show');
            approvalConfigNodeId = null;
            refreshNode(node);
            showProperties(node);
            saveToUndo();
        }
        function closeApprovalConfigModal() {
            document.getElementById('approval-config-modal').classList.remove('show');
            approvalConfigNodeId = null;
        }
        
        // Form field management functions
        function addFormField(nodeId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node) {
                if (!node.config.fields) node.config.fields = [];
                node.config.fields.push({
                    name: '',
                    type: 'text',
                    required: false,
                    placeholder: ''
                });
                refreshNode(node);
                showProperties(node);
                saveToUndo();
            }
        }
        
        function updateFormField(nodeId, fieldIndex, key, value) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node && node.config.fields && node.config.fields[fieldIndex]) {
                node.config.fields[fieldIndex][key] = value;
                refreshNode(node);
                saveToUndo();
            }
        }
        
        function removeFormField(nodeId, fieldIndex) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node && node.config.fields) {
                node.config.fields.splice(fieldIndex, 1);
                refreshNode(node);
                showProperties(node);
                saveToUndo();
            }
        }
        
        // Helper to insert field references into textareas
        function insertFieldRef(nodeId, configKey, fieldRef) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node) {
                const currentValue = node.config[configKey] || '';
                node.config[configKey] = currentValue + (currentValue ? ' ' : '') + fieldRef;
                refreshNode(node);
                showProperties(node);
                saveToUndo();
            }
        }
        
        function refreshNode(node) {
            const oldEl = document.getElementById(node.id);
            if (oldEl) {
                oldEl.remove();
                renderNode(node);
                if (state.selectedNode && state.selectedNode.id === node.id) {
                    document.getElementById(node.id).classList.add('selected');
                }
                renderConnections();
            }
        }
        
        function deleteNode(nodeId) {
            if (!confirm('Delete this node?')) return;
            
            if (state.selectedNode && state.selectedNode.id === nodeId) state.selectedNode = null;
            state.connections = state.connections.filter(c => c.from !== nodeId && c.to !== nodeId);
            state.nodes = state.nodes.filter(n => n.id !== nodeId);
            document.getElementById(nodeId)?.remove();
            closeProperties();
            renderConnections();
            updateEmptyState();
            saveToUndo();
        }
        
        function showNodeMenu(nodeId) {
            // Simple delete for now
            if (confirm('Delete this node?')) {
                deleteNode(nodeId);
            }
        }
        
        // ===== TOOLS =====
        function getAuthToken() {
            return localStorage.getItem('agentforge_token') || sessionStorage.getItem('agentforge_token');
        }
        
        function loadTools() {
            const token = getAuthToken();
            fetch('/api/tools', {
                headers: { 'Authorization': 'Bearer ' + token }
            })
            .then(r => r.json())
            .then(data => {
                state.tools = data.tools || [];
                renderToolsPalette();
            })
            .catch(e => {
                console.error('Failed to load tools:', e);
            });
        }
        
        function renderToolsPalette() {
            const container = document.getElementById('platform-tools-list');
            
            if (!state.tools.length) {
                container.innerHTML = '<div style="font-size:11px;color:#6b7280;padding:8px;">No tools available</div>';
                return;
            }
            
            container.innerHTML = state.tools.map(t => `
                <div class="palette-item" draggable="true" data-type="tool" data-tool-id="${t.id}">
                    <div class="palette-icon tool palette-shape-task">${getTypeSvgIcon('tool')}</div>
                    <div class="palette-info">
                        <div class="palette-name">${t.name}</div>
                        <div class="palette-desc">${t.type}</div>
                    </div>
                </div>
            `).join('');
            
            container.querySelectorAll('.palette-item').forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('nodeType', 'tool');
                    e.dataTransfer.setData('toolId', item.dataset.toolId);
                });
            });
        }
        
        function getToolIcon(type) {
            const icons = {
                api: 'ğŸŒ',
                database: 'ğŸ—„ï¸',
                knowledge_base: 'ğŸ“š',
                email: 'ğŸ“§',
                website: 'ğŸ”—'
            };
            return icons[type] || 'ğŸ”§';
        }
        
        // ===== ZOOM =====
        function zoomIn() {
            state.zoom = Math.min(state.zoom * 1.2, 2);
            updateCanvasTransform();
            document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%';
        }
        
        function zoomOut() {
            state.zoom = Math.max(state.zoom * 0.8, 0.25);
            updateCanvasTransform();
            document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%';
        }
        
        function zoomReset() {
            state.zoom = 1;
            state.panX = 0;
            state.panY = 0;
            updateCanvasTransform();
            document.getElementById('zoom-level').textContent = '100%';
        }
        
        function zoomFit() {
            if (state.nodes.length === 0) return;
            const container = document.getElementById('canvas-container');
            const padding = 80;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.nodes.forEach(n => {
                const el = document.getElementById(n.id);
                if (!el) return;
                const w = el.offsetWidth || 200, h = el.offsetHeight || 80;
                minX = Math.min(minX, n.x);
                minY = Math.min(minY, n.y);
                maxX = Math.max(maxX, n.x + w);
                maxY = Math.max(maxY, n.y + h);
            });
            const cw = container.clientWidth, ch = container.clientHeight;
            const bw = maxX - minX + padding * 2, bh = maxY - minY + padding * 2;
            const scale = Math.min(cw / bw, ch / bh, 2);
            state.zoom = Math.max(0.25, scale);
            const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
            state.panX = cw / 2 - cx * state.zoom;
            state.panY = ch / 2 - cy * state.zoom;
            updateCanvasTransform();
            document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%';
        }
        
        // ===== UNDO/REDO =====
        function saveToUndo() {
            state.undoStack.push(JSON.stringify({ nodes: state.nodes, connections: state.connections }));
            state.redoStack = [];
        }
        
        function undoAction() {
            if (state.undoStack.length > 1) {
                state.redoStack.push(state.undoStack.pop());
                const prev = JSON.parse(state.undoStack[state.undoStack.length - 1]);
                restoreState(prev);
            }
        }
        
        function redoAction() {
            if (state.redoStack.length > 0) {
                const next = JSON.parse(state.redoStack.pop());
                state.undoStack.push(JSON.stringify(next));
                restoreState(next);
            }
        }
        
        function restoreState(data) {
            state.nodes = data.nodes;
            state.connections = data.connections;
            
            // Clear and re-render
            document.getElementById('canvas').innerHTML = '';
            state.nodes.forEach(n => renderNode(n));
            renderConnections();
            updateEmptyState();
        }
        
        // ===== SAVE/LOAD =====
        function loadWorkflowFromUrl() {
            const params = new URLSearchParams(window.location.search);
            const agentId = params.get('agent');
            
            if (agentId) {
                state.agentId = agentId;
                loadWorkflow(agentId);
            } else {
                // New workflow - add start node
                createNode('trigger', 400, 100);
            }
        }
        
        async function loadWorkflow(agentId) {
            try {
                const token = getAuthToken();
                const response = await fetch('/api/agents/' + agentId, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                
                if (!response.ok) throw new Error('Failed to load');
                
                const agent = await response.json();
                document.getElementById('workflow-name').value = agent.name || 'My Workflow';
                
                if (agent.process_definition) {
                    const def = agent.process_definition;
                    state.nodes = def.nodes || [];
                    state.connections = def.edges || [];
                    
                    // ØªØ¬Ù†Ø¨ ØªÙƒØ±Ø§Ø± Ø§Ù„Ù€ id: Ø£ÙŠ Ø¹Ù‚Ø¯Ø© Ø¬Ø¯ÙŠØ¯Ø© ØªØ£Ø®Ø° id Ø£ÙƒØ¨Ø± Ù…Ù† ÙƒÙ„ Ø§Ù„Ø¹Ù‚Ø¯ Ø§Ù„Ù…Ø­Ù…Ù„Ø©
                    let maxNum = 0;
                    state.nodes.forEach(n => {
                        const m = (n.id || '').match(/^node_(\d+)$/);
                        if (m) maxNum = Math.max(maxNum, parseInt(m[1], 10));
                    });
                    nodeIdCounter = maxNum + 1;
                    
                    state.nodes.forEach(n => renderNode(n));
                    renderConnections();
                    updateEmptyState();
                }
            } catch (e) {
                console.error('Load error:', e);
                alert('Could not load workflow');
            }
        }
        
        async function saveWorkflow() {
            const name = document.getElementById('workflow-name').value;
            const def = {
                nodes: state.nodes,
                edges: state.connections
            };
            
            const token = getAuthToken();
            if (!token) {
                alert('âŒ Please sign in first. Save and Publish require authentication.\n\nIf you opened the Workflow Builder in a new tab, try opening it from the main app (Create â†’ Workflow â†’ Visual Builder) after signing in.');
                return;
            }
            
            try {
                const method = state.agentId ? 'PUT' : 'POST';
                const url = state.agentId ? '/api/agents/' + state.agentId : '/api/agents';
                
                const body = state.agentId ? {
                    name,
                    goal: 'Workflow automation',
                    process_definition: def,
                    status: 'draft'
                } : {
                    name,
                    goal: 'Workflow automation',
                    agent_type: 'process',
                    personality: {},
                    tasks: [],
                    tool_ids: [],
                    model_id: 'gpt-4o',
                    process_definition: def,
                    process_settings: {},
                    status: 'draft'
                };
                
                const response = await fetch(url, {
                    method,
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify(body)
                });
                
                let errMsg = 'Could not save workflow';
                if (!response.ok) {
                    try {
                        const errBody = await response.json();
                        errMsg = errBody.detail || errBody.message || errMsg;
                        if (Array.isArray(errMsg)) errMsg = errMsg.map(d => d.msg || JSON.stringify(d)).join('; ');
                    } catch (_) {
                        errMsg = await response.text() || response.statusText || errMsg;
                    }
                    throw new Error(errMsg);
                }
                
                const data = await response.json();
                if (!state.agentId) {
                    state.agentId = data.agent_id || data.id;
                    window.history.replaceState({}, '', '?agent=' + state.agentId);
                }
                
                alert('âœ… Workflow saved!');
            } catch (e) {
                console.error('Save error:', e);
                alert('âŒ ' + (e.message || 'Could not save workflow'));
            }
        }
        
        async function publishWorkflow() {
            if (!state.agentId) {
                await saveWorkflow();
                if (!state.agentId) return;
            } else {
                await saveWorkflow();
            }
            
            const token = getAuthToken();
            if (!token) {
                alert('âŒ Please sign in first.');
                return;
            }
            
            try {
                const response = await fetch('/api/agents/' + state.agentId, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({ status: 'published', is_published: true })
                });
                
                let errMsg = 'Could not publish workflow';
                if (!response.ok) {
                    try {
                        const errBody = await response.json();
                        errMsg = errBody.detail || errBody.message || errMsg;
                        if (Array.isArray(errMsg)) errMsg = errMsg.map(d => d.msg || JSON.stringify(d)).join('; ');
                    } catch (_) {
                        errMsg = await response.text() || response.statusText || errMsg;
                    }
                    throw new Error(errMsg);
                }
                
                alert('ğŸš€ Workflow published!');
            } catch (e) {
                console.error('Publish error:', e);
                alert('âŒ ' + (e.message || 'Could not publish workflow'));
            }
        }
        
        function testWorkflow() {
            // Get available input fields
            const fields = getAvailableFields();
            
            if (fields.length === 0) {
                alert('No input fields found. Add fields to your Start/Form node first.');
                return;
            }
            
            // Create test modal
            const modal = document.createElement('div');
            modal.id = 'test-workflow-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.8); display: flex; align-items: center; 
                justify-content: center; z-index: 10000;
            `;
            
            modal.innerHTML = `
                <div style="background:#1f2937; border-radius:12px; width:500px; max-width:90%; max-height:80vh; overflow:auto;">
                    <div style="padding:20px; border-bottom:1px solid #374151;">
                        <h2 style="margin:0; font-size:18px;">â–¶ï¸ Test Workflow</h2>
                        <p style="margin:8px 0 0; color:#9ca3af; font-size:13px;">Fill in the input values to simulate the workflow</p>
                    </div>
                    <div style="padding:20px;">
                        <form id="test-workflow-form">
                            ${fields.map(f => `
                                <div style="margin-bottom:16px;">
                                    <label style="display:block; margin-bottom:6px; font-size:13px; color:#d1d5db;">
                                        ${f.name} ${f.required ? '<span style="color:#ef4444;">*</span>' : ''}
                                        <span style="color:#6b7280; font-size:11px;">(${f.type})</span>
                                    </label>
                                    ${f.type === 'textarea' ? `
                                        <textarea name="${f.name}" style="width:100%; padding:10px; background:#111827; border:1px solid #374151; border-radius:6px; color:white; min-height:80px;" 
                                                  placeholder="Enter ${f.name}..." ${f.required ? 'required' : ''}></textarea>
                                    ` : `
                                        <input type="${f.type === 'number' ? 'number' : f.type === 'email' ? 'email' : f.type === 'date' ? 'date' : 'text'}" 
                                               name="${f.name}" 
                                               style="width:100%; padding:10px; background:#111827; border:1px solid #374151; border-radius:6px; color:white;" 
                                               placeholder="Enter ${f.name}..." ${f.required ? 'required' : ''}>
                                    `}
                                </div>
                            `).join('')}
                        </form>
                    </div>
                    <div style="padding:20px; border-top:1px solid #374151; display:flex; gap:12px; justify-content:flex-end;">
                        <button onclick="closeTestModal()" style="padding:10px 20px; background:#374151; border:none; border-radius:6px; color:white; cursor:pointer;">
                            Cancel
                        </button>
                        <button onclick="runWorkflowTest()" style="padding:10px 20px; background:#22c55e; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:500;">
                            â–¶ï¸ Run Test
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function closeTestModal() {
            const modal = document.getElementById('test-workflow-modal');
            if (modal) modal.remove();
        }
        
        function runWorkflowTest() {
            const form = document.getElementById('test-workflow-form');
            const formData = new FormData(form);
            const inputData = {};
            
            for (let [key, value] of formData.entries()) {
                inputData[key] = value;
            }
            
            // Simulate workflow execution
            simulateWorkflow(inputData);
        }
        
        function simulateWorkflow(inputData) {
            closeTestModal();
            
            // Create results modal
            const modal = document.createElement('div');
            modal.id = 'test-results-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.8); display: flex; align-items: center; 
                justify-content: center; z-index: 10000;
            `;
            
            // Trace through the workflow
            const trace = [];
            let currentNode = state.nodes.find(n => n.type === 'trigger' || n.type === 'form');
            
            if (!currentNode) {
                currentNode = state.nodes.find(n => n.type === 'schedule' || n.type === 'webhook');
            }
            
            if (!currentNode) {
                alert('No start node found');
                return;
            }
            
            trace.push({ node: currentNode, status: 'completed', message: 'Workflow started with input data' });
            
            // Follow the workflow path
            let maxSteps = 20; // Prevent infinite loops
            while (currentNode && maxSteps > 0) {
                maxSteps--;
                
                // Find outgoing connection
                const connections = state.connections.filter(c => c.from === currentNode.id);
                
                if (connections.length === 0) {
                    // End node or no connections
                    if (currentNode.type === 'end') {
                        trace.push({ node: currentNode, status: 'completed', message: 'Workflow completed' });
                    }
                    break;
                }
                
                // Handle condition nodes
                if (currentNode.type === 'condition') {
                    const field = currentNode.config.field;
                    const operator = currentNode.config.operator;
                    const compareValue = currentNode.config.value;
                    const inputValue = inputData[field];
                    
                    let result = false;
                    switch (operator) {
                        case 'equals': result = inputValue == compareValue; break;
                        case 'not_equals': result = inputValue != compareValue; break;
                        case 'greater_than': result = parseFloat(inputValue) > parseFloat(compareValue); break;
                        case 'less_than': result = parseFloat(inputValue) < parseFloat(compareValue); break;
                        case 'contains': result = String(inputValue).includes(compareValue); break;
                        case 'is_empty': result = !inputValue || inputValue === ''; break;
                    }
                    
                    trace.push({ 
                        node: currentNode, 
                        status: 'completed', 
                        message: `Checked: ${field} (${inputValue}) ${operator} ${compareValue} â†’ ${result ? 'YES' : 'NO'}` 
                    });
                    
                    // Find the correct path (yes or no) - connections use .type not .output
                    const nextConnection = connections.find(c => c.type === (result ? 'yes' : 'no'));
                    if (nextConnection) {
                        currentNode = state.nodes.find(n => n.id === nextConnection.to);
                    } else {
                        // Fallback - take first connection
                        currentNode = state.nodes.find(n => n.id === connections[0].to);
                    }
                } else {
                    // Regular node - add to trace and follow first connection
                    let message = '';
                    switch (currentNode.type) {
                        case 'approval':
                            const ac = currentNode.config || {};
                            const aSrc = ac.assignee_source || (ac.approvers && ac.approvers.length ? 'platform_user' : '');
                            const aIds = ac.assignee_ids || ac.approvers || [];
                            message = aSrc ? `Approval requested from: ${aSrc.replace('platform_','')} (${aIds.length} selected)` : 'Approval requested (not configured)';
                            break;
                        case 'notification':
                            let template = currentNode.config.template || '';
                            Object.keys(inputData).forEach(key => {
                                template = template.replace(new RegExp('\\{\\{' + key + '\\}\\}', 'g'), inputData[key]);
                            });
                            message = `Notification sent: "${template.substring(0, 50)}..."`;
                            break;
                        case 'ai':
                            message = `AI processed with model: ${currentNode.config.model || 'gpt-4o'}`;
                            break;
                        case 'delay':
                            message = `Waiting ${currentNode.config.duration} ${currentNode.config.unit}`;
                            break;
                        default:
                            message = `Executed: ${currentNode.name}`;
                    }
                    
                    if (currentNode.type !== 'trigger' && currentNode.type !== 'form') {
                        trace.push({ node: currentNode, status: 'completed', message });
                    }
                    
                    currentNode = state.nodes.find(n => n.id === connections[0].to);
                }
            }
            
            // Display results
            modal.innerHTML = `
                <div style="background:#1f2937; border-radius:12px; width:600px; max-width:90%; max-height:80vh; overflow:auto;">
                    <div style="padding:20px; border-bottom:1px solid #374151;">
                        <h2 style="margin:0; font-size:18px;">ğŸ“Š Test Results</h2>
                    </div>
                    <div style="padding:20px;">
                        <div style="margin-bottom:16px; padding:12px; background:#111827; border-radius:8px;">
                            <div style="font-size:12px; color:#6b7280; margin-bottom:8px;">INPUT DATA:</div>
                            <pre style="margin:0; color:#a5b4fc; font-size:12px;">${JSON.stringify(inputData, null, 2)}</pre>
                        </div>
                        
                        <div style="font-size:12px; color:#6b7280; margin-bottom:12px;">EXECUTION TRACE:</div>
                        ${trace.map((t, i) => `
                            <div style="display:flex; gap:12px; margin-bottom:12px;">
                                <div style="width:24px; height:24px; border-radius:50%; background:${t.status === 'completed' ? '#22c55e' : '#ef4444'}; display:flex; align-items:center; justify-content:center; font-size:12px;">
                                    ${t.status === 'completed' ? 'âœ“' : 'âœ—'}
                                </div>
                                <div style="flex:1;">
                                    <div style="font-weight:500;">${t.node.name}</div>
                                    <div style="font-size:12px; color:#9ca3af;">${t.message}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <div style="padding:20px; border-top:1px solid #374151; display:flex; justify-content:flex-end;">
                        <button onclick="document.getElementById('test-results-modal').remove()" 
                                style="padding:10px 20px; background:#6366f1; border:none; border-radius:6px; color:white; cursor:pointer;">
                            Close
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function updateEmptyState() {
            const empty = document.getElementById('empty-state');
            empty.style.display = state.nodes.length === 0 ? 'block' : 'none';
        }
    </script>
</body>
</html>
