<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgentForge - Workflow Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Platform theme (same as main app â€“ from Settings) */
        :root, [data-theme="dark"] {
            --canvas-bg: #0f1419;
            --grid-color: rgba(255,255,255,0.03);
            --node-bg: #1a1f2e;
            --node-border: #2d3748;
            --connection-color: #6366f1;
            --trigger-color: #22c55e;
            --action-color: #3b82f6;
            --condition-color: #f59e0b;
            --approval-color: #ef4444;
            --loop-color: #8b5cf6;
            --end-color: #6b7280;
            --pb-bg: #0a0d12;
            --pb-toolbar: #111827;
            --pb-panel: #111827;
            --pb-text: #fff;
            --pb-muted: #9ca3af;
            --label-badge-bg: rgba(15, 23, 42, 0.92);
            --label-badge-border: rgba(148, 163, 184, 0.55);
            --label-badge-text: #f8fafc;
            --label-badge-shadow: 0 8px 22px rgba(15, 23, 42, 0.4);
            /* Toolbar buttons â€“ contrast-safe per theme */
            --tb-btn-secondary-bg: #1e293b;
            --tb-btn-secondary-text: #e2e8f0;
            --tb-btn-secondary-border: #334155;
            --tb-btn-secondary-hover: #334155;
            --tb-btn-primary-bg: #4f46e5;
            --tb-btn-primary-text: #ffffff;
            --tb-btn-primary-hover: #6366f1;
            --tb-btn-success-bg: #059669;
            --tb-btn-success-text: #ffffff;
            --tb-btn-success-hover: #10b981;
        }
        [data-theme="light"] {
            --canvas-bg: #f1f5f9;
            --grid-color: rgba(0,0,0,0.06);
            --node-bg: #ffffff;
            --node-border: #cbd5e1;
            --pb-bg: #f8fafc;
            --pb-toolbar: #ffffff;
            --pb-panel: #ffffff;
            --pb-text: #1e293b;
            --pb-muted: #64748b;
            --label-badge-bg: rgba(255, 255, 255, 0.96);
            --label-badge-border: rgba(100, 116, 139, 0.4);
            --label-badge-text: #0f172a;
            --label-badge-shadow: 0 8px 18px rgba(15, 23, 42, 0.12);
            --tb-btn-secondary-bg: #e2e8f0;
            --tb-btn-secondary-text: #1e293b;
            --tb-btn-secondary-border: #cbd5e1;
            --tb-btn-secondary-hover: #cbd5e1;
            --tb-btn-primary-bg: #4f46e5;
            --tb-btn-primary-text: #ffffff;
            --tb-btn-primary-hover: #6366f1;
            --tb-btn-success-bg: #059669;
            --tb-btn-success-text: #ffffff;
            --tb-btn-success-hover: #10b981;
        }
        [data-theme="ocean"] {
            --canvas-bg: #dbeafe;
            --grid-color: rgba(14,165,233,0.1);
            --node-bg: #ffffff;
            --node-border: #bae6fd;
            --pb-bg: #e8f4f8;
            --pb-toolbar: #ffffff;
            --pb-panel: #ffffff;
            --pb-text: #0c4a6e;
            --pb-muted: #0284c7;
            --label-badge-bg: rgba(12, 74, 110, 0.15);
            --label-badge-border: rgba(3, 105, 161, 0.35);
            --label-badge-text: #0c4a6e;
            --label-badge-shadow: 0 8px 18px rgba(12, 74, 110, 0.18);
            --tb-btn-secondary-bg: #0ea5e9;
            --tb-btn-secondary-text: #ffffff;
            --tb-btn-secondary-border: #0284c7;
            --tb-btn-secondary-hover: #0284c7;
            --tb-btn-primary-bg: #1d4ed8;
            --tb-btn-primary-text: #ffffff;
            --tb-btn-primary-hover: #2563eb;
            --tb-btn-success-bg: #047857;
            --tb-btn-success-text: #ffffff;
            --tb-btn-success-hover: #059669;
        }
        [data-theme="sunset"] {
            --canvas-bg: #16213e;
            --grid-color: rgba(251,191,36,0.08);
            --node-bg: #1f2937;
            --node-border: #4b5563;
            --pb-bg: #1a1a2e;
            --pb-toolbar: #16213e;
            --pb-panel: #1f2937;
            --pb-text: #fef3c7;
            --pb-muted: #f59e0b;
            --label-badge-bg: rgba(249, 115, 22, 0.18);
            --label-badge-border: rgba(249, 115, 22, 0.45);
            --label-badge-text: #fef3c7;
            --label-badge-shadow: 0 8px 22px rgba(249, 115, 22, 0.22);
            --tb-btn-secondary-bg: #78350f;
            --tb-btn-secondary-text: #fef3c7;
            --tb-btn-secondary-border: #92400e;
            --tb-btn-secondary-hover: #92400e;
            --tb-btn-primary-bg: #b45309;
            --tb-btn-primary-text: #ffffff;
            --tb-btn-primary-hover: #ea580c;
            --tb-btn-success-bg: #166534;
            --tb-btn-success-text: #ffffff;
            --tb-btn-success-hover: #15803d;
        }
        [data-theme="forest"] {
            --canvas-bg: #14291a;
            --grid-color: rgba(74,222,128,0.1);
            --node-bg: #1a3320;
            --node-border: #2d5a35;
            --pb-bg: #0f1f13;
            --pb-toolbar: #14291a;
            --pb-panel: #1a3320;
            --pb-text: #dcfce7;
            --pb-muted: #4ade80;
            --label-badge-bg: rgba(34, 197, 94, 0.16);
            --label-badge-border: rgba(74, 222, 128, 0.35);
            --label-badge-text: #dcfce7;
            --label-badge-shadow: 0 8px 20px rgba(34, 197, 94, 0.24);
            --tb-btn-secondary-bg: #14532d;
            --tb-btn-secondary-text: #dcfce7;
            --tb-btn-secondary-border: #166534;
            --tb-btn-secondary-hover: #166534;
            --tb-btn-primary-bg: #2563eb;
            --tb-btn-primary-text: #ffffff;
            --tb-btn-primary-hover: #3b82f6;
            --tb-btn-success-bg: #15803d;
            --tb-btn-success-text: #ffffff;
            --tb-btn-success-hover: #16a34a;
        }
        [data-theme="midnight"] {
            --canvas-bg: #0f172a;
            --grid-color: rgba(59,130,246,0.08);
            --node-bg: #1e293b;
            --node-border: #475569;
            --pb-bg: #020617;
            --pb-toolbar: #0f172a;
            --pb-panel: #1e293b;
            --pb-text: #f8fafc;
            --pb-muted: #94a3b8;
            --label-badge-bg: rgba(15, 23, 42, 0.92);
            --label-badge-border: rgba(96, 165, 250, 0.45);
            --label-badge-text: #f8fafc;
            --label-badge-shadow: 0 8px 24px rgba(37, 99, 235, 0.35);
            --tb-btn-secondary-bg: #1e3a5f;
            --tb-btn-secondary-text: #e0f2fe;
            --tb-btn-secondary-border: #2563eb;
            --tb-btn-secondary-hover: #1d4ed8;
            --tb-btn-primary-bg: #2563eb;
            --tb-btn-primary-text: #ffffff;
            --tb-btn-primary-hover: #3b82f6;
            --tb-btn-success-bg: #047857;
            --tb-btn-success-text: #ffffff;
            --tb-btn-success-hover: #059669;
        }
        
        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--pb-bg);
            color: var(--pb-text);
            overflow: hidden;
        }
        
        /* Canvas */
        #canvas-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 60px);
            overflow: hidden;
            background: var(--canvas-bg);
            background-image: 
                radial-gradient(circle, var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        #canvas {
            position: absolute;
            transform-origin: 0 0;
            min-width: 3000px;
            min-height: 2000px;
            z-index: 2;
        }
        
        /* Nodes â€“ BPMN-style: Ø§Ù„Ø´ÙƒÙ„ Ù†ÙØ³Ù‡ ÙÙ‚Ø·ØŒ Ø¨Ø¯ÙˆÙ† Ø¥Ø·Ø§Ø± Ø£Ùˆ Ø®Ù„ÙÙŠØ© Ø®Ø§Ø±Ø¬ÙŠØ© */
        .workflow-node {
            position: absolute;
            width: 200px;
            min-height: 56px;
            background: var(--node-bg);
            border: 2px solid var(--node-border);
            border-radius: 12px;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.2s, border-color 0.2s;
            z-index: 10;
            overflow: visible;
        }
        /* Start: Ø§Ù„Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„Ø®Ø¶Ø±Ø§Ø¡ ÙÙ‚Ø· â€“ Ù„Ø§ Ø¥Ø·Ø§Ø± Ø£Ø¨ÙŠØ¶ ÙˆÙ„Ø§ Ø®Ù„ÙÙŠØ© ÙˆØ±Ø§Ù‡Ø§ */
        .workflow-node.shape-start {
            width: 72px;
            padding: 0 0 28px;
            background: transparent !important;
            border: none !important;
            box-shadow: none;
        }
        .workflow-node.shape-start:hover,
        .workflow-node.shape-start.selected,
        .workflow-node.shape-start.multi-selected { box-shadow: none; }
        .workflow-node.shape-start .node-shape-wrap {
            width: 56px;
            height: 56px;
            margin: 0 auto 6px;
            border-radius: 50%;
        }
        .workflow-node.shape-start .node-body { display: none; }
        .workflow-node.shape-start .node-menu-btn { display: none; }
        /* End: Ø¯Ø§Ø¦Ø±Ø© 56Ã—56 Ø³Ù…ÙŠÙƒØ© â€“ Ù†ÙØ³ Ø­Ø¬Ù… Start */
        .workflow-node.shape-end {
            width: 72px;
            padding: 0 0 28px;
            background: transparent !important;
            border: none !important;
            box-shadow: none;
        }
        .workflow-node.shape-end:hover,
        .workflow-node.shape-end.selected,
        .workflow-node.shape-end.multi-selected { box-shadow: none; }
        .workflow-node.shape-end .node-shape-wrap {
            width: 56px;
            height: 56px;
            margin: 0 auto 6px;
            border-radius: 50%;
            border: 4px solid currentColor;
            box-sizing: border-box;
        }
        .workflow-node.shape-end .node-body { display: none; }
        .workflow-node.shape-end .node-menu-btn { display: none; }
        /* Condition: Ù…Ø§Ø³Ù‘Ø© 56Ã—56 â€“ Ù†ÙØ³ Ø¹Ø±Ø¶ Ø§Ù„Ø¹ÙÙ‚Ø¯ Ø§Ù„Ø£Ø®Ø±Ù‰ */
        .workflow-node.shape-gateway {
            width: 72px;
            padding: 0 0 28px;
            background: transparent !important;
            border: none !important;
            clip-path: none;
            box-shadow: none;
        }
        .workflow-node.shape-gateway:hover,
        .workflow-node.shape-gateway.selected,
        .workflow-node.shape-gateway.multi-selected { box-shadow: none; }
        .workflow-node.shape-gateway .node-shape-wrap {
            width: 56px;
            height: 56px;
            margin: 0 auto 6px;
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            -webkit-clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
        }
        .workflow-node.shape-gateway .node-body { display: none; }
        /* Task (Loop, Wait, Action, Tools, AI, Approval, Form, Notification): Ù…Ø±Ø¨Ø¹ Ø¯Ø§Ø¦Ø±ÙŠ Ø§Ù„Ø²ÙˆØ§ÙŠØ§ Ø¨Ø­Ø¬Ù… Start â€“ Ø¨Ø¯ÙˆÙ† Ù…Ø³ØªØ·ÙŠÙ„ ÙƒØ¨ÙŠØ± */
        .workflow-node.shape-task {
            width: 72px;
            padding: 0 0 28px;
            background: transparent !important;
            border: none !important;
            box-shadow: none;
        }
        .workflow-node.shape-task:hover,
        .workflow-node.shape-task.selected,
        .workflow-node.shape-task.multi-selected { box-shadow: none; }
        .workflow-node.shape-task .node-shape-wrap {
            width: 56px;
            height: 56px;
            margin: 0 auto 6px;
            border-radius: 12px;
            padding: 0;
        }
        .workflow-node.shape-task .node-body { display: none; }
        .workflow-node.shape-task .node-menu-btn {
            top: 2px;
            right: 2px;
            width: 20px;
            height: 20px;
            font-size: 12px;
        }
        
        .workflow-node:hover {
            border-color: #4f46e5;
            box-shadow: 0 0 20px rgba(79, 70, 229, 0.3);
        }
        .workflow-node.shape-start:hover,
        .workflow-node.shape-end:hover,
        .workflow-node.shape-gateway:hover,
        .workflow-node.shape-task:hover {
            border-color: transparent;
            box-shadow: none;
            outline: none;
        }
        
        .workflow-node.selected,
        .workflow-node.multi-selected {
            border-color: #6366f1;
            box-shadow: 0 0 30px rgba(99, 102, 241, 0.4);
        }
        .workflow-node.shape-start.selected,
        .workflow-node.shape-start.multi-selected,
        .workflow-node.shape-end.selected,
        .workflow-node.shape-end.multi-selected,
        .workflow-node.shape-gateway.selected,
        .workflow-node.shape-gateway.multi-selected,
        .workflow-node.shape-task.selected,
        .workflow-node.shape-task.multi-selected {
            border-color: transparent;
            box-shadow: none;
            outline: none;
        }
        
        .workflow-node.dragging {
            opacity: 0.8;
            z-index: 100;
        }
        
        /* Shape on top, label below (text under shape â€“ BPMN-style) */
        .node-shape-wrap {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .node-shape-wrap.trigger { background: linear-gradient(135deg, #22c55e, #16a34a); }
        .node-shape-wrap.action { background: linear-gradient(135deg, #3b82f6, #2563eb); }
        .node-shape-wrap.condition { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .node-shape-wrap.approval { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .node-shape-wrap.loop { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        .node-shape-wrap.delay { background: linear-gradient(135deg, #06b6d4, #0891b2); }
        .node-shape-wrap.end { background: linear-gradient(135deg, #6b7280, #4b5563); }
        .node-shape-wrap.tool { background: linear-gradient(135deg, #ec4899, #db2777); }
        .node-shape-wrap.ai { background: linear-gradient(135deg, #0ea5e9, #0284c7); }
        .node-shape-wrap.form { background: linear-gradient(135deg, #14b8a6, #0d9488); }
        .node-shape-wrap.notification { background: linear-gradient(135deg, #f97316, #ea580c); }
        
        /* Ø­Ø¬Ù… Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© Ù…ÙˆØ­Ù‘Ø¯ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ */
        .node-shape {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .node-shape svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
            color: rgba(255,255,255,0.95);
        }
        
        /* Ø§Ù„ØªØ³Ù…ÙŠØ© â€“ Ø³Ø·Ø± ÙˆØ§Ø­Ø¯ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ØŒ Ø§Ø³Ø­Ø¨Ù‡Ø§ Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù…ÙˆØ¶Ø¹ â€“ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· Ù…Ù† Ø§Ù„Ù€ toolbar */
        .node-label {
            font-weight: 600;
            font-size: var(--label-font-size, 11px);
            line-height: 1.2;
            white-space: nowrap;
            word-break: normal;
            width: max-content;
            min-width: min-content;
            max-width: none;
            overflow: visible;
            color: var(--label-badge-text);
            background: var(--label-badge-bg);
            border: 1px solid var(--label-badge-border);
            border-radius: 9999px;
            padding: 6px 14px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: var(--label-badge-shadow);
            backdrop-filter: blur(6px);
            text-align: center;
        }
        .workflow-node .node-label.node-label-draggable {
            cursor: grab;
            position: absolute;
            transform: none;
            z-index: 15;
        }
        .workflow-node .node-label.node-label-draggable:active {
            cursor: grabbing;
        }
        /* label selection Ù…Ù†ÙØµÙ„ Ø¹Ù† shape selection â€“ Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù€ label ÙÙ‚Ø· */
        .workflow-node.label-selected .node-label {
            border-color: var(--connection-color, #6366f1);
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4), var(--label-badge-shadow);
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .workflow-node.label-selected .node-label::after {
            content: '';
            position: absolute;
            inset: -4px;
            border-radius: 9999px;
            border: 2px solid var(--connection-color, #6366f1);
            pointer-events: none;
            opacity: 0.85;
            box-shadow: 0 0 8px rgba(99, 102, 241, 0.3);
        }
        .workflow-node.label-below .node-label { position: relative; margin-top: 0; }
        .workflow-node.label-custom .node-label {
            position: absolute;
            transform: none;
            white-space: nowrap;
            word-break: normal;
            width: max-content;
            min-width: min-content;
            max-width: none;
            overflow: visible;
        }
        .node-menu-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            background: rgba(255,255,255,0.15);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            z-index: 5;
        }
        .node-menu-btn:hover {
            background: rgba(255,255,255,0.25);
        }
        
        .node-body {
            padding: 10px 12px 12px;
            border-top: 1px solid var(--node-border);
        }
        
        .node-description {
            font-size: 12px;
            color: #9ca3af;
            margin-bottom: 12px;
        }
        
        .node-config-preview {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 11px;
            color: #d1d5db;
        }
        
        .node-config-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        
        .node-config-item:last-child { margin-bottom: 0; }
        
        .config-label {
            color: #6b7280;
            min-width: 60px;
        }
        
        .config-value {
            color: #a5b4fc;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Connection Ports â€“ ØªØ¸Ù‡Ø± Ø¹Ù†Ø¯ Ø§Ù„Ù€ hover Ø£Ùˆ Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø£Ùˆ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø±Ø¨Ø· (UX Ø£ÙØ¶Ù„) */
        .port {
            position: absolute;
            width: 18px;
            height: 18px;
            background: #374151;
            border: 2px solid #6b7280;
            border-radius: 50%;
            cursor: crosshair;
            transition: opacity 0.15s ease, transform 0.2s, background 0.15s, border-color 0.15s;
            z-index: 20;
            opacity: 0;
            pointer-events: none;
        }
        .workflow-node:hover .port,
        .workflow-node.selected .port,
        .workflow-node.multi-selected .port {
            opacity: 1;
            pointer-events: auto;
        }
        .connecting .workflow-node .port {
            opacity: 1;
            pointer-events: auto;
            width: 24px;
            height: 24px;
        }
        body.connecting {
            cursor: crosshair !important;
        }
        
        .port:hover {
            background: #6366f1;
            border-color: #818cf8;
        }
        .port.input:hover { transform: translate(-50%, -50%) scale(1.2); }
        .port.output:hover { transform: translate(-50%, 50%) scale(1.2); }
        .workflow-node.shape-start .port.output:hover,
        .workflow-node.shape-end .port.output:hover,
        .workflow-node.shape-gateway .port.input:hover,
        .workflow-node.shape-gateway .port.output-yes:hover,
        .workflow-node.shape-gateway .port.output-no:hover,
        .workflow-node.shape-task .port.input:hover { transform: translate(-50%, -50%) scale(1.2); }
        .port.output-yes:hover,
        .port.output-no:hover { transform: translate(-50%, 50%) scale(1.2); }
        .workflow-node.shape-task .port.output:hover { transform: translate(-50%, -50%) scale(1.2); }
        
        /* Fallback single port â€“ Ù‚Ø¨Ù„ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¬Ù‡Ø§Øª Ø§Ù„Ø£Ø±Ø¨Ø¹ Ø­ØªÙ‰ Ù„Ø§ ØªØªØ¬Ø§ÙˆØ²Ù‡Ø§ */
        .port.input { top: 0; left: 50%; transform: translate(-50%, -50%); }
        .port.output { top: 56px; left: 50%; transform: translate(-50%, -50%); }
        .port.output-yes { top: 56px; left: 30%; transform: translate(-50%, -50%); }
        .port.output-no { top: 56px; left: 70%; transform: translate(-50%, -50%); }
        /* 4-side ports: Ù…Ù†ÙØ° ÙˆØ§Ø­Ø¯ Ù„ÙƒÙ„ Ø¬Ù‡Ø© â€“ Ø£Ø¹Ù„Ù‰ØŒ ÙŠÙ…ÙŠÙ†ØŒ Ø£Ø³ÙÙ„ØŒ ÙŠØ³Ø§Ø± (ÙƒÙ„ Ø§Ù„Ù€ shapes) */
        .port.input-top, .port.input-bottom { left: 50%; transform: translate(-50%, -50%); }
        .port.input-right, .port.input-left { transform: translate(-50%, -50%); }
        .port.input-top { top: 0; }
        .port.input-bottom { top: 56px; }
        .port.input-right { left: 64px; top: 28px; }
        .port.input-left { left: 8px; top: 28px; }
        .port.output-top, .port.output-bottom { left: 50%; transform: translate(-50%, -50%); }
        .port.output-right, .port.output-left { transform: translate(-50%, -50%); }
        .port.output-top { top: 0; }
        .port.output-bottom { top: 56px; }
        .port.output-right { left: 64px; top: 28px; }
        .port.output-left { left: 8px; top: 28px; }
        .port.output-yes-top, .port.output-yes-bottom, .port.output-no-top, .port.output-no-bottom { left: 50%; transform: translate(-50%, -50%); }
        .port.output-yes-right, .port.output-yes-left, .port.output-no-right, .port.output-no-left { transform: translate(-50%, -50%); }
        .port.output-yes-top, .port.output-no-top { top: 0; }
        .port.output-yes-bottom, .port.output-no-bottom { top: 56px; }
        .port.output-yes-right, .port.output-no-right { left: 64px; top: 28px; }
        .port.output-yes-left, .port.output-no-left { left: 8px; top: 28px; }
        
        .port-label {
            position: absolute;
            font-size: 9px;
            color: #9ca3af;
            white-space: nowrap;
        }
        
        /* Yes/No ØªØ¸Ù‡Ø± Ø¹Ù„Ù‰ Ø®Ø· Ø§Ù„Ø±Ø¨Ø· Ù†ÙØ³Ù‡ ÙÙŠ renderConnections */
        
        /* Ø·Ø¨Ù‚Ø© Ø§Ù„Ø®Ø·ÙˆØ· ÙÙ‚Ø· â€“ Ø®Ù„Ù Ø§Ù„Ø¹ÙÙ‚Ø¯ ÙˆØ§Ù„ØªØ³Ù…ÙŠØ§Øª (Ù„Ø§ ØªÙ‚Ø·Ø¹ Ø§Ù„ÙƒÙ„Ø§Ù…) */
        #connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            min-width: 3000px;
            min-height: 2000px;
            width: 3000px;
            height: 2000px;
            overflow: visible;
            pointer-events: none;
            z-index: 1;
            transform-origin: 0 0;
        }
        /* Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ù‚Ø§Ø¨Ø¶ ÙˆØªØ³Ù…ÙŠØ§Øª Yes/No ÙÙ‚Ø· â€“ ÙÙˆÙ‚ Ø§Ù„Ø¹ÙÙ‚Ø¯ Ø¹Ø´Ø§Ù† ØªÙ‚Ø¨Ù„ Ù†Ù‚Ø±/Ø³Ø­Ø¨ */
        #connections-interactive-svg {
            position: absolute;
            top: 0;
            left: 0;
            min-width: 3000px;
            min-height: 2000px;
            width: 3000px;
            height: 2000px;
            overflow: visible;
            pointer-events: auto;
            z-index: 3;
            transform-origin: 0 0;
        }
        .connection-path {
            fill: none;
            stroke: var(--connection-color, #6366f1);
            stroke-width: 2;
            stroke-linecap: round;
            vector-effect: non-scaling-stroke;
            pointer-events: stroke;
            cursor: pointer;
        }
        
        .connection-path.yes { stroke: #22c55e; }
        .connection-path.no { stroke: #ef4444; }
        
        .connection-path:hover {
            stroke-width: 3;
            cursor: pointer;
        }
        .connection-preview-path {
            pointer-events: none;
            opacity: 0.8;
        }
        .connection-hit-path {
            fill: none;
            stroke: transparent;
            stroke-width: 20;
            vector-effect: non-scaling-stroke;
            cursor: pointer;
        }
        
        .connection-path.selected {
            stroke-width: 4;
            filter: drop-shadow(0 0 6px currentColor);
        }
        .connection-path.yes.selected { stroke-width: 4; filter: drop-shadow(0 0 8px rgba(34,197,94,0.6)); }
        .connection-path.no.selected { stroke-width: 4; filter: drop-shadow(0 0 8px rgba(239,68,68,0.6)); }
        
        /* Ù…Ù‚Ø§Ø¨Ø¶ Ø§Ù„Ø®Ø· â€“ ØªØ¸Ù‡Ø± Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø®Ø· (Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ© Ù…Ù†ÙØµÙ„Ø© Ø¹Ù† Ù…Ø³Ø§Ø± Ø§Ù„Ø±Ø³Ù…) */
        .connection-handles {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
        }
        .connection-handles.selected {
            opacity: 1;
            pointer-events: all;
        }
        .connection-hit-path:hover ~ .connection-handles {
            opacity: 1;
            pointer-events: all;
        }
        
        /* Draggable endpoint handles â€“ ØªØºÙŠÙŠØ± Ù†Ù‚Ø·Ø© Ø§Ù„Ø±Ø¨Ø· Ù…Ù† Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø£Ùˆ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© */
        .connection-end-handle,
        .connection-start-handle {
            fill: var(--connection-color, #6366f1);
            stroke: #fff;
            stroke-width: 2;
            cursor: grab;
            r: 10;
        }
        .connection-end-handle:hover,
        .connection-start-handle:hover { r: 14; }
        .connection-end-handle:active,
        .connection-start-handle:active { cursor: grabbing; }
        /* Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø­Ø¨: Ø£ÙŠ shape ØªØ­Øª Ø§Ù„Ù…Ø¤Ø´Ø± ÙŠØ¸Ù‡Ø± ÙƒÙ‡Ø¯Ù Ø±Ø¨Ø· */
        .workflow-node.connection-drop-target {
            box-shadow: 0 0 0 3px var(--connection-color, #6366f1);
            border-radius: 12px;
        }
        /* Ø§Ù„Ù…Ù†ÙØ° Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø³Ø­Ø¨ â€“ ÙŠØ¨Ø±Ø² Ø­ØªÙ‰ ØªØ¹Ø±Ù Ø£ÙŠ Ù†Ù‚Ø·Ø© Ø³ØªÙØ±Ø¨Ø· */
        .port.connection-target-port {
            opacity: 1 !important;
            background: #6366f1 !important;
            border-color: #818cf8 !important;
            box-shadow: 0 0 12px rgba(99, 102, 241, 0.6);
        }
        .port.input.connection-target-port,
        .port.input-top.connection-target-port,
        .port.input-right.connection-target-port,
        .port.input-bottom.connection-target-port,
        .port.input-left.connection-target-port { transform: translate(-50%, -50%) scale(1.3) !important; }
        .connection-path.yes + .connection-handles .connection-end-handle,
        .connection-path.yes + .connection-handles .connection-start-handle { fill: #22c55e; }
        .connection-path.no + .connection-handles .connection-end-handle,
        .connection-path.no + .connection-handles .connection-start-handle { fill: #ef4444; }
        /* Draggable bend point: Ø®Ø·ÙˆØ· Ù…Ø³ØªÙ‚ÙŠÙ…Ø© + ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø²Ø§ÙˆÙŠØ© */
        .connection-bend-handle {
            fill: var(--connection-color, #6366f1);
            stroke: #fff;
            stroke-width: 2;
            cursor: grab;
            r: 6;
            visibility: hidden;
        }
        .connection-handles.selected .connection-bend-handle { visibility: visible; }
        .connection-handles.yes .connection-bend-handle { fill: #22c55e; }
        .connection-handles.no .connection-bend-handle { fill: #ef4444; }
        .connection-bend-handle:hover { r: 8; }
        .connection-bend-handle:active { cursor: grabbing; }
        
        /* ØªØ³Ù…ÙŠØ© Yes/No Ø¨Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø®Ø· â€“ draggable Ù…Ø«Ù„ ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ù‚Ø¯ */
        .connection-label-badge {
            cursor: grab;
            pointer-events: all;
            filter: drop-shadow(var(--label-badge-shadow));
        }
        .connection-label-badge:active {
            cursor: grabbing;
        }
        .connection-label-badge rect {
            stroke-width: 1.5;
            vector-effect: non-scaling-stroke;
            fill: var(--label-badge-bg);
            stroke: var(--label-badge-border);
        }
        .connection-label-badge text {
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: middle;
            fill: var(--label-badge-text);
        }
        .connection-label-badge.yes rect { fill: rgba(240, 253, 244, 0.92); stroke: #22c55e; }
        .connection-label-badge.no rect { fill: rgba(254, 242, 242, 0.92); stroke: #ef4444; }
        .connection-label-badge.yes text { fill: #166534; }
        .connection-label-badge.no text { fill: #b91c1c; }
        .connection-label-badge.selected rect {
            stroke-width: 2.5;
            filter: drop-shadow(0 0 8px rgba(99, 102, 241, 0.5));
        }
        .connection-label-badge.selected.yes rect { stroke: #166534; filter: drop-shadow(0 0 8px rgba(34,197,94,0.5)); }
        .connection-label-badge.selected.no rect { stroke: #b91c1c; filter: drop-shadow(0 0 8px rgba(239,68,68,0.5)); }
        
        /* Toolbar */
        #top-toolbar {
            height: 60px;
            background: var(--pb-toolbar);
            border-bottom: 1px solid var(--node-border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 16px;
        }
        
        .toolbar-logo {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-right: 20px;
            border-right: 1px solid var(--node-border);
        }
        
        .toolbar-logo img {
            height: 32px;
        }
        
        .toolbar-title {
            font-weight: 600;
            font-size: 16px;
            color: var(--pb-text);
        }
        
        .workflow-name-input {
            background: transparent;
            border: 1px solid transparent;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 16px;
            font-weight: 600;
            color: var(--pb-text);
            min-width: 200px;
        }
        
        .workflow-name-input:hover {
            border-color: var(--node-border);
        }
        
        .workflow-name-input:focus {
            outline: none;
            border-color: var(--connection-color);
            background: rgba(99, 102, 241, 0.1);
        }
        
        .toolbar-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }
        .toolbar-actions .toolbar-label {
            font-size: 12px;
            color: var(--pb-text-muted, #9ca3af);
            margin-right: 4px;
        }
        .toolbar-actions .flow-btn.active {
            background: var(--tb-btn-primary-bg);
            color: var(--tb-btn-primary-text);
            border-color: var(--tb-btn-primary-bg);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        /* Toolbar buttons â€“ theme-aware contrast, consistent look */
        .toolbar-btn {
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid transparent;
            letter-spacing: 0.01em;
        }
        
        .toolbar-btn:active {
            transform: scale(0.98);
        }
        
        .btn-secondary {
            background: var(--tb-btn-secondary-bg);
            border-color: var(--tb-btn-secondary-border);
            color: var(--tb-btn-secondary-text);
        }
        
        .btn-secondary:hover {
            background: var(--tb-btn-secondary-hover);
            border-color: var(--tb-btn-secondary-hover);
        }
        
        .btn-primary {
            background: var(--tb-btn-primary-bg);
            border-color: var(--tb-btn-primary-bg);
            color: var(--tb-btn-primary-text);
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
        }
        
        .btn-primary:hover {
            background: var(--tb-btn-primary-hover);
            border-color: var(--tb-btn-primary-hover);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .btn-success {
            background: var(--tb-btn-success-bg);
            border-color: var(--tb-btn-success-bg);
            color: var(--tb-btn-success-text);
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
        }
        
        .btn-success:hover {
            background: var(--tb-btn-success-hover);
            border-color: var(--tb-btn-success-hover);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        /* Left Panel - Node Palette */
        #node-palette {
            position: absolute;
            left: 20px;
            top: 80px;
            width: 260px;
            background: var(--pb-panel);
            border: 1px solid var(--node-border);
            border-radius: 12px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
            z-index: 50;
        }
        
        .palette-section {
            padding: 16px;
            border-bottom: 1px solid var(--node-border);
        }
        
        .palette-section:last-child { border-bottom: none; }
        
        .palette-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--pb-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        
        .palette-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--node-bg);
            border: 1px solid var(--node-border);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: grab;
            transition: all 0.2s;
        }
        
        .palette-item:hover {
            border-color: var(--connection-color);
            background: rgba(99, 102, 241, 0.1);
            transform: translateX(4px);
        }
        
        .palette-item:active {
            cursor: grabbing;
        }
        
        .palette-icon {
            width: 40px;
            height: 40px;
            min-width: 40px;
            min-height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .palette-icon svg {
            width: 22px;
            height: 22px;
            fill: currentColor;
            color: rgba(255,255,255,0.95);
        }
        .palette-icon.trigger { background: linear-gradient(135deg, #22c55e, #16a34a); }
        .palette-icon.action { background: linear-gradient(135deg, #3b82f6, #2563eb); }
        .palette-icon.condition { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .palette-icon.approval { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .palette-icon.loop { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        .palette-icon.delay { background: linear-gradient(135deg, #06b6d4, #0891b2); }
        .palette-icon.end { background: linear-gradient(135deg, #6b7280, #4b5563); }
        .palette-icon.tool { background: linear-gradient(135deg, #ec4899, #db2777); }
        /* Ù†ÙØ³ Ø´ÙƒÙ„ Ø§Ù„Ù€ shape Ø¹Ù„Ù‰ Ø§Ù„Ù€ canvas: Ø¯Ø§Ø¦Ø±Ø©ØŒ Ù…Ø§Ø³Ù‘Ø©ØŒ Ø¯Ø§Ø¦Ø±Ø© Ø³Ù…ÙŠÙƒØ©ØŒ Ù…Ø³ØªØ·ÙŠÙ„ */
        .palette-icon.palette-shape-start { border-radius: 50%; }
        .palette-icon.palette-shape-end { border-radius: 50%; border: 3px solid currentColor; box-sizing: border-box; }
        .palette-icon.palette-shape-gateway { border-radius: 0; clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); -webkit-clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); }
        .palette-icon.palette-shape-task { border-radius: 8px; }
        
        .palette-info {
            flex: 1;
        }
        
        .palette-name {
            font-size: 13px;
            font-weight: 500;
            color: var(--pb-text);
        }
        
        .palette-desc {
            font-size: 11px;
            color: var(--pb-muted);
            margin-top: 2px;
        }
        
        /* Right Panel - Properties */
        #properties-panel {
            position: absolute;
            right: 20px;
            top: 80px;
            width: 320px;
            background: var(--pb-panel);
            border: 1px solid var(--node-border);
            border-radius: 12px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
            z-index: 50;
            display: none;
        }
        
        #properties-panel.active { display: block; }
        
        #approval-config-modal { display: none; align-items: center; justify-content: center; }
        #approval-config-modal.show { display: flex !important; }
        #approval-config-modal .hidden { display: none !important; }
        
        .properties-header {
            padding: 16px;
            border-bottom: 1px solid #1f2937;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .properties-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .properties-title {
            flex: 1;
        }
        
        .properties-title h3 {
            font-size: 15px;
            font-weight: 600;
            margin: 0;
        }
        
        .properties-title span {
            font-size: 11px;
            color: #6b7280;
        }
        
        .properties-close {
            width: 28px;
            height: 28px;
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            font-size: 18px;
        }
        
        .properties-close:hover { color: white; }
        
        .properties-body {
            padding: 16px;
        }
        
        .property-group {
            margin-bottom: 20px;
        }
        
        .property-label {
            font-size: 12px;
            font-weight: 500;
            color: #9ca3af;
            margin-bottom: 8px;
            display: block;
        }
        
        .property-input {
            width: 100%;
            padding: 10px 12px;
            background: #1a1f2e;
            border: 1px solid #2d3748;
            border-radius: 8px;
            color: white;
            font-size: 13px;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #6366f1;
        }
        
        .property-select {
            width: 100%;
            padding: 10px 12px;
            background: #1a1f2e;
            border: 1px solid #2d3748;
            border-radius: 8px;
            color: white;
            font-size: 13px;
            cursor: pointer;
        }
        
        .property-textarea {
            width: 100%;
            padding: 10px 12px;
            background: #1a1f2e;
            border: 1px solid #2d3748;
            border-radius: 8px;
            color: white;
            font-size: 13px;
            min-height: 80px;
            resize: vertical;
        }
        
        /* Tool Selector */
        .tool-selector {
            background: #1a1f2e;
            border: 1px solid #2d3748;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .tool-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .tool-option:hover {
            background: rgba(99, 102, 241, 0.1);
        }
        
        .tool-option.selected {
            background: rgba(99, 102, 241, 0.2);
            border-left: 3px solid #6366f1;
        }
        
        .tool-option-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #ec4899, #db2777);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tool-option-info {
            flex: 1;
        }
        
        .tool-option-name {
            font-size: 13px;
            font-weight: 500;
        }
        
        .tool-option-type {
            font-size: 11px;
            color: #6b7280;
        }
        
        /* Zoom Controls */
        #zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 4px;
            background: var(--pb-panel);
            border: 1px solid var(--node-border);
            border-radius: 8px;
            padding: 4px;
            z-index: 50;
        }
        
        .zoom-btn {
            width: 36px;
            height: 36px;
            background: none;
            border: none;
            color: var(--pb-muted);
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-btn:hover {
            background: var(--node-bg);
            color: var(--pb-text);
        }
        
        .zoom-level {
            padding: 0 12px;
            font-size: 12px;
            color: var(--pb-muted);
            display: flex;
            align-items: center;
        }
        
        /* Empty State */
        #empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #6b7280;
            z-index: 5;
        }
        
        .empty-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        .empty-title {
            font-size: 18px;
            font-weight: 600;
            color: #9ca3af;
            margin-bottom: 8px;
        }
        
        .empty-desc {
            font-size: 14px;
            max-width: 300px;
            line-height: 1.5;
        }
        
        /* Animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .connecting .port.output,
        .connecting .port.output-top,
        .connecting .port.output-right,
        .connecting .port.output-bottom,
        .connecting .port.output-left,
        .connecting .port.output-yes-top,
        .connecting .port.output-yes-right,
        .connecting .port.output-yes-bottom,
        .connecting .port.output-yes-left,
        .connecting .port.output-no-top,
        .connecting .port.output-no-right,
        .connecting .port.output-no-bottom,
        .connecting .port.output-no-left {
            animation: pulse 1s infinite;
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #374151;
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }
    </style>
</head>
<body>
    <!-- Top Toolbar -->
    <div id="top-toolbar">
        <div class="toolbar-logo">
            <img src="/AgentForge_Logo.png" alt="AgentForge" onerror="this.style.display='none'">
            <span class="toolbar-title">Workflow Builder</span>
        </div>
        
        <input type="text" id="workflow-name" class="workflow-name-input" value="My Workflow" placeholder="Workflow Name">
        
        <div class="toolbar-actions">
            <span class="toolbar-label">Flow:</span>
            <button type="button" class="toolbar-btn btn-secondary flow-btn" id="flow-vertical" title="Vertical: Ù…Ù† Ø£Ø¹Ù„Ù‰ Ù„Ø£Ø³ÙÙ„ (Top â†’ Bottom)" onclick="setFlowDirection('vertical')">
                <span>â†•</span> Vertical
            </button>
            <button type="button" class="toolbar-btn btn-secondary flow-btn" id="flow-horizontal" title="Horizontal: Ù…Ù† ÙŠØ³Ø§Ø± Ù„ÙŠÙ…ÙŠÙ† (Left â†’ Right)" onclick="setFlowDirection('horizontal')">
                <span>â†”</span> Horizontal
            </button>
            <button type="button" class="toolbar-btn btn-secondary" title="Arrange process in best alignment" onclick="alignProcess()">
                <span>âŠŸ</span> Align
            </button>
            <span class="toolbar-label" style="margin-left:8px;">Labels:</span>
            <button type="button" class="toolbar-btn btn-secondary" title="Smaller label font" onclick="setLabelFontSize(-1)">
                <span>Aâˆ’</span>
            </button>
            <button type="button" class="toolbar-btn btn-secondary" title="Larger label font" onclick="setLabelFontSize(1)">
                <span>A+</span>
            </button>
            <span id="label-font-size-display" style="font-size:11px;color:var(--pb-muted);min-width:2.5em;">11px</span>
            <button class="toolbar-btn btn-secondary" title="Undo (Ctrl+Z)" onclick="undoAction()">
                <span>â†¶</span> Undo
            </button>
            <button class="toolbar-btn btn-secondary" title="Redo (Ctrl+Shift+Z)" onclick="redoAction()">
                <span>â†·</span> Redo
            </button>
            <button class="toolbar-btn btn-secondary" onclick="testWorkflow()">
                <span>â–¶</span> Test
            </button>
            <button class="toolbar-btn btn-primary" onclick="saveWorkflow()">
                <span>ğŸ’¾</span> Save
            </button>
            <button class="toolbar-btn btn-success" onclick="publishWorkflow()">
                <span>ğŸš€</span> Publish
            </button>
        </div>
    </div>
    
    <!-- Canvas Container -->
    <div id="canvas-container">
        <div id="selection-box" style="display:none;position:absolute;border:2px dashed rgba(99,102,241,0.9);background:rgba(99,102,241,0.08);pointer-events:none;z-index:20;border-radius:4px;"></div>
        <!-- SVG for connection paths only (behind nodes) -->
        <svg id="connections-svg"></svg>
        <!-- SVG for handles + Yes/No labels only (on top, clickable) -->
        <svg id="connections-interactive-svg"></svg>
        <!-- Canvas for nodes -->
        <div id="canvas">
            <!-- Nodes will be added here -->
        </div>
        
        <!-- Empty State -->
        <div id="empty-state">
            <div class="empty-icon">ğŸ”„</div>
            <div class="empty-title">Start Building Your Workflow</div>
            <div class="empty-desc">Drag components from the left panel onto the canvas to create your automation flow</div>
        </div>
    </div>
    
    <!-- Node Palette (Left Panel) -->
    <div id="node-palette">
        <div class="palette-section">
            <div class="palette-title">Triggers</div>
            <div class="palette-item" draggable="true" data-type="trigger">
                <div class="palette-icon trigger">ğŸ¯</div>
                <div class="palette-info">
                    <div class="palette-name">Start Trigger</div>
                    <div class="palette-desc">When workflow begins</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="schedule">
                <div class="palette-icon trigger">â°</div>
                <div class="palette-info">
                    <div class="palette-name">Schedule</div>
                    <div class="palette-desc">Run on a schedule</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="webhook">
                <div class="palette-icon trigger">ğŸ”—</div>
                <div class="palette-info">
                    <div class="palette-name">Webhook</div>
                    <div class="palette-desc">Triggered by API call</div>
                </div>
            </div>
        </div>
        
        <div class="palette-section">
            <div class="palette-title">Logic</div>
            <div class="palette-item" draggable="true" data-type="condition">
                <div class="palette-icon condition">ğŸ”€</div>
                <div class="palette-info">
                    <div class="palette-name">Condition</div>
                    <div class="palette-desc">If/else branching</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="loop">
                <div class="palette-icon loop">ğŸ”</div>
                <div class="palette-info">
                    <div class="palette-name">Loop</div>
                    <div class="palette-desc">Repeat for each item</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="delay">
                <div class="palette-icon delay">â³</div>
                <div class="palette-info">
                    <div class="palette-name">Delay</div>
                    <div class="palette-desc">Wait before continuing</div>
                </div>
            </div>
        </div>
        
        <div class="palette-section">
            <div class="palette-title">Actions</div>
            <div class="palette-item" draggable="true" data-type="action">
                <div class="palette-icon action">âš¡</div>
                <div class="palette-info">
                    <div class="palette-name">Action</div>
                    <div class="palette-desc">Perform an operation</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="tool">
                <div class="palette-icon tool">ğŸ”§</div>
                <div class="palette-info">
                    <div class="palette-name">Use Tool</div>
                    <div class="palette-desc">Call a platform tool</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="ai">
                <div class="palette-icon action">ğŸ¤–</div>
                <div class="palette-info">
                    <div class="palette-name">AI Action</div>
                    <div class="palette-desc">AI-powered task</div>
                </div>
            </div>
        </div>
        
        <div class="palette-section">
            <div class="palette-title">Human Tasks</div>
            <div class="palette-item" draggable="true" data-type="approval">
                <div class="palette-icon approval">âœ…</div>
                <div class="palette-info">
                    <div class="palette-name">Approval</div>
                    <div class="palette-desc">Wait for approval</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="form">
                <div class="palette-icon approval">ğŸ“</div>
                <div class="palette-info">
                    <div class="palette-name">Form Input</div>
                    <div class="palette-desc">Collect user input</div>
                </div>
            </div>
            <div class="palette-item" draggable="true" data-type="notification">
                <div class="palette-icon action">ğŸ“§</div>
                <div class="palette-info">
                    <div class="palette-name">Notification</div>
                    <div class="palette-desc">Send a message</div>
                </div>
            </div>
        </div>
        
        <div class="palette-section">
            <div class="palette-title">Flow Control</div>
            <div class="palette-item" draggable="true" data-type="end">
                <div class="palette-icon end">ğŸ</div>
                <div class="palette-info">
                    <div class="palette-name">End</div>
                    <div class="palette-desc">Complete workflow</div>
                </div>
            </div>
        </div>
        
        <div class="palette-section" id="tools-section">
            <div class="palette-title">Your Tools</div>
            <div id="platform-tools-list">
                <!-- Loaded dynamically -->
                <div style="font-size: 11px; color: #6b7280; padding: 8px;">Loading tools...</div>
            </div>
        </div>
    </div>
    
    <!-- Properties Panel (Right) -->
    <div id="properties-panel">
        <div class="properties-header">
            <div class="properties-icon action" id="prop-icon">âš¡</div>
            <div class="properties-title">
                <h3 id="prop-title">Node Properties</h3>
                <span id="prop-type">Action</span>
            </div>
            <button class="properties-close" onclick="closeProperties()">Ã—</button>
        </div>
        <div class="properties-body" id="prop-body">
            <!-- Dynamic content -->
        </div>
    </div>
    
    <!-- Approval step config modal (Approvers from Platform User / Role / Group / Tool) -->
    <div id="approval-config-modal" style="position:fixed;inset:0;background:rgba(0,0,0,0.6);align-items:center;justify-content:center;z-index:100;" onclick="if(event.target===this)closeApprovalConfigModal()">
        <div class="card rounded-xl w-full max-w-lg mx-4 p-6" style="background:#1f2937;border-radius:12px;" onclick="event.stopPropagation()">
            <h3 class="text-lg font-bold mb-4">âœ… Approval Step â€“ Approvers</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm text-gray-400 mb-1">Approvers from</label>
                    <select id="approval-config-source" onchange="onApprovalConfigSourceChange()" class="property-select w-full rounded-lg px-4 py-2" style="width:100%;background:#111827;color:#fff;border:1px solid #374151;">
                        <option value="platform_user">Platform User</option>
                        <option value="platform_role">Platform Role</option>
                        <option value="platform_group">Platform Group</option>
                        <option value="tool">Tool</option>
                    </select>
                </div>
                <div id="approval-config-platform-user-wrap" class="hidden">
                    <label class="block text-sm text-gray-400 mb-1">Select users</label>
                    <select id="approval-config-user-list" multiple class="property-input w-full rounded-lg px-4 py-2" style="height:120px;width:100%;background:#111827;color:#fff;"></select>
                </div>
                <div id="approval-config-platform-role-wrap" class="hidden">
                    <label class="block text-sm text-gray-400 mb-1">Select roles</label>
                    <select id="approval-config-role-list" multiple class="property-input w-full rounded-lg px-4 py-2" style="height:120px;width:100%;background:#111827;color:#fff;"></select>
                </div>
                <div id="approval-config-platform-group-wrap" class="hidden">
                    <label class="block text-sm text-gray-400 mb-1">Select groups</label>
                    <select id="approval-config-group-list" multiple class="property-input w-full rounded-lg px-4 py-2" style="height:120px;width:100%;background:#111827;color:#fff;"></select>
                </div>
                <div id="approval-config-tool-wrap" class="hidden">
                    <label class="block text-sm text-gray-400 mb-1">Select tool</label>
                    <select id="approval-config-tool" class="property-select w-full rounded-lg px-4 py-2" style="width:100%;background:#111827;color:#fff;">
                        <option value="">â€” None â€”</option>
                    </select>
                </div>
            </div>
            <div class="flex gap-3 mt-6">
                <button type="button" onclick="closeApprovalConfigModal()" class="flex-1 py-2 rounded-lg" style="background:#374151;color:#fff;">Cancel</button>
                <button type="button" onclick="saveApprovalConfig()" class="flex-1 py-2 rounded-lg" style="background:#6366f1;color:#fff;">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Zoom Controls -->
    <div id="zoom-controls">
        <button class="zoom-btn" onclick="zoomOut()">âˆ’</button>
        <span class="zoom-level" id="zoom-level">100%</span>
        <button class="zoom-btn" onclick="zoomIn()">+</button>
        <button class="zoom-btn" onclick="zoomReset()" title="Reset zoom">âŠ™</button>
        <button class="zoom-btn" onclick="zoomFit()" title="Fit all steps in view">âŠ¡</button>
    </div>
    
    <script>
        // ===== STATE =====
        const state = {
            nodes: [],
            connections: [],
            selectedNode: null,
            selectedLabelNodeId: null,
            selectedNodeIds: [],
            zoom: 1,
            panX: 0,
            panY: 0,
            isDragging: false,
            isConnecting: false,
            connectionStart: null,
            draggingEdgeEnd: null,
            draggingEdgeStart: null,
            draggingBendPoint: null,
            justDropped: false,
            consumeNextClick: false,
            flowDirection: 'vertical',
            draggingLabel: null,
            draggingConnectionLabel: null,
            boxSelect: null,
            justBoxSelected: false,
            labelFontSize: Math.min(24, Math.max(9, parseInt(localStorage.getItem('pb-label-font-size'), 10) || 11)),
            tools: [],
            agentId: null,
            undoStack: [],
            redoStack: [],
            connectionHoverNode: null,
            connectionHoverPort: null,
            connectionHoverPoint: null,
            connectionCompleted: false
        };
        
        // Node ID counter
        let nodeIdCounter = 1;
        
        function escapeHtml(s) {
            if (s == null) return '';
            const div = document.createElement('div');
            div.textContent = String(s);
            return div.innerHTML;
        }
        
        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', () => {
            loadPlatformTheme();
            initCanvas();
            initPalette();
            initPaletteShapes();
            loadTools();
            loadWorkflowFromUrl();
            updateFlowButtons();
            applyLabelFontSize();
            updateLabelFontSizeDisplay(state.labelFontSize);
        });
        
        function setLabelFontSize(delta) {
            const clamp = (v) => Math.min(24, Math.max(9, v));
            const nodeForLabel = state.selectedNode || (state.selectedLabelNodeId ? state.nodes.find(n => n.id === state.selectedLabelNodeId) : null);
            if (nodeForLabel) {
                const node = nodeForLabel;
                const current = node.labelFontSize != null ? node.labelFontSize : state.labelFontSize;
                node.labelFontSize = clamp(current + delta);
                updateLabelFontSizeDisplay(node.labelFontSize);
                refreshNode(node);
                saveToUndo();
                return;
            }
            if (stateSelectedConnIndex !== null && state.connections[stateSelectedConnIndex] && (state.connections[stateSelectedConnIndex].type === 'yes' || state.connections[stateSelectedConnIndex].type === 'no')) {
                const conn = state.connections[stateSelectedConnIndex];
                const current = conn.labelFontSize != null ? conn.labelFontSize : state.labelFontSize;
                conn.labelFontSize = clamp(current + delta);
                updateLabelFontSizeDisplay(conn.labelFontSize);
                renderConnections();
                saveToUndo();
                return;
            }
            state.labelFontSize = clamp(state.labelFontSize + delta);
            localStorage.setItem('pb-label-font-size', String(state.labelFontSize));
            applyLabelFontSize();
            updateLabelFontSizeDisplay(state.labelFontSize);
        }
        function updateLabelFontSizeDisplay(px) {
            const el = document.getElementById('label-font-size-display');
            if (el) el.textContent = px + 'px';
        }
        /* ØªØ·Ø¨ÙŠÙ‚ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¹Ù„Ù‰ ÙƒÙ„ Ø§Ù„ØªØ³Ù…ÙŠØ§Øª (Ø¹Ù†Ø¯ Ø¹Ø¯Ù… ØªØ­Ø¯ÙŠØ¯ Ø¹Ù‚Ø¯Ø©/Ø±Ø¨Ø·) */
        function applyLabelFontSize() {
            const container = document.getElementById('canvas-container');
            if (container) container.style.setProperty('--label-font-size', state.labelFontSize + 'px');
            state.nodes.forEach(n => {
                const nodeEl = document.getElementById(n.id);
                if (!nodeEl) {
                    renderNode(n);
                    return;
                }
                const labelEl = nodeEl.querySelector('.node-label');
                if (labelEl) {
                    const fontSize = n.labelFontSize != null ? n.labelFontSize : state.labelFontSize;
                    labelEl.style.fontSize = fontSize + 'px';
                }
            });
            renderConnections();
        }
        
        function setFlowDirection(dir) {
            state.flowDirection = dir;
            updateFlowButtons();
            applyAutoLayout(dir);
            renderConnections();
        }
        
        function applyAutoLayout(direction) {
            if (state.nodes.length === 0) return;
            // Vertical (â†•) = ØªØ¯ÙÙ‚ Ù…Ù† Ø£Ø¹Ù„Ù‰ Ù„Ø£Ø³ÙÙ„: Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ÙŠØ²ÙŠØ¯ Ù…Ø¹ yØŒ ÙˆØ§Ù„Ø¹Ù‚Ø¯ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø¬Ù†Ø¨ Ø¨Ø¹Ø¶ (x ÙŠØªØºÙŠØ±)
            // Horizontal (â†”) = ØªØ¯ÙÙ‚ Ù…Ù† ÙŠØ³Ø§Ø± Ù„ÙŠÙ…ÙŠÙ†: Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ÙŠØ²ÙŠØ¯ Ù…Ø¹ xØŒ ÙˆØ§Ù„Ø¹Ù‚Ø¯ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ÙÙˆÙ‚ Ø¨Ø¹Ø¶ (y ÙŠØªØºÙŠØ±)
            const NODE_W = 72, NODE_H = 90, GAP_X = 100, GAP_Y = 80;
            const nodeIds = new Set(state.nodes.map(n => n.id));
            const incoming = {};
            const outgoing = {};
            state.nodes.forEach(n => { incoming[n.id] = []; outgoing[n.id] = []; });
            state.connections.forEach(c => {
                if (nodeIds.has(c.from) && nodeIds.has(c.to)) {
                    outgoing[c.from].push(c.to);
                    incoming[c.to].push(c.from);
                }
            });
            const startNodes = state.nodes.filter(n => incoming[n.id].length === 0);
            if (startNodes.length === 0) startNodes.push(state.nodes[0]);
            const levels = {};
            const queue = startNodes.map(n => ({ id: n.id, level: 0 }));
            queue.forEach(({ id, level }) => { levels[id] = Math.max(levels[id] || 0, level); });
            let i = 0;
            while (i < queue.length) {
                const { id, level } = queue[i++];
                outgoing[id].forEach(toId => {
                    const next = level + 1;
                    if (next > (levels[toId] || 0)) {
                        levels[toId] = next;
                        queue.push({ id: toId, level: next });
                    }
                });
            }
            state.nodes.forEach(n => { if (levels[n.id] === undefined) levels[n.id] = 0; });
            const byLevel = {};
            state.nodes.forEach(n => {
                const L = levels[n.id];
                if (!byLevel[L]) byLevel[L] = [];
                byLevel[L].push(n.id);
            });
            const maxLevel = Math.max(...Object.keys(byLevel).map(Number));
            const baseX = 400, baseY = 80;
            for (let L = 0; L <= maxLevel; L++) {
                const ids = byLevel[L] || [];
                const count = ids.length;
                const totalW = count * NODE_W + Math.max(0, count - 1) * GAP_X;
                const totalH = count * NODE_H + Math.max(0, count - 1) * GAP_Y;
                const startX = baseX - (totalW - NODE_W) / 2;
                const startY = baseY - (totalH - NODE_H) / 2;
                ids.forEach((id, idx) => {
                    const node = state.nodes.find(n => n.id === id);
                    if (!node) return;
                    if (direction === 'vertical') {
                        // Vertical: Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª ØµÙÙˆÙ (y ÙŠØ²ÙŠØ¯ Ù…Ø¹ Ø§Ù„Ù…Ø³ØªÙˆÙ‰)ØŒ Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ = Ù†ÙØ³ Ø§Ù„ØµÙ (x ÙŠØ®ØªÙ„Ù)
                        node.x = Math.round((startX + idx * (NODE_W + GAP_X)) / 20) * 20;
                        node.y = Math.round((baseY + L * (NODE_H + GAP_Y)) / 20) * 20;
                    } else {
                        // Horizontal: Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø£Ø¹Ù…Ø¯Ø© (x ÙŠØ²ÙŠØ¯ Ù…Ø¹ Ø§Ù„Ù…Ø³ØªÙˆÙ‰)ØŒ Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ = Ù†ÙØ³ Ø§Ù„Ø¹Ù…ÙˆØ¯ (y ÙŠØ®ØªÙ„Ù)
                        node.x = Math.round((baseX + L * (NODE_W + GAP_X)) / 20) * 20;
                        node.y = Math.round((startY + idx * (NODE_H + GAP_Y)) / 20) * 20;
                    }
                });
            }
            // ØªÙˆØ³ÙŠØ· Ø§Ù„Ù€ process ÙÙŠ Ø§Ù„Ø´Ø§Ø´Ø© Ø­Ø³Ø¨ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ (vertical/horizontal)
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.nodes.forEach(n => {
                minX = Math.min(minX, n.x);
                minY = Math.min(minY, n.y);
                maxX = Math.max(maxX, n.x + NODE_W);
                maxY = Math.max(maxY, n.y + NODE_H);
            });
            const centerX = (minX + maxX) / 2, centerY = (minY + maxY) / 2;
            const container = document.getElementById('canvas-container');
            if (container) {
                state.panX = container.clientWidth / 2 - centerX * state.zoom;
                state.panY = container.clientHeight / 2 - centerY * state.zoom;
            }
            /* Ø¥Ø¹Ø§Ø¯Ø© ØªÙ…ÙˆØ¶Ø¹ ØªØ³Ù…ÙŠØ§Øª Yes/No Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø·ÙˆØ· Ø¨Ø¹Ø¯ ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¹Ù‚Ø¯ */
            state.connections.forEach(c => {
                if (c.type === 'yes' || c.type === 'no') delete c.labelOffset;
            });
            saveToUndo();
            document.getElementById('canvas').innerHTML = '';
            state.nodes.forEach(n => renderNode(n));
            updateConnectionsToClosestPorts();
            renderConnections();
            updateEmptyState();
            updateCanvasTransform();
        }
        
        function updateConnectionsToClosestPorts() {
            state.connections.forEach(conn => {
                const fromNode = document.getElementById(conn.from);
                const toNode = document.getElementById(conn.to);
                if (!fromNode || !toNode) return;
                const outKind = conn.type === 'yes' ? 'output-yes' : conn.type === 'no' ? 'output-no' : 'output';
                const pair = getClosestPortPair(fromNode, toNode, outKind);
                conn.fromPort = pair.fromSide;
                conn.toPort = pair.toSide;
            });
        }
        
        function alignProcess() {
            applyAutoLayout(state.flowDirection);
        }
        
        function updateFlowButtons() {
            const v = document.getElementById('flow-vertical');
            const h = document.getElementById('flow-horizontal');
            if (v) v.classList.toggle('active', state.flowDirection === 'vertical');
            if (h) h.classList.toggle('active', state.flowDirection === 'horizontal');
        }
        
        function initPaletteShapes() {
            document.querySelectorAll('.palette-item[data-type]').forEach(item => {
                const type = item.dataset.type;
                const iconEl = item.querySelector('.palette-icon');
                if (!iconEl) return;
                const shapeClass = getShapeClass(type);
                iconEl.innerHTML = getTypeSvgIcon(type);
                iconEl.classList.add('palette-shape-' + shapeClass.replace('shape-', ''));
            });
        }
        
        function loadPlatformTheme() {
            const theme = localStorage.getItem('agentforge-theme') || 'dark';
            if (theme !== 'dark') {
                document.documentElement.setAttribute('data-theme', theme);
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
        }
        
        function initCanvas() {
            const container = document.getElementById('canvas-container');
            const canvas = document.getElementById('canvas');
            const connectionsInteractiveSvg = document.getElementById('connections-interactive-svg');
            
            /* ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„ÙØ§Ø±ØºØ© ÙÙŠ Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ù‚Ø§Ø¨Ø¶/Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ù„Ù„Ù€ canvas Ø¹Ø´Ø§Ù† Ø§Ù„Ø¹ÙÙ‚Ø¯ ØªØ³ØªÙ‚Ø¨Ù„ (Ø³Ø­Ø¨ØŒ ØªØ­Ø¯ÙŠØ¯) */
            function forwardSvgPointerToCanvas(e) {
                const t = e.target;
                if (t !== connectionsInteractiveSvg && t && (!t.nodeName || t.nodeName.toLowerCase() !== 'svg')) return;
                const prev = connectionsInteractiveSvg.style.pointerEvents;
                connectionsInteractiveSvg.style.pointerEvents = 'none';
                const under = document.elementFromPoint(e.clientX, e.clientY);
                connectionsInteractiveSvg.style.pointerEvents = prev;
                if (under && (under === canvas || canvas.contains(under))) {
                    const ev = new MouseEvent(e.type, { bubbles: true, cancelable: true, clientX: e.clientX, clientY: e.clientY, button: e.button, buttons: e.buttons, relatedTarget: e.relatedTarget });
                    under.dispatchEvent(ev);
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
            if (connectionsInteractiveSvg) {
                connectionsInteractiveSvg.addEventListener('mousedown', forwardSvgPointerToCanvas);
                connectionsInteractiveSvg.addEventListener('mouseup', forwardSvgPointerToCanvas);
                connectionsInteractiveSvg.addEventListener('click', forwardSvgPointerToCanvas);
            }
            
            // Pan (middle mouse) and box selection (left drag on empty area)
            let isPanning = false;
            let startX, startY;
            
            /** BPMN-style: box selection ÙÙ‚Ø· Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„ÙØ§Ø±ØºØ© ÙØ¹Ù„ÙŠØ§Ù‹ â€“ Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ Ø§Ù„Ø¹ÙÙ‚Ø¯ ÙˆØ§Ù„Ù…Ù†Ø§ÙØ° ÙˆØ®Ø·ÙˆØ· Ø§Ù„Ø±Ø¨Ø· */
            function isEmptyArea(e) {
                if (state.isConnecting || state.connectionPreview) return false;
                const t = e.target;
                if (t !== container && t.id !== 'canvas' && t !== connectionsInteractiveSvg) return false;
                if (t.closest && (t.closest('.connection-hit-path') || t.closest('.connection-handles') || t.closest('.connection-label-badge'))) return false;
                const prev = connectionsInteractiveSvg ? connectionsInteractiveSvg.style.pointerEvents : '';
                if (connectionsInteractiveSvg) connectionsInteractiveSvg.style.pointerEvents = 'none';
                const under = document.elementFromPoint(e.clientX, e.clientY);
                if (connectionsInteractiveSvg) connectionsInteractiveSvg.style.pointerEvents = prev;
                if (under && under.closest && under.closest('.workflow-node')) return false;
                if (under && under.closest && under.closest('.port')) return false;
                return true;
            }
            
            container.addEventListener('mousedown', (e) => {
                if (e.button === 1) {
                    isPanning = true;
                    startX = e.clientX - state.panX;
                    startY = e.clientY - state.panY;
                    container.style.cursor = 'grabbing';
                } else if (e.button === 0 && isEmptyArea(e)) {
                    state.boxSelect = { startClientX: e.clientX, startClientY: e.clientY, addToSelection: e.ctrlKey || e.metaKey };
                    container.style.cursor = 'crosshair';
                    const box = document.getElementById('selection-box');
                    if (box) {
                        const r = container.getBoundingClientRect();
                        box.style.left = (e.clientX - r.left) + 'px';
                        box.style.top = (e.clientY - r.top) + 'px';
                        box.style.width = '0';
                        box.style.height = '0';
                        box.style.display = 'block';
                    }
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    state.panX = e.clientX - startX;
                    state.panY = e.clientY - startY;
                    updateCanvasTransform();
                } else if (state.boxSelect) {
                    const box = document.getElementById('selection-box');
                    if (!box) return;
                    const r = container.getBoundingClientRect();
                    const x1 = Math.min(state.boxSelect.startClientX, e.clientX);
                    const y1 = Math.min(state.boxSelect.startClientY, e.clientY);
                    const x2 = Math.max(state.boxSelect.startClientX, e.clientX);
                    const y2 = Math.max(state.boxSelect.startClientY, e.clientY);
                    box.style.left = (x1 - r.left) + 'px';
                    box.style.top = (y1 - r.top) + 'px';
                    box.style.width = (x2 - x1) + 'px';
                    box.style.height = (y2 - y1) + 'px';
                }
            });
            
            document.addEventListener('mouseup', (e) => {
                if (e.button === 1) {
                    isPanning = false;
                    container.style.cursor = '';
                } else if (e.button === 0 && state.boxSelect) {
                    container.style.cursor = '';
                    const box = document.getElementById('selection-box');
                    if (box) box.style.display = 'none';
                    const x1 = Math.min(state.boxSelect.startClientX, e.clientX);
                    const y1 = Math.min(state.boxSelect.startClientY, e.clientY);
                    const x2 = Math.max(state.boxSelect.startClientX, e.clientX);
                    const y2 = Math.max(state.boxSelect.startClientY, e.clientY);
                    if (x2 - x1 > 4 || y2 - y1 > 4) {
                        const r = container.getBoundingClientRect();
                        const c1 = clientToCanvas(x1, y1);
                        const c2 = clientToCanvas(x2, y2);
                        const minX = Math.min(c1.x, c2.x), maxX = Math.max(c1.x, c2.x);
                        const minY = Math.min(c1.y, c2.y), maxY = Math.max(c1.y, c2.y);
                        const NODE_W = 72, NODE_H = 90;
                        const selected = state.nodes.filter(n => {
                            const nR = n.x + NODE_W;
                            const nB = n.y + NODE_H;
                            return n.x < maxX && nR > minX && n.y < maxY && nB > minY;
                        });
                        if (selected.length > 0) {
                            state.justBoxSelected = true;
                            setTimeout(() => { state.justBoxSelected = false; }, 0);
                            const addTo = state.boxSelect.addToSelection;
                            const newIds = selected.map(n => n.id);
                            if (addTo) {
                                const cur = new Set(state.selectedNodeIds.length ? state.selectedNodeIds : (state.selectedNode ? [state.selectedNode.id] : state.selectedLabelNodeId ? [state.selectedLabelNodeId] : []));
                                newIds.forEach(id => cur.add(id));
                                state.selectedNodeIds = Array.from(cur);
                            } else {
                                state.selectedNodeIds = newIds;
                            }
                            state.selectedNode = state.selectedNodeIds.length === 1 ? state.nodes.find(n => n.id === state.selectedNodeIds[0]) : null;
                            state.selectedLabelNodeId = null;
                            stateSelectedConnIndex = null;
                            updateSelectionUI();
                            if (state.selectedNodeIds.length === 1) showProperties(state.nodes.find(n => n.id === state.selectedNodeIds[0]));
                            else closeProperties();
                        }
                    }
                    state.boxSelect = null;
                }
            });
            
            // Zoom with scroll
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.min(Math.max(state.zoom * delta, 0.25), 2);
                state.zoom = newZoom;
                updateCanvasTransform();
                document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%';
            });
            
            // Ù…Ù†Ø¹ Ø§Ù„Ù†Ù‚Ø±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ Ø¨Ø¹Ø¯ Ø§Ù„Ù€ drop ÙÙ‚Ø· (Ø³Ø¨Ø¨ Ø¸Ù‡ÙˆØ± properties Ø§Ù„Ù€ Start)
            document.addEventListener('click', (e) => {
                if (state.consumeNextClick) {
                    e.stopPropagation();
                    e.preventDefault();
                    state.consumeNextClick = false;
                }
            }, true);
            
            // Click on canvas to deselect
            container.addEventListener('click', (e) => {
                if (state.justDropped || state.justBoxSelected) return;
                if (e.target === container || e.target.id === 'canvas' || e.target === connectionsInteractiveSvg) {
                    deselectAll();
                    deselectConnection();
                }
            });
            
            // Keyboard: Undo, Redo, Delete, Select All
            document.addEventListener('keydown', (e) => {
                if (e.target.closest('input') || e.target.closest('textarea') || e.target.closest('select')) return;
                const ctrl = e.ctrlKey || e.metaKey;
                if (ctrl && e.key === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) redoAction();
                    else undoAction();
                    return;
                }
                if (ctrl && e.key === 'y') {
                    e.preventDefault();
                    redoAction();
                    return;
                }
                if (ctrl && e.key === 'a') {
                    e.preventDefault();
                    selectAllNodes();
                    return;
                }
                if (e.key !== 'Delete' && e.key !== 'Backspace') return;
                e.preventDefault();
                if (stateSelectedConnIndex !== null) {
                    deleteConnection(stateSelectedConnIndex);
                } else {
                    deleteSelectedNodes();
                }
            });
        }
        
        function updateCanvasTransform() {
            const canvas = document.getElementById('canvas');
            const svg = document.getElementById('connections-svg');
            const svgInteractive = document.getElementById('connections-interactive-svg');
            canvas.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
            svg.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
            if (svgInteractive) svgInteractive.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
            renderConnections();
        }
        
        function initPalette() {
            const items = document.querySelectorAll('.palette-item[draggable="true"]');
            const canvas = document.getElementById('canvas');
            const container = document.getElementById('canvas-container');
            
            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('nodeType', item.dataset.type);
                    e.dataTransfer.setData('toolId', item.dataset.toolId || '');
                });
            });
            
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            
            container.addEventListener('drop', (e) => {
                e.preventDefault();
                const type = e.dataTransfer.getData('nodeType');
                const toolId = e.dataTransfer.getData('toolId');
                
                if (type) {
                    const rect = container.getBoundingClientRect();
                    const x = (e.clientX - rect.left - state.panX) / state.zoom;
                    const y = (e.clientY - rect.top - state.panY) / state.zoom;
                    
                    state.justDropped = true;
                    state.consumeNextClick = true;
                    const node = createNode(type, x, y, toolId);
                    if (node) {
                        const newNodeId = node.id;
                        requestAnimationFrame(() => selectNode(newNodeId));
                        setTimeout(() => selectNode(newNodeId), 25);
                    }
                    setTimeout(() => { state.justDropped = false; }, 150);
                }
            });
        }
        
        // ===== NODE MANAGEMENT =====
        function createNode(type, x, y, toolId = null) {
            const id = 'node_' + nodeIdCounter++;
            
            const nodeConfig = getNodeConfig(type, toolId);
            
            const node = {
                id,
                type,
                name: nodeConfig.name,
                x: Math.round(x / 20) * 20, // Snap to grid
                y: Math.round(y / 20) * 20,
                config: nodeConfig.config,
                toolId
            };
            
            state.nodes.push(node);
            renderNode(node);
            saveToUndo();
            updateEmptyState();
            
            // Select the new node
            selectNode(id);
            
            return node;
        }
        
        function getNodeConfig(type, toolId = null) {
            const configs = {
                trigger: { name: 'Start', config: { triggerType: 'manual' } },
                schedule: { name: 'Schedule', config: { cron: '0 9 * * *', timezone: 'UTC' } },
                webhook: { name: 'Webhook', config: { method: 'POST', path: '/trigger' } },
                action: { name: 'Action', config: { description: '' } },
                condition: { name: 'Condition', config: { field: '', operator: 'equals', value: '' } },
                loop: { name: 'For Each', config: { collection: '', itemVar: 'item' } },
                delay: { name: 'Wait', config: { duration: 5, unit: 'minutes' } },
                approval: { name: 'Approval', config: { assignee_source: 'platform_user', assignee_type: 'user', assignee_ids: [], timeout_hours: 24, message: '' } },
                form: { name: 'Form', config: { fields: [] } },
                notification: { name: 'Send Notification', config: { channel: 'email', template: '' } },
                tool: { name: 'Use Tool', config: { toolId: toolId || '', params: {} } },
                ai: { name: 'AI Task', config: { prompt: '', model: 'gpt-4o' } },
                end: { name: 'End', config: { output: '' } }
            };
            
            // If it's a tool node with toolId, get tool name
            if (type === 'tool' && toolId) {
                const tool = state.tools.find(t => t.id === toolId);
                if (tool) {
                    return { name: tool.name, config: { toolId, params: {} } };
                }
            }
            
            return configs[type] || { name: type, config: {} };
        }
        
        function getShapeClass(type) {
            if (['trigger', 'schedule', 'webhook'].includes(type)) return 'shape-start';
            if (type === 'end') return 'shape-end';
            if (type === 'condition') return 'shape-gateway';
            return 'shape-task';
        }
        
        function renderNode(node) {
            const canvas = document.getElementById('canvas');
            
            const nodeEl = document.createElement('div');
            const shapeClass = getShapeClass(node.type);
            const hasCustomLabel = node.labelOffset && typeof node.labelOffset.x === 'number' && typeof node.labelOffset.y === 'number';
            nodeEl.className = 'workflow-node ' + shapeClass + (hasCustomLabel ? ' label-custom' : ' label-below');
            nodeEl.id = node.id;
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';
            
            const typeClass = getTypeClass(node.type);
            const svgIcon = getTypeSvgIcon(node.type);
            const labelStyle = (hasCustomLabel ? `left:${node.labelOffset.x}px;top:${node.labelOffset.y}px;` : '') + (node.labelFontSize != null ? `font-size:${node.labelFontSize}px;` : '');
            const labelStyleAttr = labelStyle ? `style="${labelStyle}"` : '';
            const ports4 = ['top','right','bottom','left'].map(s => `<div class="port input input-${s}" data-side="${s}"></div>`).join('');
            /* Ø¹Ù‚Ø¯Ø© Ø§Ù„Ù‚Ø±Ø§Ø±: Yes Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø±ØŒ No Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† (default) â€“ ÙˆÙƒÙ„Ø§Ù‡Ù…Ø§ ÙŠØ¯Ø¹Ù… Ø§Ù„Ø£Ø±Ø¨Ø¹ Ø­ÙˆØ§Ù */
            const outPorts = node.type === 'condition'
                ? '<div class="port output-yes output-yes-left" data-side="left"></div><div class="port output-no output-no-right" data-side="right"></div><div class="port output-yes output-yes-top" data-side="top"></div><div class="port output-yes output-yes-bottom" data-side="bottom"></div><div class="port output-yes output-yes-right" data-side="right"></div><div class="port output-no output-no-left" data-side="left"></div><div class="port output-no output-no-top" data-side="top"></div><div class="port output-no output-no-bottom" data-side="bottom"></div>'
                : node.type !== 'end' ? ['top','right','bottom','left'].map(s => `<div class="port output output-${s}" data-side="${s}"></div>`).join('') : '';
            nodeEl.innerHTML = `
                ${ports4}
                <div class="node-shape-wrap ${typeClass}">
                    <div class="node-shape">${svgIcon}</div>
                </div>
                <div class="node-label node-label-draggable" title="Drag to move label â€¢ Font size: use +/- in toolbar" ${labelStyleAttr}>${escapeHtml(node.name)}</div>
                <button class="node-menu-btn" onclick="event.stopPropagation(); showNodeMenu('${node.id}')">â‹®</button>
                <div class="node-body">
                    <div class="node-config-preview">${getConfigPreview(node)}</div>
                </div>
                ${outPorts}
            `;
            
            // Make draggable
            makeDraggable(nodeEl, node);
            
            // Click: Ctrl+Click = toggle ÙÙŠ Ø§Ù„Ù€ selection. Ø¨Ø¯ÙˆÙ† Ctrl: shapeâ†’selectNodeØŒ labelâ†’selectLabelOnly
            nodeEl.addEventListener('click', (e) => {
                if (e.target.closest('.port') || e.target.closest('.node-menu-btn')) return;
                e.stopPropagation();
                if (state.justDropped) return;
                if (e.ctrlKey || e.metaKey) {
                    toggleNodeInSelection(node.id, true);
                    return;
                }
                if (e.target.closest('.node-label')) {
                    selectLabelOnly(node.id);
                    return;
                }
                selectNode(node.id);
            }, true);
            
            // Double click to edit
            nodeEl.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                showProperties(node);
            });
            
            // Setup port connections
            setupPorts(nodeEl, node);
            
            const labelEl = nodeEl.querySelector('.node-label');
            if (labelEl) {
                labelEl.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    startDragLabel(node.id, e);
                });
            }
            
            canvas.appendChild(nodeEl);
        }
        
        function startDragLabel(nodeId, e) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;
            const nodeEl = document.getElementById(nodeId);
            const labelEl = nodeEl && nodeEl.querySelector('.node-label');
            if (!labelEl || !nodeEl) return;
            const nodeRect = nodeEl.getBoundingClientRect();
            const labelRect = labelEl.getBoundingClientRect();
            const zoom = state.zoom;
            const startLabelX = (labelRect.left - nodeRect.left) / zoom;
            const startLabelY = (labelRect.top - nodeRect.top) / zoom;
            const startFontSize = node.labelFontSize != null ? node.labelFontSize : state.labelFontSize;
            state.draggingLabel = { nodeId, startClientX: e.clientX, startClientY: e.clientY, startLabelX, startLabelY };
            if (!node.labelOffset) node.labelOffset = { x: startLabelX, y: startLabelY };
            nodeEl.classList.add('label-custom');
            nodeEl.classList.remove('label-below');
            labelEl.style.position = 'absolute';
            labelEl.style.transform = 'none';
            labelEl.style.left = startLabelX + 'px';
            labelEl.style.top = startLabelY + 'px';
            labelEl.style.fontSize = startFontSize + 'px';
            let didMove = false;
            const onMove = (e) => {
                if (!state.draggingLabel || state.draggingLabel.nodeId !== nodeId) return;
                const dx = (e.clientX - state.draggingLabel.startClientX) / state.zoom;
                const dy = (e.clientY - state.draggingLabel.startClientY) / state.zoom;
                if (Math.abs(dx) > 4 || Math.abs(dy) > 4) didMove = true;
                const x = state.draggingLabel.startLabelX + dx;
                const y = state.draggingLabel.startLabelY + dy;
                node.labelOffset = { x, y };
                labelEl.style.left = x + 'px';
                labelEl.style.top = y + 'px';
            };
            const onUp = () => {
                if (state.draggingLabel && state.draggingLabel.nodeId === nodeId) {
                    if (didMove) saveToUndo();
                    else selectLabelOnly(nodeId);
                    state.draggingLabel = null;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                }
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }
        
        function clientToCanvas(clientX, clientY) {
            const container = document.getElementById('canvas-container');
            if (!container) return { x: 0, y: 0 };
            const r = container.getBoundingClientRect();
            return {
                x: (clientX - r.left - state.panX) / state.zoom,
                y: (clientY - r.top - state.panY) / state.zoom
            };
        }
        
        function startDragConnectionLabel(connIndex, conn, startLx, startLy, startFontSize, e) {
            if (conn.type !== 'yes' && conn.type !== 'no') return;
            state.draggingConnectionLabel = {
                connIndex, conn,
                startClientX: e.clientX, startClientY: e.clientY,
                startLx, startLy
            };
            const onMove = (ev) => {
                if (!state.draggingConnectionLabel || state.draggingConnectionLabel.connIndex !== connIndex) return;
                const pt = clientToCanvas(ev.clientX, ev.clientY);
                const startPt = clientToCanvas(state.draggingConnectionLabel.startClientX, state.draggingConnectionLabel.startClientY);
                const dx = pt.x - startPt.x;
                const dy = pt.y - startPt.y;
                conn.labelOffset = { x: state.draggingConnectionLabel.startLx + dx, y: state.draggingConnectionLabel.startLy + dy };
                renderConnections();
            };
            const onUp = () => {
                if (state.draggingConnectionLabel && state.draggingConnectionLabel.connIndex === connIndex) {
                    saveToUndo();
                    state.draggingConnectionLabel = null;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                }
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }
        
        function getTypeClass(type) {
            const classes = {
                trigger: 'trigger', schedule: 'trigger', webhook: 'trigger',
                action: 'action', tool: 'tool', ai: 'ai', notification: 'notification',
                condition: 'condition',
                loop: 'loop',
                delay: 'delay',
                approval: 'approval', form: 'form',
                end: 'end'
            };
            return classes[type] || 'action';
        }
        
        function getTypeIcon(type) {
            const icons = {
                trigger: 'ğŸ¯', schedule: 'â°', webhook: 'ğŸ”—',
                action: 'âš¡', tool: 'ğŸ”§', ai: 'ğŸ¤–', notification: 'ğŸ“§',
                condition: 'ğŸ”€',
                loop: 'ğŸ”',
                delay: 'â³',
                approval: 'âœ…', form: 'ğŸ“',
                end: 'ğŸ'
            };
            return icons[type] || 'ğŸ“¦';
        }
        
        function getTypeSvgIcon(type) {
            const icons = {
                trigger: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8 5v14l11-7z"/></svg>',
                schedule: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"/></svg>',
                webhook: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg>',
                action: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 3v6h8l-8 12v-6H5l8-12z"/></svg>',
                tool: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"/></svg>',
                ai: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>',
                notification: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H5.17L4 17.17V4h16v12z"/></svg>',
                condition: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2L2 12l10 10 10-10L12 2zm0 15.5L4.5 12 12 4.5 19.5 12 12 19.5z"/></svg>',
                loop: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg>',
                delay: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/></svg>',
                approval: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/><path d="M18.5 10.5L16 13l-1.5-1.5 1-1L16 11l2.5-2.5 1 2z"/></svg>',
                form: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>',
                end: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none"/></svg>'
            };
            return icons[type] || icons.action;
        }
        
        function getNodeDescription(node) {
            const descs = {
                trigger: 'Workflow starts here',
                schedule: 'Runs on schedule',
                webhook: 'Triggered by API',
                action: 'Performs an operation',
                tool: 'Executes a platform tool',
                ai: 'AI-powered processing',
                condition: 'Branch based on condition',
                loop: 'Iterate over collection',
                delay: 'Wait before continuing',
                approval: 'Wait for approval',
                form: 'Collect user input',
                notification: 'Send notification',
                end: 'Workflow ends here'
            };
            return descs[node.type] || '';
        }
        
        function getConfigPreview(node) {
            const cfg = node.config || {};
            let html = '';
            
            switch (node.type) {
                case 'condition':
                    html = `<div class="node-config-item"><span class="config-label">If</span><span class="config-value">${cfg.field || 'field'} ${cfg.operator || '='} ${cfg.value || 'value'}</span></div>`;
                    break;
                case 'delay':
                    html = `<div class="node-config-item"><span class="config-label">Wait</span><span class="config-value">${cfg.duration || 5} ${cfg.unit || 'minutes'}</span></div>`;
                    break;
                case 'approval':
                    const src = cfg.assignee_source || (cfg.approvers && cfg.approvers.length ? 'platform_user' : '');
                    const cnt = (cfg.assignee_ids || cfg.approvers || []).length;
                    const toolName = (cfg.assignee_source === 'tool' && cfg.assignee_tool_id && state.tools) ? (state.tools.find(t => t.id === cfg.assignee_tool_id) || {}).name : '';
                    const approverSummary = src === 'tool' ? (toolName ? 'Tool: ' + toolName : 'Tool') : (src ? (cnt + ' selected') : 'Not set');
                    html = `<div class="node-config-item"><span class="config-label">Approvers</span><span class="config-value">${src ? (src.replace('platform_','') + ': ' + approverSummary) : approverSummary}</span></div>`;
                    break;
                case 'tool':
                    const tool = state.tools.find(t => t.id === cfg.toolId);
                    html = `<div class="node-config-item"><span class="config-label">Tool</span><span class="config-value">${tool ? tool.name : 'Select tool...'}</span></div>`;
                    break;
                case 'notification':
                    html = `<div class="node-config-item"><span class="config-label">Channel</span><span class="config-value">${cfg.channel || 'email'}</span></div>`;
                    break;
                case 'form':
                case 'trigger':
                    const fieldCount = (cfg.fields || []).length;
                    html = `<div class="node-config-item"><span class="config-label">Fields</span><span class="config-value">${fieldCount} input${fieldCount !== 1 ? 's' : ''}</span></div>`;
                    break;
                case 'schedule':
                    html = `<div class="node-config-item"><span class="config-label">Cron</span><span class="config-value">${cfg.cron || '0 9 * * *'}</span></div>`;
                    break;
                case 'webhook':
                    html = `<div class="node-config-item"><span class="config-label">Method</span><span class="config-value">${cfg.method || 'POST'} ${cfg.path || '/trigger'}</span></div>`;
                    break;
                case 'loop':
                    html = `<div class="node-config-item"><span class="config-label">Each</span><span class="config-value">${cfg.itemVar || 'item'} in ${cfg.collection || '...'}</span></div>`;
                    break;
                case 'ai':
                    html = `<div class="node-config-item"><span class="config-label">Model</span><span class="config-value">${cfg.model || 'gpt-4o'}</span></div>`;
                    break;
                case 'end':
                    html = `<div class="node-config-item"><span class="config-label">Output</span><span class="config-value">${cfg.output || 'result'}</span></div>`;
                    break;
                case 'action':
                    html = `<div class="node-config-item"><span class="config-label">Type</span><span class="config-value">${cfg.actionType || 'custom'}</span></div>`;
                    break;
                default:
                    html = '<div class="node-config-item"><span class="config-value" style="color:#6b7280;">Click to configure</span></div>';
            }
            
            return html;
        }
        
        function makeDraggable(nodeEl, node) {
            let startX, startY;
            
            nodeEl.addEventListener('mousedown', (e) => {
                if (e.target.closest('.port') || e.target.closest('.node-menu-btn')) return;
                
                state.isDragging = true;
                nodeEl.classList.add('dragging');
                
                startX = e.clientX;
                startY = e.clientY;
                const ids = getSelectedNodeIds();
                const movingIds = ids.includes(node.id) ? ids : [node.id];
                if (!ids.includes(node.id)) {
                    state.selectedNode = node;
                    state.selectedLabelNodeId = null;
                    state.selectedNodeIds = [node.id];
                    updateSelectionUI();
                }
                const startPositions = {};
                movingIds.forEach(id => {
                    const n = state.nodes.find(x => x.id === id);
                    if (n) startPositions[id] = { x: n.x, y: n.y };
                });
                state.connections.forEach(conn => {
                    if (conn.labelOffset && (conn.type === 'yes' || conn.type === 'no') && movingIds.includes(conn.from) && movingIds.includes(conn.to)) {
                        conn.labelOffset._dragStartX = conn.labelOffset.x;
                        conn.labelOffset._dragStartY = conn.labelOffset.y;
                    }
                });
                
                const onMove = (e) => {
                    if (!state.isDragging) return;
                    const dx = Math.round(((e.clientX - startX) / state.zoom) / 20) * 20;
                    const dy = Math.round(((e.clientY - startY) / state.zoom) / 20) * 20;
                    
                    movingIds.forEach(id => {
                        const n = state.nodes.find(x => x.id === id);
                        const start = startPositions[id];
                        if (!n || !start) return;
                        n.x = start.x + dx;
                        n.y = start.y + dy;
                        const el = document.getElementById(id);
                        if (el) {
                            el.style.left = n.x + 'px';
                            el.style.top = n.y + 'px';
                        }
                    });
                    
                    state.connections.forEach(conn => {
                        if (conn.labelOffset && conn.labelOffset._dragStartX !== undefined) {
                            conn.labelOffset.x = conn.labelOffset._dragStartX + dx;
                            conn.labelOffset.y = conn.labelOffset._dragStartY + dy;
                        }
                    });
                    
                    renderConnections();
                };
                
                const onUp = () => {
                    state.connections.forEach(conn => {
                        if (conn.labelOffset) {
                            delete conn.labelOffset._dragStartX;
                            delete conn.labelOffset._dragStartY;
                        }
                    });
                    state.isDragging = false;
                    nodeEl.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                    if (movingIds.length > 0) saveToUndo();
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }
        
        function getSideToward(fromEl, toEl) {
            const fr = fromEl.getBoundingClientRect();
            const tr = toEl.getBoundingClientRect();
            const dx = (tr.left + tr.width/2) - (fr.left + fr.width/2);
            const dy = (tr.top + tr.height/2) - (fr.top + fr.height/2);
            if (Math.abs(dx) > Math.abs(dy)) return dx > 0 ? 'right' : 'left';
            return dy > 0 ? 'bottom' : 'top';
        }
        /** Ù†Ù‚Ø·Ø© Ø¹Ù„Ù‰ Ø­Ø§ÙØ© Ù…Ø³ØªØ·ÙŠÙ„ Ø§Ù„Ø´ÙƒÙ„ â€“ Ù„Ùˆ forceSide Ù…Ø¹Ø·Ù‰ Ù†Ø±Ø¬Ø¹ Ù…Ø±ÙƒØ² ØªÙ„Ùƒ Ø§Ù„Ø­Ø§ÙØ©ØŒ ÙˆØ¥Ù„Ø§ Ù†Ù‚Ø·Ø© Ø§Ù„Ø®Ø±ÙˆØ¬ ÙÙŠ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø£Ø®Ø±Ù‰ */
        function getShapeEdgePoint(shapeRect, otherCenterX, otherCenterY, forceSide) {
            const L = shapeRect.left, R = shapeRect.left + shapeRect.width;
            const T = shapeRect.top, B = shapeRect.top + shapeRect.height;
            const cx = (L + R) / 2, cy = (T + B) / 2;
            if (forceSide === 'top') return { x: cx, y: T };
            if (forceSide === 'bottom') return { x: cx, y: B };
            if (forceSide === 'left') return { x: L, y: cy };
            if (forceSide === 'right') return { x: R, y: cy };
            const dx = otherCenterX - cx;
            const dy = otherCenterY - cy;
            let bestT = Infinity;
            let x = cx, y = cy;
            if (dx !== 0) {
                let t = (L - cx) / dx;
                if (t > 0.001) { const py = cy + t * dy; if (py >= T && py <= B) { bestT = t; x = L; y = py; } }
                t = (R - cx) / dx;
                if (t > 0.001 && t < bestT) { const py = cy + t * dy; if (py >= T && py <= B) { bestT = t; x = R; y = py; } }
            }
            if (dy !== 0) {
                let t = (T - cy) / dy;
                if (t > 0.001 && t < bestT) { const px = cx + t * dx; if (px >= L && px <= R) { bestT = t; x = px; y = T; } }
                t = (B - cy) / dy;
                if (t > 0.001 && t < bestT) { const px = cx + t * dx; if (px >= L && px <= R) { bestT = t; x = px; y = B; } }
            }
            return { x, y };
        }
        /** Ø£Ù‚Ø±Ø¨ Ù…Ù†ÙØ° Ø¥Ø¯Ø®Ø§Ù„ Ù„Ù†Ù‚Ø·Ø© (BPMN-style: Ø§Ù„Ø±Ø¨Ø· ÙŠØªØ¨Ø¹ Ø§Ù„Ù…Ù†ÙØ° Ø§Ù„Ø£Ù‚Ø±Ø¨ Ù„Ù„Ù…Ø¤Ø´Ø±) */
        function getClosestInputPortToPoint(nodeEl, clientX, clientY) {
            const sides = ['top', 'right', 'bottom', 'left'];
            let bestSide = 'bottom';
            let bestDist = Infinity;
            for (const s of sides) {
                const port = nodeEl.querySelector('.port.input-' + s);
                if (!port) continue;
                const r = port.getBoundingClientRect();
                const px = r.left + r.width / 2;
                const py = r.top + r.height / 2;
                const d = (clientX - px) ** 2 + (clientY - py) ** 2;
                if (d < bestDist) { bestDist = d; bestSide = s; }
            }
            return bestSide;
        }
        /** Ø§Ø­ØªÙŠØ§Ø·ÙŠ: Ø¬Ù‡Ø© Ù…Ù† Ø§Ù„Ø´ÙƒÙ„ Ø­Ø³Ø¨ Ø§Ù„Ø²Ø§ÙˆÙŠØ© (Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ ÙƒÙˆØ¯ Ù‚Ø¯ÙŠÙ…) */
        function getSideOfPointFromShape(nodeEl, clientX, clientY) {
            return getClosestInputPortToPoint(nodeEl, clientX, clientY);
        }
        /** Ø£Ù‚Ø±Ø¨ Ù…Ù†ÙØ° Ø¥Ø®Ø±Ø§Ø¬ Ù„Ù†Ù‚Ø·Ø© â€“ ÙŠÙØ³ØªØ¹Ù…Ù„ Ø¹Ù†Ø¯ Ø³Ø­Ø¨ Ø¨Ø¯Ø§ÙŠØ© Ø®Ø· Ø¥Ù„Ù‰ Ø¹Ù‚Ø¯Ø© Ø£Ø®Ø±Ù‰ */
        function getClosestOutputPortToPoint(nodeEl, clientX, clientY) {
            const sel = '.port.output-top, .port.output-right, .port.output-bottom, .port.output-left, .port.output-yes-top, .port.output-yes-right, .port.output-yes-bottom, .port.output-yes-left, .port.output-no-top, .port.output-no-right, .port.output-no-bottom, .port.output-no-left';
            const ports = nodeEl.querySelectorAll(sel);
            let best = { side: 'bottom', portType: 'default' };
            let bestDist = Infinity;
            for (const p of ports) {
                const r = p.getBoundingClientRect();
                const px = r.left + r.width / 2, py = r.top + r.height / 2;
                const d = (clientX - px) ** 2 + (clientY - py) ** 2;
                if (d >= bestDist) continue;
                bestDist = d;
                best = {
                    side: p.getAttribute('data-side') || 'bottom',
                    portType: p.classList.contains('output-yes') || (p.className && String(p.className).includes('output-yes')) ? 'yes' :
                              p.classList.contains('output-no') || (p.className && String(p.className).includes('output-no')) ? 'no' : 'default'
                };
            }
            return best;
        }
        /** Ù…Ø³Ø­ ØªÙ…ÙŠÙŠØ² Ø§Ù„Ù…Ù†ÙØ° Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù Ù…Ù† ÙƒÙ„ Ø§Ù„Ø¹ÙÙ‚Ø¯ */
        function clearConnectionTargetPort() {
            document.querySelectorAll('.port.connection-target-port').forEach(p => p.classList.remove('connection-target-port'));
        }
        /** ØªÙ…ÙŠÙŠØ² Ù…Ù†ÙØ° Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¹ÙŠÙ† ÙƒÙ‡Ø¯Ù Ø±Ø¨Ø· */
        function setConnectionTargetPort(nodeEl, toPort) {
            clearConnectionTargetPort();
            if (!nodeEl || !toPort) return;
            const portEl = getPortForSide(nodeEl, 'input', toPort);
            if (portEl) portEl.classList.add('connection-target-port');
        }
        /** Ù…Ø±ÙƒØ² Ø§Ù„Ù…Ù†ÙØ° ÙÙŠ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù€ canvas */
        function getPortCenterInCanvas(nodeEl, portKind, side) {
            const portEl = getPortForSide(nodeEl, portKind, side);
            if (!portEl) return null;
            const r = portEl.getBoundingClientRect();
            return clientToCanvas(r.left + r.width / 2, r.top + r.height / 2);
        }
        function getPortForSide(nodeEl, portKind, side) {
            if (portKind === 'input') return nodeEl.querySelector('.port.input-' + side);
            /* Ø¹Ù‚Ø¯Ø© Ø§Ù„Ù‚Ø±Ø§Ø±: Yes Ø¹Ù„Ù‰ top/bottom ÙÙ‚Ø·ØŒ No Ø¹Ù„Ù‰ left/right ÙÙ‚Ø· â€“ Ù…Ù†ÙØ° ÙˆØ§Ø­Ø¯ Ù„ÙƒÙ„ Ø¬Ù‡Ø© */
            if (portKind === 'output-yes') {
                const p = nodeEl.querySelector('.port.output-yes-' + side);
                if (p) return p;
                return nodeEl.querySelector('.port.output-yes-left') || nodeEl.querySelector('.port.output-yes-right') || nodeEl.querySelector('.port.output-yes-top') || nodeEl.querySelector('.port.output-yes-bottom');
            }
            if (portKind === 'output-no') {
                const p = nodeEl.querySelector('.port.output-no-' + side);
                if (p) return p;
                return nodeEl.querySelector('.port.output-no-right') || nodeEl.querySelector('.port.output-no-left') || nodeEl.querySelector('.port.output-no-top') || nodeEl.querySelector('.port.output-no-bottom');
            }
            return nodeEl.querySelector('.port.output-' + side);
        }
        /** Ø£Ù‚Ø±Ø¨ Ù†Ù‚Ø·ØªÙŠ Ø±Ø¨Ø· Ø¨ÙŠÙ† Ø¹Ù‚Ø¯ØªÙŠÙ† â€“ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡Ø§ Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§Ø°Ø§Ø© Ø£Ùˆ Ø¹Ù†Ø¯ Ø§Ù„Ø±Ø³Ù… */
        function getClosestPortPair(fromNodeEl, toNodeEl, outKind) {
            const outSides = outKind === 'output-yes' ? ['left', 'right', 'top', 'bottom'] : outKind === 'output-no' ? ['right', 'left', 'top', 'bottom'] : ['top', 'right', 'bottom', 'left'];
            const inSides = ['top', 'right', 'bottom', 'left'];
            let bestDist = Infinity, bestFrom = outSides[0], bestTo = inSides[0];
            for (const fs of outSides) {
                const fp = getPortForSide(fromNodeEl, outKind, fs);
                if (!fp) continue;
                const fr = fp.getBoundingClientRect();
                const fx = fr.left + fr.width / 2, fy = fr.top + fr.height / 2;
                for (const ts of inSides) {
                    const tp = getPortForSide(toNodeEl, 'input', ts);
                    if (!tp) continue;
                    const tr = tp.getBoundingClientRect();
                    const tx = tr.left + tr.width / 2, ty = tr.top + tr.height / 2;
                    const d = (fx - tx) * (fx - tx) + (fy - ty) * (fy - ty);
                    if (d < bestDist) { bestDist = d; bestFrom = fs; bestTo = ts; }
                }
            }
            return { fromSide: bestFrom, toSide: bestTo };
        }
        function completeConnection(toNodeId, toPort) {
            if (!state.isConnecting || !state.connectionStart) return false;
            if (state.connectionStart.nodeId === toNodeId) return false;
            let connType = state.connectionStart.portType;
            const fromNode = state.nodes.find(n => n.id === state.connectionStart.nodeId);
            /* Ø¹Ù‚Ø¯Ø© Ø§Ù„Ù‚Ø±Ø§Ø±: Ø£ÙˆÙ„ ÙØ±Ø¹ Ø¯Ø§Ø¦Ù…Ø§Ù‹ YesØŒ Ø§Ù„ÙØ±Ø¹ Ø§Ù„ØªØ§Ù†ÙŠ No â€“ Ù…Ù…Ù†ÙˆØ¹ ÙØ±Ø¹ÙŠÙ† No */
            if (fromNode && fromNode.type === 'condition') {
                const existingFromCondition = state.connections.filter(c => c.from === state.connectionStart.nodeId);
                if (existingFromCondition.length === 0) {
                    connType = 'yes';
                } else if (existingFromCondition.length === 1) {
                    connType = 'no';
                }
                /* Ù„Ùˆ ÙÙŠÙ‡ ÙØ±Ø¹ÙŠÙ† ÙØ¹Ù„Ø§Ù‹ (yes Ùˆ no) ÙˆØ§Ù„ÙŠÙˆØ²Ø± Ø¨ÙŠØ¶ÙŠÙ ØªØ§Ù„Øª Ù†ØªØ±Ùƒ Ø§Ù„Ù†ÙˆØ¹ Ù…Ù† Ø§Ù„Ø¨ÙˆØ±Øª */
            }
            const conn = {
                from: state.connectionStart.nodeId,
                to: toNodeId,
                type: connType,
                fromPort: state.connectionStart.fromPort,
                toPort: toPort
            };
            /* Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø±Ø¨Ø· Ø§Ù„Ù‚Ø¯ÙŠÙ… Ù„Ù†ÙØ³ Ø§Ù„Ù…Ù†ÙØ° ÙÙ‚Ø· â€“ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø¹Ø¯Ø© Ø£Ø·Ø±Ø§Ù Ù…Ù† Ù†ÙØ³ Ø§Ù„Ø¹Ù‚Ø¯Ø© */
            state.connections = state.connections.filter(c => 
                !(c.from === conn.from && c.type === conn.type && (c.fromPort || '') === (conn.fromPort || ''))
            );
            state.connections.push(conn);
            renderConnections();
            saveToUndo();
            state.connectionCompleted = true;
            state.connectionHoverNode = null;
            state.connectionHoverPort = null;
            state.connectionHoverPoint = null;
            return true;
        }
        function endConnectingMode() {
            state.isConnecting = false;
            state.connectionStart = null;
            state.connectionPreview = null;
            document.body.classList.remove('connecting');
            clearConnectionTargetPort();
            const svgInteractive = document.getElementById('connections-interactive-svg');
            const preview = svgInteractive && svgInteractive.querySelector('.connection-preview-path');
            if (preview) preview.remove();
            state.connectionHoverNode = null;
            state.connectionHoverPort = null;
            state.connectionHoverPoint = null;
            state.connectionCompleted = false;
        }
        function setupPorts(nodeEl, node) {
            const ports = nodeEl.querySelectorAll('.port.output, .port.output-top, .port.output-right, .port.output-bottom, .port.output-left, .port.output-yes, .port.output-no, .port.output-yes-top, .port.output-yes-right, .port.output-yes-bottom, .port.output-yes-left, .port.output-no-top, .port.output-no-right, .port.output-no-bottom, .port.output-no-left');
            ports.forEach(port => {
                port.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    state.isConnecting = true;
                    const fromPort = port.getAttribute('data-side') || undefined;
                    state.connectionStart = {
                        nodeId: node.id,
                        portType: port.classList.contains('output-yes') || (port.className && port.className.includes('output-yes')) ? 'yes' :
                                  port.classList.contains('output-no') || (port.className && port.className.includes('output-no')) ? 'no' : 'default',
                        fromPort
                    };
                    state.connectionHoverNode = null;
                    state.connectionHoverPort = null;
                    state.connectionHoverPoint = null;
                    state.connectionCompleted = false;
                    document.body.classList.add('connecting');
                    startConnectionPreview(node.id, fromPort, state.connectionStart.portType, e);
                });
            });
            const inputPorts = nodeEl.querySelectorAll('.port.input, .port.input-top, .port.input-right, .port.input-bottom, .port.input-left');
            inputPorts.forEach(inputPort => {
                inputPort.addEventListener('mouseup', (e) => {
                    if (state.reconnectEdge) {
                        const from = state.reconnectEdge.from;
                        const type = state.reconnectEdge.type;
                        const fromPort = state.reconnectEdge.fromPort;
                        if (from !== node.id) {
                            const toPort = (e.currentTarget.getAttribute && e.currentTarget.getAttribute('data-side')) || getSideOfPointFromShape(nodeEl, e.clientX, e.clientY);
                            state.connections.push({ from, to: node.id, type, fromPort, toPort });
                            saveToUndo();
                            renderConnections();
                        }
                        state.reconnectEdge = null;
                        document.body.classList.remove('connecting');
                        return;
                    }
                    if (state.isConnecting && state.connectionStart) {
                        const toPort = (e.currentTarget.getAttribute && e.currentTarget.getAttribute('data-side')) || getSideOfPointFromShape(nodeEl, e.clientX, e.clientY);
                        if (completeConnection(node.id, toPort)) { }
                        endConnectingMode();
                        return;
                    }
                });
            });
            /* Ø¥ÙÙ„Ø§Øª Ø¹Ù„Ù‰ Ø£ÙŠ Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ø¹Ù‚Ø¯Ø© ÙŠÙƒÙ…Ù„ Ø§Ù„Ø±Ø¨Ø· (Ø£Ø³Ù‡Ù„ Ù…Ù† Ø§Ø³ØªÙ‡Ø¯Ø§Ù Ø§Ù„Ù…Ù†ÙØ° Ø§Ù„ØµØºÙŠØ±) */
            nodeEl.addEventListener('mouseup', (e) => {
                if (e.target.closest('.port')) return;
                if (state.reconnectEdge) {
                    if (state.reconnectEdge.from !== node.id) {
                        const fromNodeEl = document.getElementById(state.reconnectEdge.from);
                        const toPort = fromNodeEl ? getSideToward(nodeEl, fromNodeEl) : 'bottom';
                        state.connections.push({
                            from: state.reconnectEdge.from,
                            to: node.id,
                            type: state.reconnectEdge.type,
                            fromPort: state.reconnectEdge.fromPort,
                            toPort
                        });
                        saveToUndo();
                        renderConnections();
                    }
                    state.reconnectEdge = null;
                    document.body.classList.remove('connecting');
                    return;
                }
                if (state.isConnecting && state.connectionStart && state.connectionStart.nodeId !== node.id) {
                    const fromNodeEl = document.getElementById(state.connectionStart.nodeId);
                    const toPort = fromNodeEl ? getSideToward(nodeEl, fromNodeEl) : 'bottom';
                    if (completeConnection(node.id, toPort)) { }
                }
                endConnectingMode();
            });
        }
        
        // ===== CONNECTIONS =====
        let stateSelectedConnIndex = null;
        
        function renderConnections() {
            const svg = document.getElementById('connections-svg');
            const svgInteractive = document.getElementById('connections-interactive-svg');
            svg.innerHTML = '';
            if (svgInteractive) svgInteractive.innerHTML = '';
            
            const ns = 'http://www.w3.org/2000/svg';
            state.connections.forEach((conn, idx) => {
                const fromNode = document.getElementById(conn.from);
                const toNode = document.getElementById(conn.to);
                
                if (!fromNode || !toNode) return;
                
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                const outKind = conn.type === 'yes' ? 'output-yes' : conn.type === 'no' ? 'output-no' : 'output';
                let fromSide = conn.fromPort;
                let toSide = conn.toPort;
                if (fromSide == null || toSide == null) {
                    const pair = getClosestPortPair(fromNode, toNode, outKind);
                    fromSide = fromSide ?? pair.fromSide;
                    toSide = toSide ?? pair.toSide;
                    conn.fromPort = pair.fromSide;
                    conn.toPort = pair.toSide;
                }
                /* Ø¹Ù‚Ø¯Ø© Ø§Ù„Ù‚Ø±Ø§Ø±: Yes Ùˆ No ÙŠØ¯Ø¹Ù…Ø§Ù† Ø§Ù„Ø£Ø±Ø¨Ø¹ Ø­ÙˆØ§Ù â€“ Ù„Ø§ ØªØµØ­ÙŠØ­ */
                if (toSide == null) toSide = getSideToward(toNode, fromNode);
                const fromPortEl = getPortForSide(fromNode, outKind, fromSide);
                const toPortEl = getPortForSide(toNode, 'input', toSide);
                /* Ø®Ø·ÙˆØ· Ø§Ù„Ø±Ø¨Ø· Ù„Ø§ ØªØªØµÙ„ Ø¥Ù„Ø§ Ø¨Ù†Ù‚Ø· Ø§Ù„Ø±Ø¨Ø· (Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ù†Ø§ÙØ°) ÙÙ‚Ø· â€“ Ù„Ø§ Ø¨Ø­Ø§ÙØ© Ø§Ù„Ø´ÙƒÙ„ */
                if (!fromPortEl || !toPortEl) return;
                const fromRect = fromPortEl.getBoundingClientRect();
                const toRect = toPortEl.getBoundingClientRect();
                const x1 = (fromRect.left + fromRect.width / 2 - canvasRect.left) / state.zoom;
                const y1 = (fromRect.top + fromRect.height / 2 - canvasRect.top) / state.zoom;
                const x2 = (toRect.left + toRect.width / 2 - canvasRect.left) / state.zoom;
                const y2 = (toRect.top + toRect.height / 2 - canvasRect.top) / state.zoom;
                
                const pathInfo = getConnectionPathData(x1, y1, x2, y2, fromSide, toSide, conn, fromNode, toNode, canvasRect);
                const pathD = pathInfo.pathD;
                const midX = pathInfo.bendX;
                const midY = pathInfo.bendY;
                const isStraight = pathInfo.straightLine === true;
                
                const path = document.createElementNS(ns, 'path');
                path.setAttribute('class', `connection-path ${conn.type}${stateSelectedConnIndex === idx ? ' selected' : ''}`);
                path.setAttribute('data-conn-index', String(idx));
                path.setAttribute('d', pathD);
                
                svg.appendChild(path);
                
                /* Ù…Ø³Ø§Ø± Ø´ÙØ§Ù ÙÙŠ Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ© Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø®Ø· Ø¨Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„ÙŠÙ‡ */
                const hitPath = document.createElementNS(ns, 'path');
                hitPath.setAttribute('class', 'connection-hit-path');
                hitPath.setAttribute('data-conn-index', String(idx));
                hitPath.setAttribute('d', pathD);
                hitPath.style.pointerEvents = 'stroke';
                hitPath.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectConnection(idx);
                });
                if (svgInteractive) svgInteractive.appendChild(hitPath);
                
                const gHandle = document.createElementNS(ns, 'g');
                gHandle.setAttribute('class', `connection-handles ${conn.type || ''}${stateSelectedConnIndex === idx ? ' selected' : ''}`);
                gHandle.setAttribute('data-conn-index', String(idx));
                const startHandle = document.createElementNS(ns, 'circle');
                startHandle.setAttribute('class', 'connection-start-handle');
                startHandle.setAttribute('cx', x1);
                startHandle.setAttribute('cy', y1);
                startHandle.setAttribute('r', 10);
                startHandle.setAttribute('title', 'Drag to change connection start point');
                startHandle.style.pointerEvents = 'all';
                startHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    startDragEdgeStart(idx, conn, x1, y1, x2, y2);
                });
                gHandle.appendChild(startHandle);
                const endHandle = document.createElementNS(ns, 'circle');
                endHandle.setAttribute('class', 'connection-end-handle');
                endHandle.setAttribute('cx', x2);
                endHandle.setAttribute('cy', y2);
                endHandle.setAttribute('r', 10);
                endHandle.setAttribute('title', 'Drag to change connection end point');
                endHandle.style.pointerEvents = 'all';
                endHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    startDragEdgeEnd(idx, conn, x1, y1, x2, y2);
                });
                gHandle.appendChild(endHandle);
                if (!isStraight) {
                    const bendHandle = document.createElementNS(ns, 'circle');
                    bendHandle.setAttribute('class', 'connection-bend-handle');
                    bendHandle.setAttribute('cx', midX);
                    bendHandle.setAttribute('cy', midY);
                    bendHandle.setAttribute('r', 6);
                    bendHandle.setAttribute('title', 'Drag to adjust bend â€¢ Double-click to reset');
                    bendHandle.style.pointerEvents = 'all';
                    bendHandle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        startDragBendPoint(idx, conn, x1, y1, x2, y2);
                    });
                    bendHandle.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        if (conn.bendPoint) {
                            delete conn.bendPoint;
                            saveToUndo();
                            renderConnections();
                        }
                    });
                    gHandle.appendChild(bendHandle);
                }
                if (svgInteractive) svgInteractive.appendChild(gHandle);
                
                const labelX = midX;
                const labelY = midY;
                if (conn.type === 'yes' || conn.type === 'no') {
                    const fontSize = conn.labelFontSize != null ? conn.labelFontSize : state.labelFontSize;
                    const offset = conn.labelOffset ? 0 : 18;
                    const lx = conn.labelOffset ? conn.labelOffset.x : labelX;
                    const ly = conn.labelOffset ? conn.labelOffset.y : (labelY - offset);
                    const badgeW = Math.max(28, Math.round(fontSize * 2.2));
                    const badgeH = Math.max(14, Math.round(fontSize * 1.2));
                    const rx = 6;
                    const g = document.createElementNS(ns, 'g');
                    g.setAttribute('class', `connection-label-badge ${conn.type}${stateSelectedConnIndex === idx ? ' selected' : ''}`);
                    g.setAttribute('data-conn-index', String(idx));
                    g.setAttribute('title', 'Drag to move label â€¢ Font size: use +/- in toolbar');
                    const rect = document.createElementNS(ns, 'rect');
                    rect.setAttribute('x', lx - badgeW / 2);
                    rect.setAttribute('y', ly - badgeH / 2);
                    rect.setAttribute('width', badgeW);
                    rect.setAttribute('height', badgeH);
                    rect.setAttribute('rx', rx);
                    g.appendChild(rect);
                    const text = document.createElementNS(ns, 'text');
                    text.setAttribute('x', lx);
                    text.setAttribute('y', ly);
                    text.setAttribute('font-size', fontSize);
                    text.textContent = conn.type === 'yes' ? 'Yes' : 'No';
                    g.appendChild(text);
                    g.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        selectConnection(idx);
                        startDragConnectionLabel(idx, conn, lx, ly, fontSize, e);
                    });
                    if (svgInteractive) svgInteractive.appendChild(g);
                }
            });
            
            if (state.draggingEdgeEnd) {
                const d = state.draggingEdgeEnd;
                let endX = d.currentX, endY = d.currentY;
                if (d.hoverNode && d.hoverPort) {
                    const targetEl = document.getElementById(d.hoverNode);
                    const pc = targetEl ? getPortCenterInCanvas(targetEl, 'input', d.hoverPort) : null;
                    if (pc) { endX = pc.x; endY = pc.y; }
                }
                const pathD = getDragPreviewPathD(d.fromX, d.fromY, endX, endY);
                const path = document.createElementNS(ns, 'path');
                path.setAttribute('class', `connection-path ${d.type} connection-preview selected`);
                path.setAttribute('d', pathD);
                path.setAttribute('stroke-dasharray', '6 4');
                if (svgInteractive) svgInteractive.appendChild(path);
                d.previewPath = path;
            }
            if (state.draggingEdgeStart) {
                const d = state.draggingEdgeStart;
                const pathD = getDragPreviewPathD(d.currentX, d.currentY, d.toX, d.toY);
                const path = document.createElementNS(ns, 'path');
                path.setAttribute('class', `connection-path ${d.type} connection-preview selected`);
                path.setAttribute('d', pathD);
                path.setAttribute('stroke-dasharray', '6 4');
                if (svgInteractive) svgInteractive.appendChild(path);
                d.previewPath = path;
            }
        }
        /** Ù…Ø³ØªØ·ÙŠÙ„ Ø§Ù„Ø¹Ù‚Ø¯Ø© ÙÙŠ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù€ canvas */
        function getNodeRectInCanvas(nodeEl, canvasRect) {
            const r = nodeEl.getBoundingClientRect();
            return {
                left: (r.left - canvasRect.left) / state.zoom,
                right: (r.right - canvasRect.left) / state.zoom,
                top: (r.top - canvasRect.top) / state.zoom,
                bottom: (r.bottom - canvasRect.top) / state.zoom
            };
        }
        /** Ù‡Ù„ Ø§Ù„Ù†Ù‚Ø·Ø© Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„ (Ù…Ø¹ Ù‡Ø§Ù…Ø´) */
        function pointInRect(px, py, r, margin) {
            margin = margin || 0;
            return px >= r.left - margin && px <= r.right + margin && py >= r.top - margin && py <= r.bottom + margin;
        }
        /** Ù‡Ù„ Ø®Ø· Ø¹Ù…ÙˆØ¯ÙŠ Ø¹Ù†Ø¯ x Ù…Ù† ya Ù„Ù€ yb ÙŠÙ…Ø± Ø¹Ø¨Ø± Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„ */
        function verticalSegmentCrossesRect(x, ya, yb, r, pad) {
            const yMin = Math.min(ya, yb), yMax = Math.max(ya, yb);
            return x >= r.left - pad && x <= r.right + pad && yMin <= r.bottom + pad && yMax >= r.top - pad;
        }
        /** Ù‡Ù„ Ø®Ø· Ø£ÙÙ‚ÙŠ Ø¹Ù†Ø¯ y Ù…Ù† xa Ù„Ù€ xb ÙŠÙ…Ø± Ø¹Ø¨Ø± Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„ */
        function horizontalSegmentCrossesRect(y, xa, xb, r, pad) {
            const xMin = Math.min(xa, xb), xMax = Math.max(xa, xb);
            return y >= r.top - pad && y <= r.bottom + pad && xMin <= r.right + pad && xMax >= r.left - pad;
        }
        /** Ù‡Ù„ Ù‚Ø·Ø¹Ø© Ø§Ù„Ø®Ø· Ù…Ù† (x1,y1) Ø¥Ù„Ù‰ (x2,y2) ØªÙ…Ø± Ø¹Ø¨Ø± Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„ (Ù†Ù‚Ø§Ø· Ø¯Ø§Ø®Ù„ÙŠØ© ÙÙ‚Ø·) */
        function lineSegmentCrossesRect(x1, y1, x2, y2, r, pad) {
            for (let t = 0.1; t < 1; t += 0.1) {
                const px = x1 + t * (x2 - x1);
                const py = y1 + t * (y2 - y1);
                if (pointInRect(px, py, r, pad)) return true;
            }
            return false;
        }
        /** Ù†Ù‚Ø·Ø© Ø§Ù†Ø­Ù†Ø§Ø¡ Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¹ÙÙ‚Ø¯ â€“ Ø§Ù„Ø®Ø· Ù„Ø§ ÙŠÙ…Ø± Ø£Ø¨Ø¯Ø§Ù‹ Ù…Ù† Ø¯Ø§Ø®Ù„ Ø§Ù„Ø´ÙƒÙ„. Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¯Ø®ÙˆÙ„/Ø§Ù„Ø®Ø±ÙˆØ¬ */
        function getBendOutsideNodes(x1, y1, x2, y2, fromSide, toSide, fromNode, toNode, canvasRect) {
            const segmentLen = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const pad = Math.min(20, Math.max(8, segmentLen * 0.25));
            const horSides = ['left', 'right'];
            const fromH = horSides.includes(fromSide), toH = horSides.includes(toSide);
            let bx = (x1 + x2) / 2, by = (y1 + y2) / 2;
            if (!fromNode || !toNode) return { x: bx, y: by };
            const r1 = getNodeRectInCanvas(fromNode, canvasRect);
            const r2 = getNodeRectInCanvas(toNode, canvasRect);
            const leftOfBoth = Math.min(r1.left, r2.left) - pad;
            const rightOfBoth = Math.max(r1.right, r2.right) + pad;
            const aboveBoth = Math.min(r1.top, r2.top) - pad;
            const belowBoth = Math.max(r1.bottom, r2.bottom) + pad;
            const gapX = r1.right + pad <= r2.left - pad ? (r1.right + r2.left) / 2 : null;
            const gapX2 = r2.right + pad <= r1.left - pad ? (r2.right + r1.left) / 2 : null;
            const gapY = r1.bottom + pad <= r2.top - pad ? (r1.bottom + r2.top) / 2 : null;
            const gapY2 = r2.bottom + pad <= r1.top - pad ? (r2.bottom + r1.top) / 2 : null;
            if (fromH && toH) {
                if (gapX != null && (fromSide !== 'right' || gapX >= r2.right + pad)) { bx = gapX; }
                else if (gapX2 != null && (fromSide !== 'left' || gapX2 <= r2.left - pad)) { bx = gapX2; }
                else { bx = fromSide === 'left' ? leftOfBoth : rightOfBoth; }
                const yLo = Math.min(r1.top, r2.top) - pad, yHi = Math.max(r1.bottom, r2.bottom) + pad;
                by = Math.max(yLo, Math.min(yHi, (y1 + y2) / 2));
                if (verticalSegmentCrossesRect(bx, y1, y2, r1, pad) || verticalSegmentCrossesRect(bx, y1, y2, r2, pad)) {
                    bx = bx <= (r1.left + r2.left) / 2 ? leftOfBoth : rightOfBoth;
                }
            } else if (!fromH && !toH) {
                const portsFaceEachOther = (fromSide === 'top' && toSide === 'bottom') || (fromSide === 'bottom' && toSide === 'top');
                if (portsFaceEachOther && gapY != null) { by = gapY; }
                else if (portsFaceEachOther && gapY2 != null) { by = gapY2; }
                else { by = fromSide === 'top' ? aboveBoth : belowBoth; }
                const xLo = Math.min(r1.left, r2.left) - pad, xHi = Math.max(r1.right, r2.right) + pad;
                bx = Math.max(xLo, Math.min(xHi, (x1 + x2) / 2));
                if (horizontalSegmentCrossesRect(by, x1, x2, r1, pad) || horizontalSegmentCrossesRect(by, x1, x2, r2, pad)) {
                    by = fromSide === 'top' ? aboveBoth : belowBoth;
                }
            } else if (fromH && !toH) {
                if (fromSide === 'right' && gapX != null) { bx = gapX; }
                else if (fromSide === 'left' && gapX2 != null) { bx = gapX2; }
                else { bx = fromSide === 'left' ? leftOfBoth : rightOfBoth; }
                if (toSide === 'top' && gapY != null) { by = gapY; }
                else if (toSide === 'bottom' && gapY2 != null) { by = gapY2; }
                else { by = toSide === 'top' ? aboveBoth : belowBoth; }
                if (verticalSegmentCrossesRect(bx, y1, by, r1, pad) || verticalSegmentCrossesRect(bx, y1, by, r2, pad) ||
                    verticalSegmentCrossesRect(bx, by, y2, r1, pad) || verticalSegmentCrossesRect(bx, by, y2, r2, pad)) {
                    bx = fromSide === 'left' ? leftOfBoth : rightOfBoth;
                }
                if (horizontalSegmentCrossesRect(by, bx, x2, r1, pad) || horizontalSegmentCrossesRect(by, bx, x2, r2, pad)) {
                    by = toSide === 'top' ? aboveBoth : belowBoth;
                }
            } else {
                if (gapY != null) {
                    const okForFrom = (fromSide === 'top' && gapY <= r1.top - pad) || (fromSide === 'bottom' && gapY >= r1.bottom + pad);
                    if (okForFrom) by = gapY;
                    else by = fromSide === 'top' ? aboveBoth : belowBoth;
                } else if (gapY2 != null) {
                    const okForFrom = (fromSide === 'top' && gapY2 <= r1.top - pad) || (fromSide === 'bottom' && gapY2 >= r1.bottom + pad);
                    if (okForFrom) by = gapY2;
                    else by = fromSide === 'top' ? aboveBoth : belowBoth;
                } else { by = fromSide === 'top' ? aboveBoth : belowBoth; }
                if (toSide === 'right' && gapX2 != null) { bx = gapX2; }
                else if (toSide === 'left' && gapX != null) { bx = gapX; }
                else { bx = toSide === 'left' ? leftOfBoth : rightOfBoth; }
                if (horizontalSegmentCrossesRect(by, x1, bx, r1, pad) || horizontalSegmentCrossesRect(by, x1, bx, r2, pad) ||
                    horizontalSegmentCrossesRect(by, bx, x2, r1, pad) || horizontalSegmentCrossesRect(by, bx, x2, r2, pad)) {
                    by = fromSide === 'top' ? aboveBoth : belowBoth;
                }
                if (verticalSegmentCrossesRect(bx, by, y2, r1, pad) || verticalSegmentCrossesRect(bx, by, y2, r2, pad)) {
                    bx = toSide === 'left' ? leftOfBoth : rightOfBoth;
                }
            }
            if (pointInRect(bx, by, r1, pad) || pointInRect(bx, by, r2, pad)) {
                bx = leftOfBoth;
                by = (y1 + y2) / 2;
                if (pointInRect(bx, by, r1, pad) || pointInRect(bx, by, r2, pad)) {
                    bx = rightOfBoth;
                    if (pointInRect(bx, by, r1, pad) || pointInRect(bx, by, r2, pad)) {
                        by = aboveBoth;
                        if (pointInRect(bx, by, r1, pad) || pointInRect(bx, by, r2, pad)) by = belowBoth;
                    }
                }
            }
            return { x: bx, y: by };
        }
        /** Ù…Ø³Ø§Ø± Ø§Ù„Ø±Ø¨Ø· Ø§Ù„Ø°ÙƒÙŠ ÙˆØ§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ
         * Rules: Ø§Ù„Ø®Ø· Ù„Ø§ ÙŠÙ…Ø± Ù…Ù† Ø¯Ø§Ø®Ù„ Ø§Ù„Ù€ shapeØ› Ø§Ù„Ø§Ù†Ø­Ù†Ø§Ø¡ ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ø§Ù„Ù…Ø³Ø§ÙØ©Ø› ØªØ¬Ù†Ø¨ Ø§Ù„Ù‚Ø·Ø§Ø¹Ø§Øª Ø§Ù„Ù‚ØµÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹ (kinks)
         * Paths recalculate on node move (renderConnections in makeDraggable mousemove) */
        function getConnectionPathData(x1, y1, x2, y2, fromSide, toSide, conn, fromNode, toNode, canvasRect) {
            const pad = 20;
            const useManualBend = conn && conn.bendPoint && typeof conn.bendPoint.x === 'number' && typeof conn.bendPoint.y === 'number';
            const straightPossible = !useManualBend && fromNode && toNode;
            if (straightPossible) {
                const r1 = getNodeRectInCanvas(fromNode, canvasRect);
                const r2 = getNodeRectInCanvas(toNode, canvasRect);
                const segmentLen = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                const dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
                const minBendDist = 40;
                const minSegmentForBend = 12;
                const alignedVertically = dx < minSegmentForBend;
                const alignedHorizontally = dy < minSegmentForBend;
                const wouldCreateKink = segmentLen < minBendDist && (alignedVertically || alignedHorizontally);
                const straightPad = wouldCreateKink ? 0 : Math.max(1, Math.min(pad, segmentLen * 0.2));
                let crosses = lineSegmentCrossesRect(x1, y1, x2, y2, r1, straightPad) || lineSegmentCrossesRect(x1, y1, x2, y2, r2, straightPad);
                const minSegmentLen = 10;
                const bentWouldKink = Math.min(dx, dy) < minSegmentLen;
                if (!crosses || (bentWouldKink && !lineSegmentCrossesRect(x1, y1, x2, y2, r1, 0) && !lineSegmentCrossesRect(x1, y1, x2, y2, r2, 0))) {
                    const midX = (x1 + x2) / 2, midY = (y1 + y2) / 2;
                    return { pathD: `M ${x1} ${y1} L ${x2} ${y2}`, bendX: midX, bendY: midY, useHVH: false, straightLine: true };
                }
            }
            const horSides = ['left', 'right'];
            const fromH = horSides.includes(fromSide), toH = horSides.includes(toSide);
            const def = getBendOutsideNodes(x1, y1, x2, y2, fromSide, toSide, fromNode, toNode, canvasRect);
            let bendX = def.x, bendY = def.y;
            if (useManualBend) {
                bendX = conn.bendPoint.x;
                bendY = conn.bendPoint.y;
            }
            let pathD;
            if (fromH && toH) {
                pathD = `M ${x1} ${y1} L ${bendX} ${y1} L ${bendX} ${bendY} L ${bendX} ${y2} L ${x2} ${y2}`;
            } else if (!fromH && !toH) {
                pathD = `M ${x1} ${y1} L ${x1} ${bendY} L ${bendX} ${bendY} L ${x2} ${bendY} L ${x2} ${y2}`;
            } else if (fromH && !toH) {
                pathD = `M ${x1} ${y1} L ${bendX} ${y1} L ${bendX} ${bendY} L ${x2} ${bendY} L ${x2} ${y2}`;
            } else {
                pathD = `M ${x1} ${y1} L ${x1} ${bendY} L ${bendX} ${bendY} L ${bendX} ${y2} L ${x2} ${y2}`;
            }
            return { pathD, bendX, bendY, useHVH: fromH, straightLine: false };
        }
        function getDragPreviewPathD(fromX, fromY, currentX, currentY) {
            const midY = (fromY + currentY) / 2;
            const midX = (fromX + currentX) / 2;
            return state.flowDirection === 'horizontal'
                ? `M ${fromX} ${fromY} L ${midX} ${fromY} L ${midX} ${currentY} L ${currentX} ${currentY}`
                : `M ${fromX} ${fromY} L ${fromX} ${midY} L ${currentX} ${midY} L ${currentX} ${currentY}`;
        }
        function startConnectionPreview(fromNodeId, fromPort, portType, e) {
            const fromNodeEl = document.getElementById(fromNodeId);
            if (!fromNodeEl) return;
            const outKind = portType === 'yes' ? 'output-yes' : portType === 'no' ? 'output-no' : 'output';
            const side = fromPort || 'bottom';
            const fromPortEl = getPortForSide(fromNodeEl, outKind, side);
            if (!fromPortEl) return;
            const canvasRect = document.getElementById('canvas').getBoundingClientRect();
            const fromRect = fromPortEl.getBoundingClientRect();
            const fromX = (fromRect.left + fromRect.width/2 - canvasRect.left) / state.zoom;
            const fromY = (fromRect.top + fromRect.height/2 - canvasRect.top) / state.zoom;
            const svgInteractive = document.getElementById('connections-interactive-svg');
            const ns = 'http://www.w3.org/2000/svg';
            const path = document.createElementNS(ns, 'path');
            path.setAttribute('class', `connection-path ${portType} connection-preview-path`);
            path.setAttribute('stroke-dasharray', '6 4');
            if (svgInteractive) svgInteractive.appendChild(path);
            state.connectionPreview = { path, fromX, fromY };
            const onMove = (ev) => {
                if (!state.connectionPreview) return;
                const inputPort = getInputPortAtPoint(ev.clientX, ev.clientY);
                let hoveredId = null;
                let hoverPort = null;
                if (inputPort && inputPort.nodeId !== fromNodeId) {
                    hoveredId = inputPort.nodeId;
                    hoverPort = inputPort.toPort;
                } else {
                    for (let i = 0; i < state.nodes.length; i++) {
                        const n = state.nodes[i];
                        if (n.id === fromNodeId) continue;
                        const el = document.getElementById(n.id);
                        if (!el) continue;
                        const r = el.getBoundingClientRect();
                        if (ev.clientX >= r.left && ev.clientX <= r.right && ev.clientY >= r.top && ev.clientY <= r.bottom) {
                            hoveredId = n.id;
                            hoverPort = getClosestInputPortToPoint(el, ev.clientX, ev.clientY);
                            break;
                        }
                    }
                }
                const hoveredEl = hoveredId ? document.getElementById(hoveredId) : null;
                setConnectionTargetPort(hoveredEl, hoverPort);
                let endX, endY;
                if (hoveredEl && hoverPort) {
                    const pc = getPortCenterInCanvas(hoveredEl, 'input', hoverPort);
                    endX = pc ? pc.x : (clientToCanvas(ev.clientX, ev.clientY)).x;
                    endY = pc ? pc.y : (clientToCanvas(ev.clientX, ev.clientY)).y;
                } else {
                    const pt = clientToCanvas(ev.clientX, ev.clientY);
                    endX = pt.x;
                    endY = pt.y;
                }
                path.setAttribute('d', getDragPreviewPathD(fromX, fromY, endX, endY));
                state.nodes.forEach(n => {
                    const el = document.getElementById(n.id);
                    if (!el) return;
                    if (n.id === fromNodeId) {
                        el.classList.remove('connection-drop-target');
                        return;
                    }
                    el.classList.toggle('connection-drop-target', hoveredId === n.id);
                });
                if (hoveredId) {
                    state.connectionHoverNode = hoveredId;
                    state.connectionHoverPort = { toPort: hoverPort };
                    state.connectionHoverPoint = { clientX: ev.clientX, clientY: ev.clientY };
                } else {
                    state.connectionHoverNode = null;
                    state.connectionHoverPort = null;
                    state.connectionHoverPoint = null;
                }
            };
            const onUp = (ev) => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
                clearConnectionTargetPort();
                state.nodes.forEach(n => {
                    const el = document.getElementById(n.id);
                    if (el) el.classList.remove('connection-drop-target');
                });
                if (state.connectionPreview && state.connectionPreview.path) {
                    state.connectionPreview.path.remove();
                }
                state.connectionPreview = null;
                if (state.isConnecting && !state.connectionCompleted && state.connectionHoverNode && state.connectionHoverNode !== fromNodeId) {
                    const hoveredEl = document.getElementById(state.connectionHoverNode);
                    const lastPoint = state.connectionHoverPoint || { clientX: ev.clientX, clientY: ev.clientY };
                    let toPort = state.connectionHoverPort ? state.connectionHoverPort.toPort : null;
                    if (!toPort && hoveredEl) {
                        toPort = getClosestInputPortToPoint(hoveredEl, lastPoint.clientX, lastPoint.clientY);
                    }
                    completeConnection(state.connectionHoverNode, toPort);
                }
                if (state.isConnecting) endConnectingMode();
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
            onMove(e);
        }
        function updateDragPreview() {
            if (!state.draggingEdgeEnd || !state.draggingEdgeEnd.previewPath) return;
            const d = state.draggingEdgeEnd;
            let endX = d.currentX, endY = d.currentY;
            if (d.hoverNode && d.hoverPort) {
                const targetEl = document.getElementById(d.hoverNode);
                const pc = targetEl ? getPortCenterInCanvas(targetEl, 'input', d.hoverPort) : null;
                if (pc) { endX = pc.x; endY = pc.y; }
            }
            d.previewPath.setAttribute('d', getDragPreviewPathD(d.fromX, d.fromY, endX, endY));
        }
        
        function getOutputPortAtPoint(clientX, clientY) {
            const el = document.elementFromPoint(clientX, clientY);
            if (!el) return null;
            const port = el.closest ? el.closest('.port[class*="output"]') : null;
            if (!port) return null;
            const nodeEl = port.closest('.workflow-node');
            if (!nodeEl || !nodeEl.id) return null;
            const side = port.getAttribute('data-side') || undefined;
            const portType = (port.classList.contains('output-yes') || (port.className && port.className.includes && port.className.includes('output-yes'))) ? 'yes' :
                (port.classList.contains('output-no') || (port.className && port.className.includes && port.className.includes('output-no'))) ? 'no' : 'default';
            if (state.nodes.some(n => n.id === nodeEl.id && n.type === 'end')) return null;
            return { nodeId: nodeEl.id, fromPort: side, portType };
        }
        function getInputPortAtPoint(clientX, clientY) {
            const el = document.elementFromPoint(clientX, clientY);
            if (!el) return null;
            const port = el.closest ? el.closest('.port[class*="input"]') : null;
            if (!port) return null;
            const nodeEl = port.closest('.workflow-node');
            if (!nodeEl || !nodeEl.id) return null;
            const side = port.getAttribute('data-side') || undefined;
            return { nodeId: nodeEl.id, toPort: side };
        }
        function startDragEdgeEnd(connIndex, conn, fromX, fromY, startX, startY) {
            saveToUndo();
            const origConn = { ...conn };
            state.connections.splice(connIndex, 1);
            state.draggingEdgeEnd = {
                connIndex,
                from: conn.from,
                type: conn.type,
                fromX, fromY,
                currentX: startX,
                currentY: startY,
                origConn,
                hoverNode: null,
                hoverPort: null,
                hoverPoint: null
            };
            stateSelectedConnIndex = null;
            
            function nodeUnderCursor(clientX, clientY, excludeId) {
                let found = null;
                state.nodes.forEach(n => {
                    if (excludeId && n.id === excludeId) return;
                    const el = document.getElementById(n.id);
                    if (!el) return;
                    const r = el.getBoundingClientRect();
                    if (clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom)
                        found = n.id;
                });
                return found;
            }
            
            const onMove = (e) => {
                if (!state.draggingEdgeEnd) return;
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                state.draggingEdgeEnd.currentX = (e.clientX - canvasRect.left) / state.zoom;
                state.draggingEdgeEnd.currentY = (e.clientY - canvasRect.top) / state.zoom;
                const inputPort = getInputPortAtPoint(e.clientX, e.clientY);
                let hoveredId = null;
                let hoverPort = null;
                if (inputPort && inputPort.nodeId !== state.draggingEdgeEnd.from) {
                    hoveredId = inputPort.nodeId;
                    hoverPort = inputPort.toPort;
                } else {
                    const candidate = nodeUnderCursor(e.clientX, e.clientY, state.draggingEdgeEnd.from);
                    if (candidate && candidate !== state.draggingEdgeEnd.from) {
                        hoveredId = candidate;
                        const el = document.getElementById(candidate);
                        hoverPort = el ? getSideOfPointFromShape(el, e.clientX, e.clientY) : null;
                    }
                }
                const hoveredEl = hoveredId ? document.getElementById(hoveredId) : null;
                setConnectionTargetPort(hoveredEl, hoverPort);
                state.nodes.forEach(n => {
                    const el = document.getElementById(n.id);
                    if (!el) return;
                    if (n.id === state.draggingEdgeEnd.from) {
                        el.classList.remove('connection-drop-target');
                        return;
                    }
                    el.classList.toggle('connection-drop-target', hoveredId === n.id);
                });
                state.draggingEdgeEnd.hoverNode = hoveredId;
                state.draggingEdgeEnd.hoverPort = hoverPort;
                state.draggingEdgeEnd.hoverPoint = hoveredId ? { clientX: e.clientX, clientY: e.clientY } : null;
                updateDragPreview();
            };
            const onUp = (e) => {
                if (!state.draggingEdgeEnd) return;
                clearConnectionTargetPort();
                const inputPort = getInputPortAtPoint(e.clientX, e.clientY);
                let newTo = inputPort ? inputPort.nodeId : nodeUnderCursor(e.clientX, e.clientY, state.draggingEdgeEnd.from);
                let toPort = inputPort ? inputPort.toPort : (newTo ? getSideOfPointFromShape(document.getElementById(newTo), e.clientX, e.clientY) : undefined);
                if ((!newTo || newTo === state.draggingEdgeEnd.from) && state.draggingEdgeEnd.hoverNode && state.draggingEdgeEnd.hoverNode !== state.draggingEdgeEnd.from) {
                    newTo = state.draggingEdgeEnd.hoverNode;
                    const hoverPoint = state.draggingEdgeEnd.hoverPoint || { clientX: e.clientX, clientY: e.clientY };
                    const targetEl = document.getElementById(newTo);
                    toPort = state.draggingEdgeEnd.hoverPort || (targetEl ? getSideOfPointFromShape(targetEl, hoverPoint.clientX, hoverPoint.clientY) : undefined);
                }
                state.nodes.forEach(n => {
                    const el = document.getElementById(n.id);
                    if (el) el.classList.remove('connection-drop-target');
                });
                if (newTo && newTo !== state.draggingEdgeEnd.from) {
                    state.connections.push({
                        from: state.draggingEdgeEnd.from,
                        to: newTo,
                        type: state.draggingEdgeEnd.type,
                        fromPort: origConn.fromPort,
                        toPort
                    });
                    saveToUndo();
                } else {
                    state.connections.push(origConn);
                }
                state.draggingEdgeEnd = null;
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
                renderConnections();
            };
            renderConnections();
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }
        function startDragBendPoint(connIndex, conn, x1, y1, x2, y2) {
            saveToUndo();
            if (!conn.bendPoint) conn.bendPoint = { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
            const startClientX = event.clientX, startClientY = event.clientY;
            const startBX = conn.bendPoint.x, startBY = conn.bendPoint.y;
            const onMove = (e) => {
                const dx = (e.clientX - startClientX) / state.zoom;
                const dy = (e.clientY - startClientY) / state.zoom;
                conn.bendPoint.x = startBX + dx;
                conn.bendPoint.y = startBY + dy;
                renderConnections();
            };
            const onUp = () => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }
        function updateDragPreviewStart() {
            if (!state.draggingEdgeStart || !state.draggingEdgeStart.previewPath) return;
            const d = state.draggingEdgeStart;
            d.previewPath.setAttribute('d', getDragPreviewPathD(d.currentX, d.currentY, d.toX, d.toY));
        }
        function startDragEdgeStart(connIndex, conn, startX, startY, toX, toY) {
            saveToUndo();
            const origConn = { ...conn };
            state.connections.splice(connIndex, 1);
            state.draggingEdgeStart = {
                connIndex,
                to: conn.to,
                toPort: conn.toPort,
                type: conn.type,
                toX, toY,
                currentX: startX,
                currentY: startY,
                origConn,
                hoverNode: null,
                hoverData: null
            };
            stateSelectedConnIndex = null;
            
            function nodeUnderCursor(clientX, clientY, excludeId) {
                let found = null;
                state.nodes.forEach(n => {
                    if (excludeId && n.id === excludeId) return;
                    const el = document.getElementById(n.id);
                    if (!el) return;
                    const r = el.getBoundingClientRect();
                    if (clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom)
                        found = n.id;
                });
                return found;
            }
            
            const onMove = (e) => {
                if (!state.draggingEdgeStart) return;
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                state.draggingEdgeStart.currentX = (e.clientX - canvasRect.left) / state.zoom;
                state.draggingEdgeStart.currentY = (e.clientY - canvasRect.top) / state.zoom;
                const outputPort = getOutputPortAtPoint(e.clientX, e.clientY);
                let hoveredId = null;
                let hoverData = null;
                if (outputPort && outputPort.nodeId !== state.draggingEdgeStart.to) {
                    hoveredId = outputPort.nodeId;
                    hoverData = { fromPort: outputPort.fromPort, portType: outputPort.portType };
                } else {
                    const candidate = nodeUnderCursor(e.clientX, e.clientY, state.draggingEdgeStart.to);
                    if (candidate && candidate !== state.draggingEdgeStart.to) {
                        hoveredId = candidate;
                        const el = document.getElementById(candidate);
                        const out = el ? getClosestOutputPortToPoint(el, e.clientX, e.clientY) : { side: 'bottom', portType: 'default' };
                        hoverData = { fromPort: out.side, portType: out.portType };
                    }
                }
                state.nodes.forEach(n => {
                    const el = document.getElementById(n.id);
                    if (!el) return;
                    if (n.id === state.draggingEdgeStart.to) {
                        el.classList.remove('connection-drop-target');
                        return;
                    }
                    el.classList.toggle('connection-drop-target', hoveredId === n.id);
                });
                state.draggingEdgeStart.hoverNode = hoveredId;
                state.draggingEdgeStart.hoverData = hoveredId ? { ...hoverData, point: { clientX: e.clientX, clientY: e.clientY } } : null;
                updateDragPreviewStart();
            };
            const onUp = (e) => {
                if (!state.draggingEdgeStart) return;
                const outputPort = getOutputPortAtPoint(e.clientX, e.clientY);
                let newFrom = outputPort ? outputPort.nodeId : nodeUnderCursor(e.clientX, e.clientY, state.draggingEdgeStart.to);
                let data = outputPort ? { fromPort: outputPort.fromPort, portType: outputPort.portType } : null;
                if ((!newFrom || newFrom === state.draggingEdgeStart.to) && state.draggingEdgeStart.hoverNode && state.draggingEdgeStart.hoverNode !== state.draggingEdgeStart.to) {
                    newFrom = state.draggingEdgeStart.hoverNode;
                    data = state.draggingEdgeStart.hoverData ? { fromPort: state.draggingEdgeStart.hoverData.fromPort, portType: state.draggingEdgeStart.hoverData.portType, point: state.draggingEdgeStart.hoverData.point } : null;
                }
                state.nodes.forEach(n => {
                    const el = document.getElementById(n.id);
                    if (el) el.classList.remove('connection-drop-target');
                });
                if (newFrom && newFrom !== state.draggingEdgeStart.to) {
                    const fromNodeEl = document.getElementById(newFrom);
                    let fromPort, portType;
                    if (data && data.fromPort && data.portType) {
                        fromPort = data.fromPort;
                        portType = data.portType;
                    } else if (fromNodeEl) {
                        const out = getClosestOutputPortToPoint(fromNodeEl, e.clientX, e.clientY);
                        fromPort = out.side || 'bottom';
                        portType = out.portType || 'default';
                    } else {
                        fromPort = 'bottom';
                        portType = 'default';
                    }
                    state.connections.push({
                        from: newFrom,
                        to: state.draggingEdgeStart.to,
                        type: portType,
                        fromPort,
                        toPort: state.draggingEdgeStart.toPort
                    });
                    saveToUndo();
                } else {
                    state.connections.push(origConn);
                }
                state.draggingEdgeStart = null;
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
                renderConnections();
            };
            renderConnections();
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }
        
        function selectConnection(idx) {
            state.selectedNode = null;
            state.selectedLabelNodeId = null;
            state.selectedNodeIds = [];
            updateSelectionUI();
            closeProperties();
            stateSelectedConnIndex = idx;
            const conn = state.connections[idx];
            const px = (conn && (conn.type === 'yes' || conn.type === 'no')) ? (conn.labelFontSize != null ? conn.labelFontSize : state.labelFontSize) : state.labelFontSize;
            updateLabelFontSizeDisplay(px);
            renderConnections();
        }
        
        function deselectConnection() {
            stateSelectedConnIndex = null;
            updateLabelFontSizeDisplay(state.labelFontSize);
            renderConnections();
        }
        
        function deleteConnection(connIndex) {
            if (connIndex >= 0 && connIndex < state.connections.length) {
                state.connections.splice(connIndex, 1);
                saveToUndo();
                deselectConnection();
                renderConnections();
            }
        }
        
        // ===== SELECTION =====
        function getSelectedNodeIds() {
            if (state.selectedNodeIds.length > 0) return state.selectedNodeIds.filter(id => state.nodes.some(n => n.id === id));
            if (state.selectedNode) return [state.selectedNode.id];
            if (state.selectedLabelNodeId) return [state.selectedLabelNodeId];
            return [];
        }
        function selectNode(id) {
            state.selectedNode = null;
            state.selectedLabelNodeId = null;
            state.selectedNodeIds = [];
            stateSelectedConnIndex = null;
            updateSelectionUI();
            const node = state.nodes.find(n => n.id === id);
            if (node) {
                state.selectedNode = node;
                state.selectedNodeIds = [id];
                const el = document.getElementById(id);
                if (el) el.classList.add('selected');
                updateLabelFontSizeDisplay(node.labelFontSize != null ? node.labelFontSize : state.labelFontSize);
                showProperties(node);
            } else {
                closeProperties();
            }
        }
        function selectLabelOnly(nodeId) {
            state.selectedNode = null;
            state.selectedLabelNodeId = nodeId;
            state.selectedNodeIds = [nodeId];
            stateSelectedConnIndex = null;
            updateSelectionUI();
            const el = document.getElementById(nodeId);
            if (el) el.classList.add('label-selected');
            const node = state.nodes.find(n => n.id === nodeId);
            if (node) updateLabelFontSizeDisplay(node.labelFontSize != null ? node.labelFontSize : state.labelFontSize);
            closeProperties();
        }
        function toggleNodeInSelection(nodeId, ctrlKey) {
            if (!ctrlKey) {
                selectNode(nodeId);
                return;
            }
            state.selectedNode = null;
            state.selectedLabelNodeId = null;
            stateSelectedConnIndex = null;
            const idx = state.selectedNodeIds.indexOf(nodeId);
            if (idx >= 0) {
                state.selectedNodeIds.splice(idx, 1);
            } else {
                state.selectedNodeIds.push(nodeId);
            }
            if (state.selectedNodeIds.length === 1) {
                const node = state.nodes.find(n => n.id === state.selectedNodeIds[0]);
                if (node) {
                    state.selectedNode = node;
                    updateLabelFontSizeDisplay(node.labelFontSize != null ? node.labelFontSize : state.labelFontSize);
                    showProperties(node);
                }
            } else {
                closeProperties();
                if (state.selectedNodeIds.length > 0) updateLabelFontSizeDisplay(state.labelFontSize);
            }
            updateSelectionUI();
        }
        function selectAllNodes() {
            if (state.nodes.length === 0) return;
            state.selectedNode = null;
            state.selectedLabelNodeId = null;
            state.selectedNodeIds = state.nodes.map(n => n.id);
            stateSelectedConnIndex = null;
            updateSelectionUI();
            closeProperties();
        }
        function updateSelectionUI() {
            document.querySelectorAll('.workflow-node').forEach(n => {
                n.classList.remove('selected', 'label-selected', 'multi-selected');
                const id = n.id;
                if (state.selectedNodeIds.includes(id)) {
                    n.classList.add(state.selectedNodeIds.length > 1 ? 'multi-selected' : (state.selectedLabelNodeId === id ? 'label-selected' : 'selected'));
                } else if (state.selectedLabelNodeId === id) {
                    n.classList.add('label-selected');
                }
            });
        }
        function deselectAll() {
            state.selectedNode = null;
            state.selectedLabelNodeId = null;
            state.selectedNodeIds = [];
            stateSelectedConnIndex = null;
            updateSelectionUI();
            closeProperties();
            updateLabelFontSizeDisplay(state.labelFontSize);
        }
        function deleteSelectedNodes() {
            const ids = getSelectedNodeIds();
            if (ids.length === 0) return;
            if (!confirm(ids.length > 1 ? `Delete ${ids.length} selected nodes?` : 'Delete this node?')) return;
            ids.forEach(id => {
                state.connections = state.connections.filter(c => c.from !== id && c.to !== id);
                state.nodes = state.nodes.filter(n => n.id !== id);
                document.getElementById(id)?.remove();
            });
            state.selectedNode = null;
            state.selectedLabelNodeId = null;
            state.selectedNodeIds = [];
            closeProperties();
            renderConnections();
            updateEmptyState();
            saveToUndo();
        }
        
        // ===== PROPERTIES PANEL =====
        function showProperties(node) {
            const panel = document.getElementById('properties-panel');
            const icon = document.getElementById('prop-icon');
            const title = document.getElementById('prop-title');
            const type = document.getElementById('prop-type');
            const body = document.getElementById('prop-body');
            
            icon.className = 'properties-icon ' + getTypeClass(node.type);
            icon.textContent = getTypeIcon(node.type);
            title.textContent = node.name;
            type.textContent = node.type.charAt(0).toUpperCase() + node.type.slice(1);
            
            body.innerHTML = generatePropertiesForm(node);
            panel.classList.add('active');
        }
        
        // Helper function to get all available fields from trigger/form nodes
        function getAvailableFields() {
            const fields = [];
            state.nodes.forEach(n => {
                if ((n.type === 'trigger' || n.type === 'form') && n.config.fields) {
                    n.config.fields.forEach(f => {
                        if (f.name) {
                            fields.push({
                                name: f.name,
                                type: f.type,
                                required: f.required || false,
                                source: n.name
                            });
                        }
                    });
                }
            });
            return fields;
        }
        
        function generatePropertiesForm(node) {
            let html = `
                <div class="property-group">
                    <label class="property-label">Name</label>
                    <input type="text" class="property-input" value="${node.name}" 
                           onchange="updateNodeProperty('${node.id}', 'name', this.value)">
                </div>
                <div style="font-size:11px;color:#9ca3af;margin-bottom:8px;">Drag the label on the canvas to move it</div>
            `;
            
            // Get available fields for dropdowns
            const availableFields = getAvailableFields();
            
            switch (node.type) {
                case 'condition':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Field to Check</label>
                            ${availableFields.length > 0 ? `
                                <select class="property-select" onchange="updateNodeConfig('${node.id}', 'field', this.value)">
                                    <option value="">-- Select Field --</option>
                                    ${availableFields.map(f => `
                                        <option value="${f.name}" ${node.config.field === f.name ? 'selected' : ''}>
                                            ${f.name} (${f.type}) - from ${f.source}
                                        </option>
                                    `).join('')}
                                    <option value="_custom" ${node.config.field && !availableFields.find(f => f.name === node.config.field) ? 'selected' : ''}>
                                        âœï¸ Custom field...
                                    </option>
                                </select>
                                ${(node.config.field && !availableFields.find(f => f.name === node.config.field)) || node.config.field === '_custom' ? `
                                    <input type="text" class="property-input" style="margin-top:8px;" placeholder="Enter custom field name" 
                                           value="${node.config.field === '_custom' ? '' : (node.config.field || '')}"
                                           onchange="updateNodeConfig('${node.id}', 'field', this.value)">
                                ` : ''}
                            ` : `
                                <input type="text" class="property-input" placeholder="e.g., amount, status" 
                                       value="${node.config.field || ''}"
                                       onchange="updateNodeConfig('${node.id}', 'field', this.value)">
                                <div style="font-size:11px;color:#f59e0b;margin-top:4px;">
                                    ğŸ’¡ Tip: Add fields to your Start/Form node first
                                </div>
                            `}
                        </div>
                        <div class="property-group">
                            <label class="property-label">Operator</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'operator', this.value)">
                                <option value="equals" ${node.config.operator === 'equals' ? 'selected' : ''}>Equals</option>
                                <option value="not_equals" ${node.config.operator === 'not_equals' ? 'selected' : ''}>Not Equals</option>
                                <option value="greater_than" ${node.config.operator === 'greater_than' ? 'selected' : ''}>Greater Than</option>
                                <option value="less_than" ${node.config.operator === 'less_than' ? 'selected' : ''}>Less Than</option>
                                <option value="contains" ${node.config.operator === 'contains' ? 'selected' : ''}>Contains</option>
                                <option value="is_empty" ${node.config.operator === 'is_empty' ? 'selected' : ''}>Is Empty</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Value</label>
                            <input type="text" class="property-input" placeholder="Compare value" 
                                   value="${node.config.value || ''}"
                                   onchange="updateNodeConfig('${node.id}', 'value', this.value)">
                        </div>
                    `;
                    break;
                    
                case 'delay':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Wait Duration</label>
                            <div style="display:flex;gap:8px;">
                                <input type="number" class="property-input" style="width:100px;" 
                                       value="${node.config.duration || 5}"
                                       onchange="updateNodeConfig('${node.id}', 'duration', parseInt(this.value))">
                                <select class="property-select" onchange="updateNodeConfig('${node.id}', 'unit', this.value)">
                                    <option value="seconds" ${node.config.unit === 'seconds' ? 'selected' : ''}>Seconds</option>
                                    <option value="minutes" ${node.config.unit === 'minutes' ? 'selected' : ''}>Minutes</option>
                                    <option value="hours" ${node.config.unit === 'hours' ? 'selected' : ''}>Hours</option>
                                    <option value="days" ${node.config.unit === 'days' ? 'selected' : ''}>Days</option>
                                </select>
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'tool':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Select Tool</label>
                            <div class="tool-selector">
                                ${state.tools.map(t => `
                                    <div class="tool-option ${node.config.toolId === t.id ? 'selected' : ''}" 
                                         onclick="selectTool('${node.id}', '${t.id}')">
                                        <div class="tool-option-icon">${getToolIcon(t.type)}</div>
                                        <div class="tool-option-info">
                                            <div class="tool-option-name">${t.name}</div>
                                            <div class="tool-option-type">${t.type}</div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'approval':
                    const aCfg = node.config || {};
                    const aSrc = aCfg.assignee_source || (aCfg.approvers && aCfg.approvers.length ? 'platform_user' : 'platform_user');
                    const aIds = aCfg.assignee_ids || aCfg.approvers || [];
                    const aToolId = aCfg.assignee_tool_id || '';
                    const timeoutVal = aCfg.timeout_hours != null ? aCfg.timeout_hours : (aCfg.timeout != null ? aCfg.timeout : 24);
                    const approverLabel = aSrc === 'tool' ? (state.tools.find(t => t.id === aToolId) || {}).name || 'Tool' : (aSrc.replace('platform_','') + ': ' + aIds.length + ' selected');
                    html += `
                        <div class="property-group">
                            <label class="property-label">Approval Message</label>
                            <textarea class="property-textarea" placeholder="Message to show approvers..."
                                      onchange="updateNodeConfig('${node.id}', 'message', this.value)">${aCfg.message || ''}</textarea>
                            ${availableFields.length > 0 ? `
                                <div style="margin-top:8px;padding:8px;background:#1a1f2e;border-radius:6px;">
                                    <div style="font-size:11px;color:#6b7280;margin-bottom:6px;">ğŸ“‹ Available Fields (click to insert):</div>
                                    <div style="display:flex;flex-wrap:wrap;gap:4px;">
                                        ${availableFields.map(f => `
                                            <button onclick="insertFieldRef('${node.id}', 'message', '{{${f.name}}}')" 
                                                    style="padding:4px 8px;background:#374151;border:none;border-radius:4px;color:#a5b4fc;font-size:11px;cursor:pointer;">
                                                {{${f.name}}}
                                            </button>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        <div class="property-group">
                            <label class="property-label">Approvers</label>
                            <div style="font-size:12px;color:#9ca3af;margin-bottom:6px;">From: ${approverLabel}</div>
                            <button type="button" onclick="openApprovalConfigModal('${node.id}')" class="property-input" style="cursor:pointer;text-align:left;">
                                Configure approvers (Platform User / Role / Group / Tool)
                            </button>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Timeout (hours)</label>
                            <input type="number" class="property-input" value="${timeoutVal}" min="1"
                                   onchange="updateNodeConfig('${node.id}', 'timeout_hours', parseInt(this.value) || 24)">
                        </div>
                    `;
                    break;
                    
                case 'notification':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Channel</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'channel', this.value)">
                                <option value="email" ${node.config.channel === 'email' ? 'selected' : ''}>Email</option>
                                <option value="slack" ${node.config.channel === 'slack' ? 'selected' : ''}>Slack</option>
                                <option value="teams" ${node.config.channel === 'teams' ? 'selected' : ''}>Microsoft Teams</option>
                                <option value="sms" ${node.config.channel === 'sms' ? 'selected' : ''}>SMS</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Recipient</label>
                            ${availableFields.filter(f => f.type === 'email' || f.type === 'text').length > 0 ? `
                                <select class="property-select" onchange="updateNodeConfig('${node.id}', 'recipient', this.value)">
                                    <option value="">-- Select Field --</option>
                                    ${availableFields.filter(f => f.type === 'email' || f.type === 'text').map(f => `
                                        <option value="{{${f.name}}}" ${node.config.recipient === '{{' + f.name + '}}' ? 'selected' : ''}>
                                            ${f.name} (${f.type})
                                        </option>
                                    `).join('')}
                                    <option value="_custom">âœï¸ Custom...</option>
                                </select>
                            ` : ''}
                            <input type="text" class="property-input" ${availableFields.length > 0 ? 'style="margin-top:8px;"' : ''} 
                                   placeholder="email@example.com or {{field_name}}" 
                                   value="${node.config.recipient || ''}"
                                   onchange="updateNodeConfig('${node.id}', 'recipient', this.value)">
                        </div>
                        <div class="property-group">
                            <label class="property-label">Message Template</label>
                            <textarea class="property-textarea" placeholder="Enter message template..."
                                      onchange="updateNodeConfig('${node.id}', 'template', this.value)">${node.config.template || ''}</textarea>
                            ${availableFields.length > 0 ? `
                                <div style="margin-top:8px;padding:8px;background:#1a1f2e;border-radius:6px;">
                                    <div style="font-size:11px;color:#6b7280;margin-bottom:6px;">ğŸ“‹ Available Fields (click to insert):</div>
                                    <div style="display:flex;flex-wrap:wrap;gap:4px;">
                                        ${availableFields.map(f => `
                                            <button onclick="insertFieldRef('${node.id}', 'template', '{{${f.name}}}')" 
                                                    style="padding:4px 8px;background:#374151;border:none;border-radius:4px;color:#a5b4fc;font-size:11px;cursor:pointer;">
                                                {{${f.name}}}
                                            </button>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                    break;
                    
                case 'ai':
                    html += `
                        <div class="property-group">
                            <label class="property-label">AI Prompt</label>
                            <textarea class="property-textarea" style="min-height:120px;" 
                                      placeholder="Describe what the AI should do..."
                                      onchange="updateNodeConfig('${node.id}', 'prompt', this.value)">${node.config.prompt || ''}</textarea>
                            ${availableFields.length > 0 ? `
                                <div style="margin-top:8px;padding:8px;background:#1a1f2e;border-radius:6px;">
                                    <div style="font-size:11px;color:#6b7280;margin-bottom:6px;">ğŸ“‹ Available Fields (click to insert):</div>
                                    <div style="display:flex;flex-wrap:wrap;gap:4px;">
                                        ${availableFields.map(f => `
                                            <button onclick="insertFieldRef('${node.id}', 'prompt', '{{${f.name}}}')" 
                                                    style="padding:4px 8px;background:#374151;border:none;border-radius:4px;color:#a5b4fc;font-size:11px;cursor:pointer;">
                                                {{${f.name}}}
                                            </button>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        <div class="property-group">
                            <label class="property-label">AI Model</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'model', this.value)">
                                <option value="gpt-4o" ${node.config.model === 'gpt-4o' ? 'selected' : ''}>GPT-4o (Fast)</option>
                                <option value="gpt-4o-mini" ${node.config.model === 'gpt-4o-mini' ? 'selected' : ''}>GPT-4o Mini</option>
                                <option value="claude-sonnet-4-20250514" ${node.config.model === 'claude-sonnet-4-20250514' ? 'selected' : ''}>Claude Sonnet</option>
                            </select>
                        </div>
                    `;
                    break;
                
                case 'form':
                case 'trigger':
                    // Form fields editor
                    const fields = node.config.fields || [];
                    html += `
                        <div class="property-group">
                            <label class="property-label">Form Title</label>
                            <input type="text" class="property-input" placeholder="e.g., Submit Expense Report" 
                                   value="${node.config.title || ''}"
                                   onchange="updateNodeConfig('${node.id}', 'title', this.value)">
                        </div>
                        <div class="property-group">
                            <label class="property-label">Input Fields</label>
                            <div id="form-fields-list" style="margin-bottom:12px;">
                                ${fields.length === 0 ? '<div style="color:#6b7280;font-size:12px;padding:8px;">No fields yet. Add some below.</div>' : ''}
                                ${fields.map((f, idx) => `
                                    <div class="form-field-item" style="display:flex;gap:8px;align-items:center;margin-bottom:8px;padding:8px;background:#1a1f2e;border-radius:6px;">
                                        <input type="text" class="property-input" style="flex:1;margin:0;" placeholder="Field name"
                                               value="${f.name || ''}"
                                               onchange="updateFormField('${node.id}', ${idx}, 'name', this.value)">
                                        <select class="property-select" style="width:100px;margin:0;"
                                                onchange="updateFormField('${node.id}', ${idx}, 'type', this.value)">
                                            <option value="text" ${f.type === 'text' ? 'selected' : ''}>Text</option>
                                            <option value="number" ${f.type === 'number' ? 'selected' : ''}>Number</option>
                                            <option value="email" ${f.type === 'email' ? 'selected' : ''}>Email</option>
                                            <option value="date" ${f.type === 'date' ? 'selected' : ''}>Date</option>
                                            <option value="textarea" ${f.type === 'textarea' ? 'selected' : ''}>Long Text</option>
                                            <option value="select" ${f.type === 'select' ? 'selected' : ''}>Dropdown</option>
                                            <option value="file" ${f.type === 'file' ? 'selected' : ''}>File</option>
                                        </select>
                                        <label style="display:flex;align-items:center;gap:4px;font-size:11px;color:#9ca3af;">
                                            <input type="checkbox" ${f.required ? 'checked' : ''} 
                                                   onchange="updateFormField('${node.id}', ${idx}, 'required', this.checked)">
                                            Req
                                        </label>
                                        <button onclick="removeFormField('${node.id}', ${idx})" 
                                                style="background:#ef4444;border:none;color:white;width:24px;height:24px;border-radius:4px;cursor:pointer;">Ã—</button>
                                    </div>
                                `).join('')}
                            </div>
                            <button onclick="addFormField('${node.id}')" 
                                    style="width:100%;padding:10px;background:#22c55e;border:none;border-radius:8px;color:white;cursor:pointer;font-size:13px;">
                                + Add Input Field
                            </button>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Submit Button Text</label>
                            <input type="text" class="property-input" placeholder="Submit" 
                                   value="${node.config.submitText || 'Submit'}"
                                   onchange="updateNodeConfig('${node.id}', 'submitText', this.value)">
                        </div>
                    `;
                    break;
                
                case 'schedule':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Schedule (Cron Expression)</label>
                            <input type="text" class="property-input" placeholder="0 9 * * *" 
                                   value="${node.config.cron || '0 9 * * *'}"
                                   onchange="updateNodeConfig('${node.id}', 'cron', this.value)">
                            <div style="font-size:11px;color:#6b7280;margin-top:4px;">
                                Format: minute hour day month weekday<br>
                                Examples: "0 9 * * *" (daily 9AM), "0 */4 * * *" (every 4 hours)
                            </div>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Timezone</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'timezone', this.value)">
                                <option value="UTC" ${node.config.timezone === 'UTC' ? 'selected' : ''}>UTC</option>
                                <option value="America/New_York" ${node.config.timezone === 'America/New_York' ? 'selected' : ''}>Eastern (US)</option>
                                <option value="America/Los_Angeles" ${node.config.timezone === 'America/Los_Angeles' ? 'selected' : ''}>Pacific (US)</option>
                                <option value="Europe/London" ${node.config.timezone === 'Europe/London' ? 'selected' : ''}>London</option>
                                <option value="Europe/Paris" ${node.config.timezone === 'Europe/Paris' ? 'selected' : ''}>Paris</option>
                                <option value="Asia/Dubai" ${node.config.timezone === 'Asia/Dubai' ? 'selected' : ''}>Dubai</option>
                                <option value="Africa/Cairo" ${node.config.timezone === 'Africa/Cairo' ? 'selected' : ''}>Cairo</option>
                                <option value="Asia/Tokyo" ${node.config.timezone === 'Asia/Tokyo' ? 'selected' : ''}>Tokyo</option>
                            </select>
                        </div>
                    `;
                    break;
                
                case 'webhook':
                    html += `
                        <div class="property-group">
                            <label class="property-label">HTTP Method</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'method', this.value)">
                                <option value="POST" ${node.config.method === 'POST' ? 'selected' : ''}>POST</option>
                                <option value="GET" ${node.config.method === 'GET' ? 'selected' : ''}>GET</option>
                                <option value="PUT" ${node.config.method === 'PUT' ? 'selected' : ''}>PUT</option>
                                <option value="PATCH" ${node.config.method === 'PATCH' ? 'selected' : ''}>PATCH</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Webhook Path</label>
                            <input type="text" class="property-input" placeholder="/trigger" 
                                   value="${node.config.path || '/trigger'}"
                                   onchange="updateNodeConfig('${node.id}', 'path', this.value)">
                            <div style="font-size:11px;color:#6b7280;margin-top:4px;">
                                Full URL: /api/webhooks/process/{id}${node.config.path || '/trigger'}
                            </div>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Authentication</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'auth', this.value)">
                                <option value="none" ${node.config.auth === 'none' ? 'selected' : ''}>None</option>
                                <option value="api_key" ${node.config.auth === 'api_key' ? 'selected' : ''}>API Key</option>
                                <option value="bearer" ${node.config.auth === 'bearer' ? 'selected' : ''}>Bearer Token</option>
                            </select>
                        </div>
                    `;
                    break;
                
                case 'loop':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Collection to Iterate</label>
                            ${availableFields.length > 0 ? `
                                <select class="property-select" onchange="updateNodeConfig('${node.id}', 'collection', this.value)">
                                    <option value="">-- Select Field --</option>
                                    ${availableFields.map(f => `
                                        <option value="${f.name}" ${node.config.collection === f.name ? 'selected' : ''}>
                                            ${f.name} (${f.type}) - from ${f.source}
                                        </option>
                                    `).join('')}
                                    <option value="_custom" ${node.config.collection && !availableFields.find(f => f.name === node.config.collection) ? 'selected' : ''}>
                                        âœï¸ Custom...
                                    </option>
                                </select>
                                ${(node.config.collection && !availableFields.find(f => f.name === node.config.collection)) ? `
                                    <input type="text" class="property-input" style="margin-top:8px;" placeholder="e.g., items, data.results" 
                                           value="${node.config.collection || ''}"
                                           onchange="updateNodeConfig('${node.id}', 'collection', this.value)">
                                ` : ''}
                            ` : `
                                <input type="text" class="property-input" placeholder="e.g., items, users, data.results" 
                                       value="${node.config.collection || ''}"
                                       onchange="updateNodeConfig('${node.id}', 'collection', this.value)">
                            `}
                            <div style="font-size:11px;color:#6b7280;margin-top:4px;">
                                The array/list to iterate over
                            </div>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Item Variable Name</label>
                            <input type="text" class="property-input" placeholder="item" 
                                   value="${node.config.itemVar || 'item'}"
                                   onchange="updateNodeConfig('${node.id}', 'itemVar', this.value)">
                            <div style="font-size:11px;color:#6b7280;margin-top:4px;">
                                Access current item with: {{${node.config.itemVar || 'item'}}}
                            </div>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Max Iterations</label>
                            <input type="number" class="property-input" placeholder="100" 
                                   value="${node.config.maxIterations || 100}"
                                   onchange="updateNodeConfig('${node.id}', 'maxIterations', parseInt(this.value))">
                        </div>
                    `;
                    break;
                
                case 'end':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Output Variable</label>
                            <input type="text" class="property-input" placeholder="e.g., result, response" 
                                   value="${node.config.output || ''}"
                                   onchange="updateNodeConfig('${node.id}', 'output', this.value)">
                            <div style="font-size:11px;color:#6b7280;margin-top:4px;">
                                The variable to return as workflow result
                            </div>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Success Message</label>
                            <textarea class="property-textarea" placeholder="Workflow completed successfully"
                                      onchange="updateNodeConfig('${node.id}', 'successMessage', this.value)">${node.config.successMessage || ''}</textarea>
                        </div>
                    `;
                    break;
                
                case 'action':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Action Description</label>
                            <textarea class="property-textarea" placeholder="Describe what this action does..."
                                      onchange="updateNodeConfig('${node.id}', 'description', this.value)">${node.config.description || ''}</textarea>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Action Type</label>
                            <select class="property-select" onchange="updateNodeConfig('${node.id}', 'actionType', this.value)">
                                <option value="custom" ${node.config.actionType === 'custom' ? 'selected' : ''}>Custom Action</option>
                                <option value="http" ${node.config.actionType === 'http' ? 'selected' : ''}>HTTP Request</option>
                                <option value="script" ${node.config.actionType === 'script' ? 'selected' : ''}>Run Script</option>
                                <option value="transform" ${node.config.actionType === 'transform' ? 'selected' : ''}>Transform Data</option>
                            </select>
                        </div>
                    `;
                    break;
                    
                default:
                    html += `
                        <div class="property-group">
                            <label class="property-label">Description</label>
                            <textarea class="property-textarea" placeholder="What does this step do?"
                                      onchange="updateNodeConfig('${node.id}', 'description', this.value)">${node.config.description || ''}</textarea>
                        </div>
                    `;
            }
            
            // Delete button
            html += `
                <div style="margin-top:24px; padding-top:16px; border-top:1px solid #2d3748;">
                    <button onclick="deleteNode('${node.id}')" 
                            style="width:100%; padding:10px; background:#ef4444; border:none; border-radius:8px; color:white; cursor:pointer;">
                        ğŸ—‘ï¸ Delete Node
                    </button>
                </div>
            `;
            
            return html;
        }
        
        function closeProperties() {
            document.getElementById('properties-panel').classList.remove('active');
        }
        
        function updateNodeProperty(nodeId, prop, value) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node) {
                node[prop] = value;
                refreshNode(node);
                saveToUndo();
            }
        }
        
        function updateNodeConfig(nodeId, key, value) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node) {
                node.config[key] = value;
                refreshNode(node);
                saveToUndo();
            }
        }
        
        function selectTool(nodeId, toolId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node) {
                const tool = state.tools.find(t => t.id === toolId);
                node.config.toolId = toolId;
                if (tool) node.name = tool.name;
                refreshNode(node);
                showProperties(node); // Refresh panel
                saveToUndo();
            }
        }
        
        // Approval config modal (Approvers from Platform User / Role / Group / Tool)
        let approvalConfigNodeId = null;
        async function openApprovalConfigModal(nodeId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;
            approvalConfigNodeId = nodeId;
            const modal = document.getElementById('approval-config-modal');
            const cfg = node.config || {};
            let source = cfg.assignee_source || '';
            if (!source && (cfg.approvers || []).length) source = 'platform_user';
            if (!source) source = 'platform_user';
            const assigneeIds = cfg.assignee_ids || cfg.approvers || [];
            const assigneeToolId = cfg.assignee_tool_id || '';
            const token = getAuthToken();
            const headers = { 'Authorization': 'Bearer ' + token };
            let users = [], roles = [], groups = [], tools = [];
            try {
                const [uRes, rRes, gRes, tRes] = await Promise.all([
                    fetch('/api/security/users', { headers }),
                    fetch('/api/security/roles', { headers }),
                    fetch('/api/security/groups', { headers }),
                    fetch('/api/tools/accessible', { headers })
                ]);
                if (uRes.ok) { const d = await uRes.json(); users = Array.isArray(d) ? d : (d.users || []); }
                if (rRes.ok) { const d = await rRes.json(); roles = Array.isArray(d) ? d : (d.roles || []); }
                if (gRes.ok) { const d = await gRes.json(); groups = Array.isArray(d) ? d : (d.groups || []); }
                if (tRes.ok) { const d = await tRes.json(); tools = d.tools || []; }
            } catch (e) { console.error('Load approval options:', e); }
            const userOpts = users.map(u => '<option value="' + u.id + '"' + (assigneeIds.includes(u.id) ? ' selected' : '') + '>' + (u.name || u.email || u.id).substring(0, 40) + '</option>').join('');
            const roleOpts = roles.map(r => '<option value="' + r.id + '"' + (assigneeIds.includes(r.id) ? ' selected' : '') + '>' + (r.name || r.id).substring(0, 40) + '</option>').join('');
            const groupOpts = groups.map(g => '<option value="' + g.id + '"' + (assigneeIds.includes(g.id) ? ' selected' : '') + '>' + (g.name || g.id).substring(0, 40) + '</option>').join('');
            const toolOpts = tools.map(t => '<option value="' + t.id + '"' + (assigneeToolId === t.id ? ' selected' : '') + '>' + (t.name || t.id).substring(0, 40) + '</option>').join('');
            document.getElementById('approval-config-source').value = source;
            document.getElementById('approval-config-user-list').innerHTML = userOpts;
            document.getElementById('approval-config-role-list').innerHTML = roleOpts;
            document.getElementById('approval-config-group-list').innerHTML = groupOpts;
            document.getElementById('approval-config-tool').innerHTML = '<option value="">â€” None â€”</option>' + toolOpts;
            document.getElementById('approval-config-tool').value = assigneeToolId;
            onApprovalConfigSourceChange();
            modal.classList.add('show');
        }
        function onApprovalConfigSourceChange() {
            const v = document.getElementById('approval-config-source').value;
            document.getElementById('approval-config-platform-user-wrap').classList.toggle('hidden', v !== 'platform_user');
            document.getElementById('approval-config-platform-role-wrap').classList.toggle('hidden', v !== 'platform_role');
            document.getElementById('approval-config-platform-group-wrap').classList.toggle('hidden', v !== 'platform_group');
            document.getElementById('approval-config-tool-wrap').classList.toggle('hidden', v !== 'tool');
        }
        function saveApprovalConfig() {
            if (!approvalConfigNodeId) return;
            const node = state.nodes.find(n => n.id === approvalConfigNodeId);
            if (!node) { approvalConfigNodeId = null; return; }
            const source = document.getElementById('approval-config-source').value;
            const userList = document.getElementById('approval-config-user-list');
            const roleList = document.getElementById('approval-config-role-list');
            const groupList = document.getElementById('approval-config-group-list');
            const toolSelect = document.getElementById('approval-config-tool');
            const assigneeIds = [];
            if (source === 'platform_user') { for (let i = 0; i < userList.options.length; i++) if (userList.options[i].selected) assigneeIds.push(userList.options[i].value); }
            else if (source === 'platform_role') { for (let i = 0; i < roleList.options.length; i++) if (roleList.options[i].selected) assigneeIds.push(roleList.options[i].value); }
            else if (source === 'platform_group') { for (let i = 0; i < groupList.options.length; i++) if (groupList.options[i].selected) assigneeIds.push(groupList.options[i].value); }
            const assigneeType = source === 'platform_user' ? 'user' : source === 'platform_role' ? 'role' : source === 'platform_group' ? 'group' : 'user';
            node.config.assignee_source = source;
            node.config.assignee_type = assigneeType;
            node.config.assignee_ids = assigneeIds;
            node.config.assignee_tool_id = source === 'tool' ? (toolSelect.value || '') : undefined;
            if (node.config.approvers !== undefined) delete node.config.approvers;
            document.getElementById('approval-config-modal').classList.remove('show');
            approvalConfigNodeId = null;
            refreshNode(node);
            showProperties(node);
            saveToUndo();
        }
        function closeApprovalConfigModal() {
            document.getElementById('approval-config-modal').classList.remove('show');
            approvalConfigNodeId = null;
        }
        
        // Form field management functions
        function addFormField(nodeId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node) {
                if (!node.config.fields) node.config.fields = [];
                node.config.fields.push({
                    name: '',
                    type: 'text',
                    required: false,
                    placeholder: ''
                });
                refreshNode(node);
                showProperties(node);
                saveToUndo();
            }
        }
        
        function updateFormField(nodeId, fieldIndex, key, value) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node && node.config.fields && node.config.fields[fieldIndex]) {
                node.config.fields[fieldIndex][key] = value;
                refreshNode(node);
                saveToUndo();
            }
        }
        
        function removeFormField(nodeId, fieldIndex) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node && node.config.fields) {
                node.config.fields.splice(fieldIndex, 1);
                refreshNode(node);
                showProperties(node);
                saveToUndo();
            }
        }
        
        // Helper to insert field references into textareas
        function insertFieldRef(nodeId, configKey, fieldRef) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node) {
                const currentValue = node.config[configKey] || '';
                node.config[configKey] = currentValue + (currentValue ? ' ' : '') + fieldRef;
                refreshNode(node);
                showProperties(node);
                saveToUndo();
            }
        }
        
        function refreshNode(node) {
            const oldEl = document.getElementById(node.id);
            if (oldEl) {
                oldEl.remove();
                renderNode(node);
                const el = document.getElementById(node.id);
                if (el) {
                    if (state.selectedNodeIds.includes(node.id)) el.classList.add(state.selectedNodeIds.length > 1 ? 'multi-selected' : (state.selectedLabelNodeId === node.id ? 'label-selected' : 'selected'));
                    else if (state.selectedLabelNodeId === node.id) el.classList.add('label-selected');
                }
                renderConnections();
            }
        }
        
        function deleteNode(nodeId) {
            if (!confirm('Delete this node?')) return;
            
            if (state.selectedNode && state.selectedNode.id === nodeId) state.selectedNode = null;
            if (state.selectedLabelNodeId === nodeId) state.selectedLabelNodeId = null;
            state.connections = state.connections.filter(c => c.from !== nodeId && c.to !== nodeId);
            state.nodes = state.nodes.filter(n => n.id !== nodeId);
            document.getElementById(nodeId)?.remove();
            closeProperties();
            renderConnections();
            updateEmptyState();
            saveToUndo();
        }
        
        function showNodeMenu(nodeId) {
            // Simple delete for now
            if (confirm('Delete this node?')) {
                deleteNode(nodeId);
            }
        }
        
        // ===== TOOLS =====
        function getAuthToken() {
            return localStorage.getItem('agentforge_token') || sessionStorage.getItem('agentforge_token');
        }
        
        function loadTools() {
            const token = getAuthToken();
            fetch('/api/tools', {
                headers: { 'Authorization': 'Bearer ' + token }
            })
            .then(r => r.json())
            .then(data => {
                state.tools = data.tools || [];
                renderToolsPalette();
            })
            .catch(e => {
                console.error('Failed to load tools:', e);
            });
        }
        
        function renderToolsPalette() {
            const container = document.getElementById('platform-tools-list');
            
            if (!state.tools.length) {
                container.innerHTML = '<div style="font-size:11px;color:#6b7280;padding:8px;">No tools available</div>';
                return;
            }
            
            container.innerHTML = state.tools.map(t => `
                <div class="palette-item" draggable="true" data-type="tool" data-tool-id="${t.id}">
                    <div class="palette-icon tool palette-shape-task">${getTypeSvgIcon('tool')}</div>
                    <div class="palette-info">
                        <div class="palette-name">${t.name}</div>
                        <div class="palette-desc">${t.type}</div>
                    </div>
                </div>
            `).join('');
            
            container.querySelectorAll('.palette-item').forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('nodeType', 'tool');
                    e.dataTransfer.setData('toolId', item.dataset.toolId);
                });
            });
        }
        
        function getToolIcon(type) {
            const icons = {
                api: 'ğŸŒ',
                database: 'ğŸ—„ï¸',
                knowledge_base: 'ğŸ“š',
                email: 'ğŸ“§',
                website: 'ğŸ”—'
            };
            return icons[type] || 'ğŸ”§';
        }
        
        // ===== ZOOM =====
        function zoomIn() {
            state.zoom = Math.min(state.zoom * 1.2, 2);
            updateCanvasTransform();
            document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%';
        }
        
        function zoomOut() {
            state.zoom = Math.max(state.zoom * 0.8, 0.25);
            updateCanvasTransform();
            document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%';
        }
        
        function zoomReset() {
            state.zoom = 1;
            state.panX = 0;
            state.panY = 0;
            updateCanvasTransform();
            document.getElementById('zoom-level').textContent = '100%';
        }
        
        function zoomFit() {
            if (state.nodes.length === 0) return;
            const container = document.getElementById('canvas-container');
            const padding = 80;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.nodes.forEach(n => {
                const el = document.getElementById(n.id);
                if (!el) return;
                const w = el.offsetWidth || 200, h = el.offsetHeight || 80;
                minX = Math.min(minX, n.x);
                minY = Math.min(minY, n.y);
                maxX = Math.max(maxX, n.x + w);
                maxY = Math.max(maxY, n.y + h);
            });
            const cw = container.clientWidth, ch = container.clientHeight;
            const bw = maxX - minX + padding * 2, bh = maxY - minY + padding * 2;
            const scale = Math.min(cw / bw, ch / bh, 2);
            state.zoom = Math.max(0.25, scale);
            const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
            state.panX = cw / 2 - cx * state.zoom;
            state.panY = ch / 2 - cy * state.zoom;
            updateCanvasTransform();
            document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%';
        }
        
        // ===== UNDO/REDO =====
        function saveToUndo() {
            state.undoStack.push(JSON.stringify({ nodes: state.nodes, connections: state.connections }));
            state.redoStack = [];
        }
        
        function undoAction() {
            if (state.undoStack.length > 1) {
                state.redoStack.push(state.undoStack.pop());
                const prev = JSON.parse(state.undoStack[state.undoStack.length - 1]);
                restoreState(prev);
            }
        }
        
        function redoAction() {
            if (state.redoStack.length > 0) {
                const next = JSON.parse(state.redoStack.pop());
                state.undoStack.push(JSON.stringify(next));
                restoreState(next);
            }
        }
        
        function restoreState(data) {
            state.nodes = data.nodes;
            state.connections = data.connections;
            
            // Clear and re-render
            document.getElementById('canvas').innerHTML = '';
            state.nodes.forEach(n => renderNode(n));
            renderConnections();
            updateEmptyState();
        }
        
        // ===== SAVE/LOAD =====
        function loadWorkflowFromUrl() {
            const params = new URLSearchParams(window.location.search);
            const agentId = params.get('agent');
            
            if (agentId) {
                state.agentId = agentId;
                loadWorkflow(agentId);
            } else {
                // New workflow - add start node
                createNode('trigger', 400, 100);
            }
        }
        
        async function loadWorkflow(agentId) {
            try {
                const token = getAuthToken();
                const response = await fetch('/api/agents/' + agentId, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                
                if (!response.ok) throw new Error('Failed to load');
                
                const agent = await response.json();
                document.getElementById('workflow-name').value = agent.name || 'My Workflow';
                
                if (agent.process_definition) {
                    const def = agent.process_definition;
                    state.nodes = def.nodes || [];
                    state.connections = def.edges || [];
                    
                    // ØªØ¬Ù†Ø¨ ØªÙƒØ±Ø§Ø± Ø§Ù„Ù€ id: Ø£ÙŠ Ø¹Ù‚Ø¯Ø© Ø¬Ø¯ÙŠØ¯Ø© ØªØ£Ø®Ø° id Ø£ÙƒØ¨Ø± Ù…Ù† ÙƒÙ„ Ø§Ù„Ø¹Ù‚Ø¯ Ø§Ù„Ù…Ø­Ù…Ù„Ø©
                    let maxNum = 0;
                    state.nodes.forEach(n => {
                        const m = (n.id || '').match(/^node_(\d+)$/);
                        if (m) maxNum = Math.max(maxNum, parseInt(m[1], 10));
                    });
                    nodeIdCounter = maxNum + 1;
                    
                    state.nodes.forEach(n => renderNode(n));
                    renderConnections();
                    updateEmptyState();
                }
            } catch (e) {
                console.error('Load error:', e);
                alert('Could not load workflow');
            }
        }
        
        async function saveWorkflow() {
            const name = document.getElementById('workflow-name').value;
            const def = {
                nodes: state.nodes,
                edges: state.connections
            };
            
            const token = getAuthToken();
            if (!token) {
                alert('âŒ Please sign in first. Save and Publish require authentication.\n\nIf you opened the Workflow Builder in a new tab, try opening it from the main app (Create â†’ Workflow â†’ Visual Builder) after signing in.');
                return;
            }
            
            try {
                const method = state.agentId ? 'PUT' : 'POST';
                const url = state.agentId ? '/api/agents/' + state.agentId : '/api/agents';
                
                const body = state.agentId ? {
                    name,
                    goal: 'Workflow automation',
                    process_definition: def,
                    status: 'draft'
                } : {
                    name,
                    goal: 'Workflow automation',
                    agent_type: 'process',
                    personality: {},
                    tasks: [],
                    tool_ids: [],
                    model_id: 'gpt-4o',
                    process_definition: def,
                    process_settings: {},
                    status: 'draft'
                };
                
                const response = await fetch(url, {
                    method,
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify(body)
                });
                
                let errMsg = 'Could not save workflow';
                if (!response.ok) {
                    try {
                        const errBody = await response.json();
                        errMsg = errBody.detail || errBody.message || errMsg;
                        if (Array.isArray(errMsg)) errMsg = errMsg.map(d => d.msg || JSON.stringify(d)).join('; ');
                    } catch (_) {
                        errMsg = await response.text() || response.statusText || errMsg;
                    }
                    throw new Error(errMsg);
                }
                
                const data = await response.json();
                if (!state.agentId) {
                    state.agentId = data.agent_id || data.id;
                    window.history.replaceState({}, '', '?agent=' + state.agentId);
                }
                
                alert('âœ… Workflow saved!');
            } catch (e) {
                console.error('Save error:', e);
                alert('âŒ ' + (e.message || 'Could not save workflow'));
            }
        }
        
        async function publishWorkflow() {
            if (!state.agentId) {
                await saveWorkflow();
                if (!state.agentId) return;
            } else {
                await saveWorkflow();
            }
            
            const token = getAuthToken();
            if (!token) {
                alert('âŒ Please sign in first.');
                return;
            }
            
            try {
                const response = await fetch('/api/agents/' + state.agentId, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({ status: 'published', is_published: true })
                });
                
                let errMsg = 'Could not publish workflow';
                if (!response.ok) {
                    try {
                        const errBody = await response.json();
                        errMsg = errBody.detail || errBody.message || errMsg;
                        if (Array.isArray(errMsg)) errMsg = errMsg.map(d => d.msg || JSON.stringify(d)).join('; ');
                    } catch (_) {
                        errMsg = await response.text() || response.statusText || errMsg;
                    }
                    throw new Error(errMsg);
                }
                
                alert('ğŸš€ Workflow published!');
            } catch (e) {
                console.error('Publish error:', e);
                alert('âŒ ' + (e.message || 'Could not publish workflow'));
            }
        }
        
        function testWorkflow() {
            // Get available input fields
            const fields = getAvailableFields();
            
            if (fields.length === 0) {
                alert('No input fields found. Add fields to your Start/Form node first.');
                return;
            }
            
            // Create test modal
            const modal = document.createElement('div');
            modal.id = 'test-workflow-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.8); display: flex; align-items: center; 
                justify-content: center; z-index: 10000;
            `;
            
            modal.innerHTML = `
                <div style="background:#1f2937; border-radius:12px; width:500px; max-width:90%; max-height:80vh; overflow:auto;">
                    <div style="padding:20px; border-bottom:1px solid #374151;">
                        <h2 style="margin:0; font-size:18px;">â–¶ï¸ Test Workflow</h2>
                        <p style="margin:8px 0 0; color:#9ca3af; font-size:13px;">Fill in the input values to simulate the workflow</p>
                    </div>
                    <div style="padding:20px;">
                        <form id="test-workflow-form">
                            ${fields.map(f => `
                                <div style="margin-bottom:16px;">
                                    <label style="display:block; margin-bottom:6px; font-size:13px; color:#d1d5db;">
                                        ${f.name} ${f.required ? '<span style="color:#ef4444;">*</span>' : ''}
                                        <span style="color:#6b7280; font-size:11px;">(${f.type})</span>
                                    </label>
                                    ${f.type === 'textarea' ? `
                                        <textarea name="${f.name}" style="width:100%; padding:10px; background:#111827; border:1px solid #374151; border-radius:6px; color:white; min-height:80px;" 
                                                  placeholder="Enter ${f.name}..." ${f.required ? 'required' : ''}></textarea>
                                    ` : `
                                        <input type="${f.type === 'number' ? 'number' : f.type === 'email' ? 'email' : f.type === 'date' ? 'date' : 'text'}" 
                                               name="${f.name}" 
                                               style="width:100%; padding:10px; background:#111827; border:1px solid #374151; border-radius:6px; color:white;" 
                                               placeholder="Enter ${f.name}..." ${f.required ? 'required' : ''}>
                                    `}
                                </div>
                            `).join('')}
                        </form>
                    </div>
                    <div style="padding:20px; border-top:1px solid #374151; display:flex; gap:12px; justify-content:flex-end;">
                        <button onclick="closeTestModal()" style="padding:10px 20px; background:#374151; border:none; border-radius:6px; color:white; cursor:pointer;">
                            Cancel
                        </button>
                        <button onclick="runWorkflowTest()" style="padding:10px 20px; background:#22c55e; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:500;">
                            â–¶ï¸ Run Test
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function closeTestModal() {
            const modal = document.getElementById('test-workflow-modal');
            if (modal) modal.remove();
        }
        
        function runWorkflowTest() {
            const form = document.getElementById('test-workflow-form');
            const formData = new FormData(form);
            const inputData = {};
            
            for (let [key, value] of formData.entries()) {
                inputData[key] = value;
            }
            
            // Simulate workflow execution
            simulateWorkflow(inputData);
        }
        
        function simulateWorkflow(inputData) {
            closeTestModal();
            
            // Create results modal
            const modal = document.createElement('div');
            modal.id = 'test-results-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.8); display: flex; align-items: center; 
                justify-content: center; z-index: 10000;
            `;
            
            // Trace through the workflow
            const trace = [];
            let currentNode = state.nodes.find(n => n.type === 'trigger' || n.type === 'form');
            
            if (!currentNode) {
                currentNode = state.nodes.find(n => n.type === 'schedule' || n.type === 'webhook');
            }
            
            if (!currentNode) {
                alert('No start node found');
                return;
            }
            
            trace.push({ node: currentNode, status: 'completed', message: 'Workflow started with input data' });
            
            // Follow the workflow path
            let maxSteps = 20; // Prevent infinite loops
            while (currentNode && maxSteps > 0) {
                maxSteps--;
                
                // Find outgoing connection
                const connections = state.connections.filter(c => c.from === currentNode.id);
                
                if (connections.length === 0) {
                    // End node or no connections
                    if (currentNode.type === 'end') {
                        trace.push({ node: currentNode, status: 'completed', message: 'Workflow completed' });
                    }
                    break;
                }
                
                // Handle condition nodes
                if (currentNode.type === 'condition') {
                    const field = currentNode.config.field;
                    const operator = currentNode.config.operator;
                    const compareValue = currentNode.config.value;
                    const inputValue = inputData[field];
                    
                    let result = false;
                    switch (operator) {
                        case 'equals': result = inputValue == compareValue; break;
                        case 'not_equals': result = inputValue != compareValue; break;
                        case 'greater_than': result = parseFloat(inputValue) > parseFloat(compareValue); break;
                        case 'less_than': result = parseFloat(inputValue) < parseFloat(compareValue); break;
                        case 'contains': result = String(inputValue).includes(compareValue); break;
                        case 'is_empty': result = !inputValue || inputValue === ''; break;
                    }
                    
                    trace.push({ 
                        node: currentNode, 
                        status: 'completed', 
                        message: `Checked: ${field} (${inputValue}) ${operator} ${compareValue} â†’ ${result ? 'YES' : 'NO'}` 
                    });
                    
                    // Find the correct path (yes or no) - connections use .type not .output
                    const nextConnection = connections.find(c => c.type === (result ? 'yes' : 'no'));
                    if (nextConnection) {
                        currentNode = state.nodes.find(n => n.id === nextConnection.to);
                    } else {
                        // Fallback - take first connection
                        currentNode = state.nodes.find(n => n.id === connections[0].to);
                    }
                } else {
                    // Regular node - add to trace and follow first connection
                    let message = '';
                    switch (currentNode.type) {
                        case 'approval':
                            const ac = currentNode.config || {};
                            const aSrc = ac.assignee_source || (ac.approvers && ac.approvers.length ? 'platform_user' : '');
                            const aIds = ac.assignee_ids || ac.approvers || [];
                            message = aSrc ? `Approval requested from: ${aSrc.replace('platform_','')} (${aIds.length} selected)` : 'Approval requested (not configured)';
                            break;
                        case 'notification':
                            let template = currentNode.config.template || '';
                            Object.keys(inputData).forEach(key => {
                                template = template.replace(new RegExp('\\{\\{' + key + '\\}\\}', 'g'), inputData[key]);
                            });
                            message = `Notification sent: "${template.substring(0, 50)}..."`;
                            break;
                        case 'ai':
                            message = `AI processed with model: ${currentNode.config.model || 'gpt-4o'}`;
                            break;
                        case 'delay':
                            message = `Waiting ${currentNode.config.duration} ${currentNode.config.unit}`;
                            break;
                        default:
                            message = `Executed: ${currentNode.name}`;
                    }
                    
                    if (currentNode.type !== 'trigger' && currentNode.type !== 'form') {
                        trace.push({ node: currentNode, status: 'completed', message });
                    }
                    
                    currentNode = state.nodes.find(n => n.id === connections[0].to);
                }
            }
            
            // Display results
            modal.innerHTML = `
                <div style="background:#1f2937; border-radius:12px; width:600px; max-width:90%; max-height:80vh; overflow:auto;">
                    <div style="padding:20px; border-bottom:1px solid #374151;">
                        <h2 style="margin:0; font-size:18px;">ğŸ“Š Test Results</h2>
                    </div>
                    <div style="padding:20px;">
                        <div style="margin-bottom:16px; padding:12px; background:#111827; border-radius:8px;">
                            <div style="font-size:12px; color:#6b7280; margin-bottom:8px;">INPUT DATA:</div>
                            <pre style="margin:0; color:#a5b4fc; font-size:12px;">${JSON.stringify(inputData, null, 2)}</pre>
                        </div>
                        
                        <div style="font-size:12px; color:#6b7280; margin-bottom:12px;">EXECUTION TRACE:</div>
                        ${trace.map((t, i) => `
                            <div style="display:flex; gap:12px; margin-bottom:12px;">
                                <div style="width:24px; height:24px; border-radius:50%; background:${t.status === 'completed' ? '#22c55e' : '#ef4444'}; display:flex; align-items:center; justify-content:center; font-size:12px;">
                                    ${t.status === 'completed' ? 'âœ“' : 'âœ—'}
                                </div>
                                <div style="flex:1;">
                                    <div style="font-weight:500;">${t.node.name}</div>
                                    <div style="font-size:12px; color:#9ca3af;">${t.message}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <div style="padding:20px; border-top:1px solid #374151; display:flex; justify-content:flex-end;">
                        <button onclick="document.getElementById('test-results-modal').remove()" 
                                style="padding:10px 20px; background:#6366f1; border:none; border-radius:6px; color:white; cursor:pointer;">
                            Close
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function updateEmptyState() {
            const empty = document.getElementById('empty-state');
            empty.style.display = state.nodes.length === 0 ? 'block' : 'none';
        }
    </script>
</body>
</html>
